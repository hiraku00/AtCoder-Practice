# 東京大学「Pythonプログラミング入門」
https://utokyo-ipp.github.io/

---

# 5-3

```python
import numpy as np

def arange_square_matrix(n):
    return np.array([np.arange(i, n+i) for i in range(n)])

print(all(map(all,(arange_square_matrix(3) == np.array([[0,1,2],[1,2,3],[2,3,4]])))))
```

## `np.array([np.arange(i, n+i) for i in range(n)])` の説明

### 1. `for i in range(n)`

まず、この部分から見ていきましょう。

* **`for`**: これはPythonの繰り返し処理（ループ）を行うためのキーワードです。
* **`i`**:  これはループの中で使う変数の名前です。
* **`in`**:  `for`ループの構文の一部で、繰り返す対象を指定します。
* **`range(n)`**: これは`0`から`n-1`までの整数を順番に生成する関数です。例えば、`n`が`3`の場合、`range(3)`は`0, 1, 2`という数列を生成します。

つまり、この部分では変数 `i` が `0` から `n-1` まで順番に変化しながら、後続の処理が繰り返されることになります。

**例:** `n = 3` の場合

`i` は `0`、次に `1`、最後に `2` と変化します。

### 2. `np.arange(i, n+i)`

次に、`for`ループの中で実行されるこの部分を見てみましょう。

* **`np.arange()`**: これはNumPyの関数で、等間隔の数列を生成します。
* **`(i, n+i)`**:  `np.arange()`に渡す引数です。
    * **`i`**: 生成する数列の**開始値**です。`for`ループで変化する `i` の値が使われます。
    * **`n+i`**: 生成する数列の**終点（含まれない）**です。つまり、`n+i` の手前の数値までが生成されます。

**例:** `n = 3` の場合

* **`i = 0` のとき**: `np.arange(0, 3+0)` → `np.arange(0, 3)`  →  `[0, 1, 2]`
* **`i = 1` のとき**: `np.arange(1, 3+1)` → `np.arange(1, 4)`  →  `[1, 2, 3]`
* **`i = 2` のとき**: `np.arange(2, 3+2)` → `np.arange(2, 5)`  →  `[2, 3, 4]`

`for`ループが回るたびに、異なる数列が生成されるのがわかりますね。

### 3. `[np.arange(i, n+i) for i in range(n)]`

この部分は、リスト内包表記と呼ばれる記法です。これは、ループ処理の結果をリストとして簡潔に作り出すためのものです。

* **`[...]`**:  リストを作成することを示します。
* **`np.arange(i, n+i)`**:  これがリストの各要素になります。`for`ループが回るたびに生成されるNumPyの配列が、リストの要素として追加されていきます。
* **`for i in range(n)`**:  どの範囲でループ処理を行うかを指定します。

**例:** `n = 3` の場合

このリスト内包表記は、以下の処理をまとめて行っていることになります。

1. `i = 0` のとき `np.arange(0, 3)` で `[0, 1, 2]` が生成され、リストの最初の要素になる。
2. `i = 1` のとき `np.arange(1, 4)` で `[1, 2, 3]` が生成され、リストの次の要素になる。
3. `i = 2` のとき `np.arange(2, 5)` で `[2, 3, 4]` が生成され、リストの最後の要素になる。

結果として、このリスト内包表記は `[[0, 1, 2], [1, 2, 3], [2, 3, 4]]` というリストを生成します。これは、作成したい正方行列の各行を表すリストが要素となったリストです。

### 4. `np.array(...)`

最後に、このリストを `np.array()` で囲んでいます。

* **`np.array()`**: これはNumPyの関数で、リストやタプルなどのシーケンスをNumPy配列に変換します。特に、2次元のリスト（リストの中にリストがある場合）を渡すと、NumPyの多次元配列、つまり行列が作成されます。

**例:** `n = 3` の場合

`np.array([[0, 1, 2], [1, 2, 3], [2, 3, 4]])` を実行すると、以下のNumPy配列（行列）が作成されます。

```
[[0 1 2]
 [1 2 3]
 [2 3 4]]
```

これが、`np.array([np.arange(i, n+i) for i in range(n)])` の全体的な流れと、各部分がどのように機能しているかの説明です。この式は、NumPyの機能を効率的に使って、規則性のある正方行列を簡潔に生成するためのPythonのテクニックと言えます。

## `print(all(map(all,(arange_square_matrix(3) == np.array([[0,1,2],[1,2,3],[2,3,4]])))))` の説明

### 1. `arange_square_matrix(3)`

まず、一番内側から見ていきます。これは、定義した関数 `arange_square_matrix` を `n=3` という値で実行しています。

以前に説明したように、`arange_square_matrix(3)` は、以下のNumPy配列（3x3の行列）を生成します。

```
[[0 1 2]
 [1 2 3]
 [2 3 4]]
```

### 2. `np.array([[0,1,2],[1,2,3],[2,3,4]])`

これは、NumPyを使って直接的に作成した配列です。これは、`arange_square_matrix(3)` が生成する**はず**の正しい結果を表しています。

### 3. `arange_square_matrix(3) == np.array([[0,1,2],[1,2,3],[2,3,4]])`

ここで、先ほど生成された2つのNumPy配列を `==` で比較しています。NumPy配列同士を `==` で比較すると、配列の**各要素ごと**に比較が行われ、結果として同じ形状の真偽値（TrueまたはFalse）を持つ配列が返されます。

今回の例では、`arange_square_matrix(3)` が生成する配列と、期待される配列は完全に一致するので、この比較の結果は以下のようになります。

```
[[ True  True  True]
 [ True  True  True]
 [ True  True  True]]
```

すべての要素が一致しているので、すべて `True` になります。

### 4. `map(all, ...)`

次に、`map(all, ...)` の部分を見ていきましょう。

* **`map()`**: これはPythonの組み込み関数で、指定された関数を、イテラブル（リストや配列など）のすべての要素に適用します。
* **`all`**: これはPythonの組み込み関数で、与えられたイテラブルのすべての要素が `True` の場合に `True` を返し、そうでない場合に `False` を返します。

`map(all, (先ほどの比較結果))` ということは、比較結果の配列の**各行**に対して `all` 関数を適用するということです。

比較結果は以下の通りでした。

```
[[ True  True  True]
 [ True  True  True]
 [ True  True  True]]
```

`map(all, ...)` は、この各行に対して `all` を実行します。

* 1行目: `all([True, True, True])` → `True`
* 2行目: `all([True, True, True])` → `True`
* 3行目: `all([True, True, True])` → `True`

`map()` の結果として、`[True, True, True]` というリストが得られます。これは、「各行のすべての要素が `True` である」という結果を表しています。

### 5. `all(...)`

最後に、一番外側の `all()` 関数です。これは、`map()` の結果である `[True, True, True]` というリストに対して適用されます。

`all([True, True, True])` は、リストのすべての要素が `True` なので、最終的に `True` を返します。

### 6. `print(...)`

そして、この最終的な結果である `True` が `print()` 関数によって画面に出力されます。

**まとめると:**

この `print` 文は、以下の手順で処理を行い、最終的に `True` か `False` を出力します。

1. あなたの関数 `arange_square_matrix(3)` を実行して行列を作成。
2. 期待される正しい行列と比較して、各要素が一致するかどうかを確認。
3. 各行のすべての要素が一致するかどうかをチェック。
4. すべての行が期待通りかどうかをチェック。
5. 最終的な結果（`True` または `False`）を画面に表示。

このコードは、あなたの関数が正しく動作しているかを自動的に確認するための、簡単なテストのようなものです。今回の場合は、関数が期待通りに動作しているので `True` が出力されます。もし関数が間違った行列を生成した場合、比較結果の一部が `False` になり、最終的な出力は `False` になります。

<br>
<br>

---

# 6-1

## コード解説：Pythonのリスト操作、関数、行列演算

それぞれのコードスニペットについて、初心者の方にも分かりやすいように、文法を分解しながら詳しく解説していきます。

### 1. リスト内包表記の基本：文字列の長さ

```python
strings = ['The', 'quick', 'brown']
print([len(x) for x in strings])
```

**コードの概要:**

このコードは、リスト `strings` に含まれる各文字列の長さを計算し、その結果を新しいリストとして出力します。

**文法の分解:**

* **`strings = ['The', 'quick', 'brown']`**:
    * これは、文字列を要素とするリストを変数 `strings` に代入しています。
    * `['The', 'quick', 'brown']` のように、角括弧 `[]` で囲み、要素をカンマ `,` で区切ることでリストを作成します。

* **`[len(x) for x in strings]`**: これは**リスト内包表記**と呼ばれる、リストを簡潔に作成するための記法です。

    * **`for x in strings`**:  これは `for` ループで、リスト `strings` の各要素を順番に取り出し、変数 `x` に代入します。
        * 1回目のループでは `x` は `'The'` になります。
        * 2回目のループでは `x` は `'quick'` になります。
        * 3回目のループでは `x` は `'brown'` になります。

    * **`len(x)`**:  これは組み込み関数 `len()` を使って、文字列 `x` の長さを計算しています。
        * `x` が `'The'` の場合、`len(x)` は `3` になります。
        * `x` が `'quick'` の場合、`len(x)` は `5` になります。
        * `x` が `'brown'` の場合、`len(x)` は `5` になります。

    * **`[ ... ]`**: 角括弧で囲むことで、`for` ループで処理された結果が新しいリストの要素として格納されます。

* **`print(...)`**: 計算されたリストの内容を画面に出力します。

**実行例:**

1. `strings` は `['The', 'quick', 'brown']` というリストです。
2. リスト内包表記が実行されます。
3. 1回目のループ: `x` は `'The'`、`len(x)` は `3`。新しいリストに `3` が追加されます。
4. 2回目のループ: `x` は `'quick'`、`len(x)` は `5`。新しいリストに `5` が追加されます。
5. 3回目のループ: `x` は `'brown'`、`len(x)` は `5`。新しいリストに `5` が追加されます。
6. 最終的に、新しいリスト `[3, 5, 5]` が作成され、`print()` 関数によって出力されます。

**出力結果:**

```
[3, 5, 5]
```

### 2. リスト内包表記と文字列操作、型変換

```python
str1 = '123,45,-3'
print([int(x) for x in str1.split(',')])
```

**コードの概要:**

このコードは、カンマで区切られた文字列 `str1` を数値のリストに変換して出力します。

**文法の分解:**

* **`str1 = '123,45,-3'`**:
    * 文字列 `'123,45,-3'` を変数 `str1` に代入しています。

* **`str1.split(',')`**:
    * これは文字列のメソッド `split()` を使って、文字列 `str1` を指定された区切り文字（ここではカンマ `,`）で分割し、分割された文字列のリストを返します。
    * `'123,45,-3'.split(',')` の結果は `['123', '45', '-3']` というリストになります。

* **`[int(x) for x in str1.split(',')]`**: リスト内包表記です。

    * **`for x in str1.split(',')`**: `str1.split(',')` で生成されたリスト `['123', '45', '-3']` の各要素を順番に取り出し、変数 `x` に代入します。
        * 1回目のループでは `x` は `'123'` になります。
        * 2回目のループでは `x` は `'45'` になります。
        * 3回目のループでは `x` は `'-3'` になります。

    * **`int(x)`**: 組み込み関数 `int()` を使って、文字列 `x` を整数に変換します。
        * `x` が `'123'` の場合、`int(x)` は `123` になります。
        * `x` が `'45'` の場合、`int(x)` は `45` になります。
        * `x` が `'-3'` の場合、`int(x)` は `-3` になります。

    * **`[ ... ]`**: `for` ループで処理された結果（整数）が新しいリストの要素として格納されます。

* **`print(...)`**: 計算されたリストの内容を画面に出力します。

**実行例:**

1. `str1` は `'123,45,-3'` という文字列です。
2. `str1.split(',')` が実行され、`['123', '45', '-3']` というリストが生成されます。
3. リスト内包表記が実行されます。
4. 1回目のループ: `x` は `'123'`、`int(x)` は `123`。新しいリストに `123` が追加されます。
5. 2回目のループ: `x` は `'45'`、`int(x)` は `45`。新しいリストに `45` が追加されます。
6. 3回目のループ: `x` は `'-3'`、`int(x)` は `-3`。新しいリストに `-3` が追加されます。
7. 最終的に、新しいリスト `[123, 45, -3]` が作成され、`print()` 関数によって出力されます。

**出力結果:**

```
[123, 45, -3]
```

### 3. 関数の定義とリスト内包表記を使った分散の計算

```python
def var(lst):
    n = len(lst)
    av = sum(lst) / n
    return sum([(x - av)**2 for x in lst]) / n
print(var([3,4,1,2]) == 1.25)
```

**コードの概要:**

このコードは、リストを受け取り、その分散を計算する関数 `var` を定義し、具体的なリストで計算した結果が期待値と一致するかどうかを出力します。

**文法の分解:**

* **`def var(lst):`**:
    * `def` は関数を定義するためのキーワードです。
    * `var` は関数の名前です。
    * `(lst)` は仮引数で、関数を呼び出す際に渡されるリストを受け取るための変数です。
    * `:` は関数定義の開始を示します。

* **`n = len(lst)`**:
    * 組み込み関数 `len()` を使って、リスト `lst` の要素数を計算し、変数 `n` に代入します。

* **`av = sum(lst) / n`**:
    * 組み込み関数 `sum()` を使って、リスト `lst` の要素の合計を計算します。
    * その合計を要素数 `n` で割ることで、リストの平均値（average）を計算し、変数 `av` に代入します。

* **`return sum([(x - av)**2 for x in lst]) / n`**:
    * `return` は関数の結果を返すためのキーワードです。
    * **`[(x - av)**2 for x in lst]`**: リスト内包表記です。
        * **`for x in lst`**: リスト `lst` の各要素を順番に取り出し、変数 `x` に代入します。
        * **`(x - av)**2`**: 各要素 `x` から平均値 `av` を引き、その結果を2乗します。これは分散の計算における偏差の2乗を表します。
        * **`[ ... ]`**: 計算された偏差の2乗が新しいリストの要素として格納されます。
    * **`sum(...)`**:  リスト内包表記で作成された偏差の2乗のリストの要素を合計します。
    * **`/ n`**:  偏差の2乗の合計を要素数 `n` で割ることで、分散を計算します。

* **`print(var([3,4,1,2]) == 1.25)`**:
    * 関数 `var` を引数 `[3, 4, 1, 2]` で呼び出し、その戻り値（分散）を計算します。
    * 計算された分散が `1.25` と等しいかどうかを `==` で比較し、その結果（True または False）を `print()` 関数で出力します。

**実行例:**

1. 関数 `var` が引数 `[3, 4, 1, 2]` で呼び出されます。
2. `n` は `len([3, 4, 1, 2])` で `4` になります。
3. `av` は `sum([3, 4, 1, 2]) / 4` で `10 / 4 = 2.5` になります。
4. リスト内包表記が実行されます。
    * `x` が `3` のとき: `(3 - 2.5)**2` は `0.25`
    * `x` が `4` のとき: `(4 - 2.5)**2` は `2.25`
    * `x` が `1` のとき: `(1 - 2.5)**2` は `2.25`
    * `x` が `2` のとき: `(2 - 2.5)**2` は `0.25`
   リスト `[0.25, 2.25, 2.25, 0.25]` が生成されます。
5. `sum([0.25, 2.25, 2.25, 0.25])` は `5.0` になります。
6. 最終的な分散は `5.0 / 4` で `1.25` になります。
7. `print(1.25 == 1.25)` が実行され、`True` が出力されます。

**出力結果:**

```
True
```

### 4. ネストしたリスト内包表記：リストのリストの合計

```python
def sum_lists(list1):
    return sum([sum(x) for x in list1])
print(sum_lists([[20, 5], [6, 16, 14, 5], [16, 8, 16, 17, 14], [1], [5, 3, 5, 7]]) == 158)
```

**コードの概要:**

このコードは、リストのリストを受け取り、内側の各リストの合計を計算し、さらにそれらの合計を足し合わせた総和を返す関数 `sum_lists` を定義し、期待値との比較結果を出力します。

**文法の分解:**

* **`def sum_lists(list1):`**:
    * 関数 `sum_lists` を定義し、引数としてリスト `list1` を受け取ります。この `list1` は、リストを要素とするリスト（ネストしたリスト）です。

* **`return sum([sum(x) for x in list1])`**:
    * **`[sum(x) for x in list1]`**: リスト内包表記です。
        * **`for x in list1`**: 外側のリスト `list1` の各要素を順番に取り出し、変数 `x` に代入します。ここで、`x` は内側のリストそのものです。
        * **`sum(x)`**: 組み込み関数 `sum()` を使って、内側のリスト `x` の要素の合計を計算します。
        * **`[ ... ]`**: 内側のリストの合計が新しいリストの要素として格納されます。
    * **`sum(...)`**: 外側の `sum()` 関数は、リスト内包表記で作成された、内側のリストの合計を要素とするリストの要素を合計します。これが全体の総和となります。

* **`print(sum_lists([[20, 5], [6, 16, 14, 5], [16, 8, 16, 17, 14], [1], [5, 3, 5, 7]]) == 158)`**:
    * 関数 `sum_lists` を、ネストしたリスト `[[20, 5], [6, 16, 14, 5], [16, 8, 16, 17, 14], [1], [5, 3, 5, 7]]` を引数として呼び出します。
    * 関数の戻り値（総和）が `158` と等しいかどうかを比較し、結果を出力します。

**実行例:**

1. 関数 `sum_lists` がネストしたリストを引数として呼び出されます。
2. リスト内包表記が実行されます。
    * 1回目のループ: `x` は `[20, 5]`、`sum(x)` は `25`。
    * 2回目のループ: `x` は `[6, 16, 14, 5]`、`sum(x)` は `41`。
    * 3回目のループ: `x` は `[16, 8, 16, 17, 14]`、`sum(x)` は `71`。
    * 4回目のループ: `x` は `[1]`、`sum(x)` は `1`。
    * 5回目のループ: `x` は `[5, 3, 5, 7]`、`sum(x)` は `20`。
   リスト `[25, 41, 71, 1, 20]` が生成されます。
3. `sum([25, 41, 71, 1, 20])` は `158` になります。
4. `print(158 == 158)` が実行され、`True` が出力されます。

**出力結果:**

```
True
```

### 5. ネストしたリスト内包表記：行列の足し算

```python
def sum_matrix(list1, list2):
    return [[list1[i][j] + list2[i][j] for j in range(len(list2))] for i in range(len(list1))]

print(sum_matrix([[1,5,3],[4,5,6],[7,8,9]], [[1,4,7],[2,5,8],[3,6,9]])==[[2, 9, 10], [6, 10, 14], [10, 14, 18]])
```

**コードの概要:**

このコードは、2つの同じサイズの行列（リストのリスト）を受け取り、対応する要素同士を足し合わせて新しい行列を作成する関数 `sum_matrix` を定義し、期待値との比較結果を出力します。

**文法の分解:**

* **`def sum_matrix(list1, list2):`**:
    * 関数 `sum_matrix` を定義し、引数として2つのリスト `list1` と `list2` を受け取ります。これらは行列を表すネストしたリストです。

* **`return [[list1[i][j] + list2[i][j] for j in range(len(list2))] for i in range(len(list1))]`**:
    * これは**ネストしたリスト内包表記**です。外側のリスト内包表記が各行を生成し、内側のリスト内包表記が各行の要素を生成します。
    * **`for i in range(len(list1))`**: 外側のループで、`list1` の行数だけ繰り返します。変数 `i` は行のインデックスを表します。
    * **`[list1[i][j] + list2[i][j] for j in range(len(list2))]`**: 内側のリスト内包表記で、現在の行の各要素を生成します。
        * **`for j in range(len(list2))`**: 内側のループで、`list2` の列数（`list1` と同じと仮定）だけ繰り返します。変数 `j` は列のインデックスを表します。
        * **`list1[i][j] + list2[i][j]`**: `list1` の `i` 行 `j` 列の要素と `list2` の `i` 行 `j` 列の要素を足し合わせます。
        * **`[ ... ]`**: 足し合わされた結果が、新しい行列の現在の行の要素として格納されます。
    * **`[[ ... ]]`**: 外側の角括弧は、内側のリスト内包表記で生成された行を要素とする、新しい行列（リストのリスト）を作成することを示します。

* **`print(sum_matrix([[1,5,3],[4,5,6],[7,8,9]], [[1,4,7],[2,5,8],[3,6,9]])==[[2, 9, 10], [6, 10, 14], [10, 14, 18]])`**:
    * 関数 `sum_matrix` を、2つの具体的な行列を引数として呼び出します。
    * 関数の戻り値（足し合わされた新しい行列）が、期待される行列 `[[2, 9, 10], [6, 10, 14], [10, 14, 18]]` と等しいかどうかを比較し、結果を出力します。

**実行例:**

1. 関数 `sum_matrix` が2つの行列を引数として呼び出されます。
2. 外側のリスト内包表記が実行されます。
    * `i = 0` の場合: 内側のリスト内包表記が実行され、1行目の要素が生成されます。
        * `j = 0`: `list1[0][0] + list2[0][0]` は `1 + 1 = 2`
        * `j = 1`: `list1[0][1] + list2[0][1]` は `5 + 4 = 9`
        * `j = 2`: `list1[0][2] + list2[0][2]` は `3 + 7 = 10`
       1行目は `[2, 9, 10]` となります。
    * `i = 1` の場合: 同様に2行目の要素が生成されます。
       2行目は `[6, 10, 14]` となります。
    * `i = 2` の場合: 同様に3行目の要素が生成されます。
       3行目は `[10, 14, 18]` となります。
3. 新しい行列 `[[2, 9, 10], [6, 10, 14], [10, 14, 18]]` が生成されます。
4. `print([[2, 9, 10], [6, 10, 14], [10, 14, 18]] == [[2, 9, 10], [6, 10, 14], [10, 14, 18]])` が実行され、`True` が出力されます。

**出力結果:**

```
True
```

これらの解説を通して、Pythonのリスト操作、関数、リスト内包表記といった基本的ながらも重要な概念を理解する助けになれば幸いです。


<br>
<br>

---

# 6-2

## コード解説

### Practice 1

```python
print(f'=========================== Practice 1')
def max_value_key(d):
    return max(d, key=lambda x: d[x])

print(max_value_key({3:10, 5:2, 9:1}) == 3)
```

この関数 `max_value_key(d)` は、**ディクショナリ（辞書） `d` の中で、値が最も大きいキー** を見つけ出すものです。

*   **`def max_value_key(d):`**:  `max_value_key` という名前の関数を定義します。この関数は `d` という引数を受け取ります。`d` はディクショナリを想定しています。
*   **`return max(d, key=lambda x: d[x])`**:  この部分が関数の中心となる処理です。
    *   **`max(d, ...)`**:  Pythonの組み込み関数 `max()` は、与えられたものの中から最大の要素を見つけ出す関数です。通常、リストやタプルなどの要素を比較して最大値を見つけますが、ここでは少し変わった使い方をしています。
    *   **`key=lambda x: d[x]`**:  `max()` 関数の `key` 引数に、`lambda x: d[x]` という記述があります。これは **無名関数（ラムダ式）** と呼ばれるもので、簡単に言うと「名前のない小さな関数」です。
        *   **`lambda x:`**:  「`x` という引数を受け取る関数」という意味です。`x` には、ディクショナリ `d` の各 **キー** が順番に入ってきます。
        *   **`d[x]`**:  ディクショナリ `d` に対して、キー `x` に対応する **値** を取り出す操作です。
    *   **まとめると**: `max(d, key=lambda x: d[x])` は、「ディクショナリ `d` の各キーに対して、そのキーに対応する値を比較し、最も大きい値を持つキーを返す」という意味になります。
*   **`print(max_value_key({3:10, 5:2, 9:1}) == 3)`**:  この部分は関数の動作を確認するためのものです。
    *   **`max_value_key({3:10, 5:2, 9:1})`**:  `max_value_key` 関数に、`{3:10, 5:2, 9:1}` というディクショナリを渡して実行します。このディクショナリでは、キー `3` の値は `10`、キー `5` の値は `2`、キー `9` の値は `1` です。したがって、最も大きい値を持つキーは `3` になります。
    *   **`== 3`**:  関数の実行結果が `3` と等しいかどうかを比較しています。結果が `True` であれば、関数は正しく動作していることになります。

### Practice 2

```python
print(f'=========================== Practice 2')
def max_abs(ln):
    return max(map(abs, ln))

print(max_abs([3,-8,1,0,7,-5]) == 8)
```

この関数 `max_abs(ln)` は、**数値のリスト `ln` の中で、絶対値が最も大きい数値** を見つけ出すものです。

*   **`def max_abs(ln):`**: `max_abs` という名前の関数を定義します。この関数は `ln` という引数を受け取ります。`ln` は数値のリストを想定しています。
*   **`return max(map(abs, ln))`**:  この部分が関数の中心となる処理です。
    *   **`map(abs, ln)`**:  `map()` 関数は、リストなどの要素すべてに対して、指定した関数を順番に適用するものです。
        *   **`abs`**:  Pythonの組み込み関数 `abs()` は、数値の絶対値を返す関数です。例えば、`abs(-8)` は `8` になります。
        *   **`ln`**:  入力となる数値のリストです。
        *   **まとめると**: `map(abs, ln)` は、リスト `ln` の各数値に対して `abs()` 関数を適用し、その結果（絶対値）を順番に生成する **イテレータ** というものを作ります。（イテレータは、必要になるたびに要素を生成する便利な仕組みです。）
    *   **`max(...)`**:  `max()` 関数は、`map()` が生成したイテレータから、最大の要素（ここでは絶対値が最大の値）を見つけ出して返します。
*   **`print(max_abs([3,-8,1,0,7,-5]) == 8)`**:  この部分は関数の動作を確認するためのものです。
    *   **`max_abs([3,-8,1,0,7,-5])`**:  `max_abs` 関数に、`[3,-8,1,0,7,-5]` という数値のリストを渡して実行します。リスト内の各数値の絶対値は、それぞれ `3`, `8`, `1`, `0`, `7`, `5` となります。この中で最も大きい値は `8` です。
    *   **`== 8`**:  関数の実行結果が `8` と等しいかどうかを比較しています。結果が `True` であれば、関数は正しく動作していることになります。

### Practice 3

```python
print(f'=========================== Practice 3')
def number_of_big_numbers(ln, n):
    return len(list(filter(lambda x: x > n, ln)))

print(number_of_big_numbers([10, 0, 7, 1, 5, 2, 9], 5) == 3)
```

この関数 `number_of_big_numbers(ln, n)` は、**数値のリスト `ln` の中で、数値 `n` よりも大きい数値がいくつあるか** を数えるものです。

*   **`def number_of_big_numbers(ln, n):`**:  `number_of_big_numbers` という名前の関数を定義します。この関数は `ln` （数値のリスト）と `n` （比較する数値）の2つの引数を受け取ります。
*   **`return len(list(filter(lambda x: x > n, ln)))`**:  この部分が関数の中心となる処理です。
    *   **`filter(lambda x: x > n, ln)`**:  `filter()` 関数は、リストなどの要素の中から、特定の条件を満たすものだけを抽出するものです。
        *   **`lambda x: x > n`**:  ラムダ式で、「`x` という引数を受け取り、`x` が `n` よりも大きければ `True` を、そうでなければ `False` を返す」という条件を表しています。`x` には、リスト `ln` の各数値が順番に入ってきます。
        *   **`ln`**:  入力となる数値のリストです。
        *   **まとめると**: `filter(lambda x: x > n, ln)` は、リスト `ln` の数値の中から、`n` よりも大きい数値だけを取り出した **イテレータ** を作ります。
    *   **`list(...)`**:  `filter()` が作ったイテレータを `list()` 関数に渡すことで、イテレータの中身をすべて含んだ **リスト** を新しく作成します。
    *   **`len(...)`**:  `len()` 関数は、リストや文字列などの **要素の数（長さ）** を数える関数です。ここでは、`filter` で抽出された「`n` より大きい数値」のリストの長さを数えています。
*   **`print(number_of_big_numbers([10, 0, 7, 1, 5, 2, 9], 5) == 3)`**:  この部分は関数の動作を確認するためのものです。
    *   **`number_of_big_numbers([10, 0, 7, 1, 5, 2, 9], 5)`**:  `number_of_big_numbers` 関数に、数値のリスト `[10, 0, 7, 1, 5, 2, 9]` と数値 `5` を渡して実行します。リストの中で `5` より大きい数値は `10`, `7`, `9` の3つです。
    *   **`== 3`**:  関数の実行結果が `3` と等しいかどうかを比較しています。結果が `True` であれば、関数は正しく動作していることになります。

### Practice 4

```python
print(f'=========================== Practice 4')
def number_of_long_lines(file, n):
    with open(file, 'r', encoding='utf-8') as f:
        return len(list(filter(lambda x: len(x) > n, f)))

print(number_of_long_lines('jugemu.txt', 10) == 6)
```

この関数 `number_of_long_lines(file, n)` は、**指定されたファイル `file` の中で、長さ（文字数）が `n` よりも長い行がいくつあるか** を数えるものです。

*   **`def number_of_long_lines(file, n):`**:  `number_of_long_lines` という名前の関数を定義します。この関数は `file` （ファイルの名前）と `n` （比較する長さ）の2つの引数を受け取ります。
*   **`with open(file, 'r', encoding='utf-8') as f:`**:  この部分は、ファイルを安全に開いて処理するための構文です。
    *   **`open(file, 'r', encoding='utf-8')`**:  指定された名前のファイルを **読み込みモード (`'r'`)** で開きます。
        *   **`file`**:  関数の引数として渡されたファイルの名前です。
        *   **`encoding='utf-8'`**:  ファイルの中身が **UTF-8** という文字コードで書かれていることを指定します。これにより、日本語などの文字も正しく読み込めます。
    *   **`as f`**:  開いたファイルは `f` という名前でプログラムの中で扱えるようになります。
    *   **`with ...:`**:  `with` を使うと、ファイルを使った処理が終わった後、自動的にファイルが閉じられるため、安全にファイルを扱うことができます。
*   **`return len(list(filter(lambda x: len(x) > n, f)))`**:  この部分は、Practice 3 の `number_of_big_numbers` 関数と非常によく似た構造をしています。
    *   **`filter(lambda x: len(x) > n, f)`**:
        *   **`f`**:  開かれたファイルオブジェクトです。ファイルオブジェクトは、テキストファイルを1行ずつ順番に読み込むことができる **イテレータ** のような働きをします。
        *   **`lambda x: len(x) > n`**:  ラムダ式で、「`x` という引数（ここではファイルの1行）を受け取り、その行の長さ `len(x)` が `n` よりも大きければ `True` を、そうでなければ `False` を返す」という条件を表しています。
        *   **まとめると**: `filter(lambda x: len(x) > n, f)` は、ファイル `f` の各行の中から、長さが `n` よりも長い行だけを取り出した **イテレータ** を作ります。
    *   **`list(...)`**:  `filter()` が作ったイテレータを `list()` 関数に渡すことで、イテレータの中身（長さが `n` より長い行）をすべて含んだ **リスト** を新しく作成します。
    *   **`len(...)`**:  `len()` 関数で、`filter` で抽出された「長さが `n` より長い行」のリストの長さを数えています。
*   **`print(number_of_long_lines('jugemu.txt', 10) == 6)`**:  この部分は関数の動作を確認するためのものです。
    *   **`number_of_long_lines('jugemu.txt', 10)`**:  `number_of_long_lines` 関数に、ファイル名 `'jugemu.txt'` と長さ `10` を渡して実行します。この例では、`jugemu.txt` というファイルの中で、長さが `10` より長い行がいくつあるかを数えます。
    *   **`== 6`**:  関数の実行結果が `6` と等しいかどうかを比較しています。結果が `True` であれば、関数は正しく動作していることになります。


<br>
<br>

---

# 6-3


```python
class HelloFileIterator(HelloFile):
    def __iter__(self):
        return self
    def __next__(self):
        line = self.readline()
        if line == '':
            raise StopIteration
        return line

print(f'================================== Practice1')

class StringFileIterator(HelloFileIterator):
    def __init__(self, s, n):
        self.s = s
        self.n = n

    def readline(self):
        if self.n == 0:
            return ''
        self.n = self.n - 1
        return self.s

f = StringFileIterator('abc', 3)
print(list(f) == ['abc','abc','abc'])
```

## **`StringFileIterator` クラスの概要:**

`StringFileIterator` クラスは、`HelloFileIterator` クラスを **継承** しています。これは、`StringFileIterator` が `HelloFileIterator` の機能を受け継ぎ、さらに独自の機能を追加できるということです。

### **`__init__` メソッド:**

```python
    def __init__(self, s, n):
        self.s = s
        self.n = n
```

- `__init__` は、クラスの **コンストラクタ** と呼ばれ、オブジェクトが作成されるときに最初に実行される特別なメソッドです。
- `StringFileIterator('abc', 3)` のようにオブジェクトを作成する際に、`'abc'` が `s` に、`3` が `n` に渡されます。
- `self.s = s` は、渡された文字列 `'abc'` をオブジェクトの属性 `s` に保存します。
- `self.n = n` は、渡された数値 `3` をオブジェクトの属性 `n` に保存します。この `n` は、文字列を何回繰り返すかを制御するために使われます。

### **`readline` メソッド (オーバーライド):**

```python
    def readline(self):
        if self.n == 0:
            return ''
        self.n = self.n - 1
        return self.s
```

- `readline` メソッドは、親クラスである `HelloFileIterator` (さらにその親クラスである `HelloFile`) にも定義されていますが、`StringFileIterator` では **オーバーライド (上書き)** されています。
- `if self.n == 0:` は、オブジェクトの属性 `n` が `0` かどうかをチェックします。もし `0` であれば、空文字列 `''` を返します。これは、もう文字列を返す必要がないことを意味します。
- `self.n = self.n - 1` は、`n` の値を `1` 減らします。
- `return self.s` は、オブジェクトの属性 `s` に保存されている文字列（この場合は `'abc'`）を返します。

### **`f = StringFileIterator('abc', 3)` の実行:**

この行で、`StringFileIterator` クラスの新しいオブジェクト `f` が作成されます。`__init__` メソッドが実行され、`f.s` は `'abc'`、`f.n` は `3` に設定されます。

### **`print(list(f) == ['abc','abc','abc'])` の評価:**

#### 1. **`list(f)` の処理:**
   - `list()` 関数は、引数として与えられたイテレータ（この場合は `f`）からすべての要素を取り出し、新しいリストを作成します。
   - `f` は `StringFileIterator` のインスタンスであり、`HelloFileIterator` から `__iter__` と `__next__` メソッドを継承しています。
   - `list(f)` は、内部的に `f` の `__next__` メソッドを繰り返し呼び出し、要素を取得していきます。

#### 2. **`f.__next__()` メソッドの呼び出しと `readline` メソッドの動作 (繰り返し):**
   - **1回目:** `f.__next__()` が呼ばれると、`readline()` が実行されます。`f.n` は `3` なので、`'abc'` が返され、`f.n` は `2` になります。
   - **2回目:** `f.__next__()` が呼ばれると、`readline()` が実行されます。`f.n` は `2` なので、`'abc'` が返され、`f.n` は `1` になります。
   - **3回目:** `f.__next__()` が呼ばれると、`readline()` が実行されます。`f.n` は `1` なので、`'abc'` が返され、`f.n` は `0` になります。
   - **4回目:** `f.__next__()` が呼ばれると、`readline()` が実行されます。`f.n` は `0` なので、空文字列 `''` が返されます。
   - `__next__()` メソッド内で `line == ''` の条件が満たされ、`raise StopIteration` が実行されます。`list()` はこの例外を受け取り、要素の取り出しを終了します。

#### 3. **`list(f)` の結果:**
   - `list(f)` は、`__next__()` から返された `'abc'`、`'abc'`、`'abc'` を要素とするリスト `['abc', 'abc', 'abc']` を作成します。

#### 4. **`== ['abc','abc','abc']` の比較:**
   - `list(f)` の結果である `['abc', 'abc', 'abc']` と、`['abc', 'abc', 'abc']` というリストリテラルを比較します。
   - 2つのリストは内容が完全に一致するため、この比較は `True` を返します。

#### 5. **`print()` 関数の出力:**
   - `print(True)` が実行され、コンソールに `True` と表示されます。

## **まとめ:**

`StringFileIterator` は、指定された文字列を指定された回数だけ繰り返すイテレータを作成するクラスです。`list(f)` は、このイテレータからすべての文字列を取り出してリストに変換し、そのリストが期待されるリストと一致するかどうかを評価しています。

<br>
<br>

---

# 9-recursive

## power (べき乗の計算)

```python
def power(base, expt):
    if expt == 0:
        return 1
    else:
        return base * power(base, expt - 1)

power(2, 10)
```

```python
def power(base, expt):
    if expt == 0:
        return 1
    elif expt % 2 == 0:
        return power(base, expt // 2) ** 2 # x**(2m) == (x*x)**m
    else:
        return base * power(base, expt - 1)

power(2, 10)
```

2つ目のコードの方が一般的に高速です。その理由と仕組みについて説明します。

**2つ目のコードが速い理由**

2つ目のコードは、指数 (`expt`) が偶数の場合に、計算回数を大幅に減らす最適化を行っているためです。

最初のコードは、指数が1減るごとに再帰呼び出しを行い、最終的に指数が0になるまで `base` を掛け続けます。例えば `power(2, 10)` の場合、10回の掛け算が行われます。

一方、2つ目のコードでは、指数が偶数の場合、`power(base, expt // 2) ** 2` という計算を行います。これは、例えば `power(2, 10)` なら `power(2, 5) ** 2` となり、指数を半分にしてから結果を2乗します。これにより、再帰呼び出しの回数が大幅に減り、計算量が削減されます。

**2つ目のコードの仕組み**

2つ目のコードは、指数が偶数か奇数かで処理を分けています。

* **指数が0の場合:**  これは最初のコードと同じで、どんな数の0乗も1なので `1` を返します。

* **指数が偶数の場合 (`elif expt % 2 == 0`):**
    * `power(base, expt // 2)` を呼び出します。これは、元の問題の指数を半分にした部分問題を解くことに相当します。
    * その結果を2乗 (`** 2`) します。これは、数学的な性質 `x**(2m) == (x*x)**m`  を利用しています。例えば、`2**10` は `(2**5)**2` と同じです。

* **指数が奇数の場合 (`else`):**
    * `base * power(base, expt - 1)` を呼び出します。これは、奇数の指数を「base * (baseの偶数乗)」という形に分解して計算する方法です。例えば、`2**11` は `2 * 2**10` と同じです。

**具体例: `power(2, 10)` の計算過程**

**最初のコード:**

1. `power(2, 10)` -> `2 * power(2, 9)`
2. `power(2, 9)`  -> `2 * power(2, 8)`
3. ...
4. `power(2, 1)`  -> `2 * power(2, 0)`
5. `power(2, 0)`  -> `1`
6. 最終的に `2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 1 = 1024`

**2つ目のコード:**

1. `power(2, 10)` (10は偶数) -> `power(2, 5) ** 2`
2. `power(2, 5)`  (5は奇数) -> `2 * power(2, 4)`
3. `power(2, 4)`  (4は偶数) -> `power(2, 2) ** 2`
4. `power(2, 2)`  (2は偶数) -> `power(2, 1) ** 2`
5. `power(2, 1)`  (1は奇数) -> `2 * power(2, 0)`
6. `power(2, 0)`  -> `1`
7. 計算を遡る:
   - `power(2, 1)` は `2 * 1 = 2`
   - `power(2, 2)` は `2 ** 2 = 4`
   - `power(2, 4)` は `4 ** 2 = 16`
   - `power(2, 5)` は `2 * 16 = 32`
   - `power(2, 10)` は `32 ** 2 = 1024`

このように、2つ目のコードでは再帰呼び出しの回数が大幅に減っていることがわかります。

**計算量の比較**

* **最初のコード:** 指数 `n` に対して、ほぼ `n` 回の掛け算が行われるため、計算量は O(n) となります。
* **2つ目のコード:** 指数が半分になるごとに再帰呼び出しが行われるため、計算量は O(log n) となります。

指数が大きくなるほど、この計算量の違いは顕著になり、2つ目のコードの効率が際立ちます。

**補足**

2つ目のコードで使われている手法は、「再帰的平方」や「バイナリ法」と呼ばれることもあります。これは、指数の二進数表現を利用して効率的にべき乗を計算する考え方に基づいています。
