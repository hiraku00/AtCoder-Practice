# 東京大学「Pythonプログラミング入門」
https://utokyo-ipp.github.io/

---

# 5-3

```python
import numpy as np

def arange_square_matrix(n):
    return np.array([np.arange(i, n+i) for i in range(n)])

print(all(map(all,(arange_square_matrix(3) == np.array([[0,1,2],[1,2,3],[2,3,4]])))))
```

## `np.array([np.arange(i, n+i) for i in range(n)])` の説明

### 1. `for i in range(n)`

まず、この部分から見ていきましょう。

* **`for`**: これはPythonの繰り返し処理（ループ）を行うためのキーワードです。
* **`i`**:  これはループの中で使う変数の名前です。
* **`in`**:  `for`ループの構文の一部で、繰り返す対象を指定します。
* **`range(n)`**: これは`0`から`n-1`までの整数を順番に生成する関数です。例えば、`n`が`3`の場合、`range(3)`は`0, 1, 2`という数列を生成します。

つまり、この部分では変数 `i` が `0` から `n-1` まで順番に変化しながら、後続の処理が繰り返されることになります。

**例:** `n = 3` の場合

`i` は `0`、次に `1`、最後に `2` と変化します。

### 2. `np.arange(i, n+i)`

次に、`for`ループの中で実行されるこの部分を見てみましょう。

* **`np.arange()`**: これはNumPyの関数で、等間隔の数列を生成します。
* **`(i, n+i)`**:  `np.arange()`に渡す引数です。
    * **`i`**: 生成する数列の**開始値**です。`for`ループで変化する `i` の値が使われます。
    * **`n+i`**: 生成する数列の**終点（含まれない）**です。つまり、`n+i` の手前の数値までが生成されます。

**例:** `n = 3` の場合

* **`i = 0` のとき**: `np.arange(0, 3+0)` → `np.arange(0, 3)`  →  `[0, 1, 2]`
* **`i = 1` のとき**: `np.arange(1, 3+1)` → `np.arange(1, 4)`  →  `[1, 2, 3]`
* **`i = 2` のとき**: `np.arange(2, 3+2)` → `np.arange(2, 5)`  →  `[2, 3, 4]`

`for`ループが回るたびに、異なる数列が生成されるのがわかりますね。

### 3. `[np.arange(i, n+i) for i in range(n)]`

この部分は、リスト内包表記と呼ばれる記法です。これは、ループ処理の結果をリストとして簡潔に作り出すためのものです。

* **`[...]`**:  リストを作成することを示します。
* **`np.arange(i, n+i)`**:  これがリストの各要素になります。`for`ループが回るたびに生成されるNumPyの配列が、リストの要素として追加されていきます。
* **`for i in range(n)`**:  どの範囲でループ処理を行うかを指定します。

**例:** `n = 3` の場合

このリスト内包表記は、以下の処理をまとめて行っていることになります。

1. `i = 0` のとき `np.arange(0, 3)` で `[0, 1, 2]` が生成され、リストの最初の要素になる。
2. `i = 1` のとき `np.arange(1, 4)` で `[1, 2, 3]` が生成され、リストの次の要素になる。
3. `i = 2` のとき `np.arange(2, 5)` で `[2, 3, 4]` が生成され、リストの最後の要素になる。

結果として、このリスト内包表記は `[[0, 1, 2], [1, 2, 3], [2, 3, 4]]` というリストを生成します。これは、作成したい正方行列の各行を表すリストが要素となったリストです。

### 4. `np.array(...)`

最後に、このリストを `np.array()` で囲んでいます。

* **`np.array()`**: これはNumPyの関数で、リストやタプルなどのシーケンスをNumPy配列に変換します。特に、2次元のリスト（リストの中にリストがある場合）を渡すと、NumPyの多次元配列、つまり行列が作成されます。

**例:** `n = 3` の場合

`np.array([[0, 1, 2], [1, 2, 3], [2, 3, 4]])` を実行すると、以下のNumPy配列（行列）が作成されます。

```
[[0 1 2]
 [1 2 3]
 [2 3 4]]
```

これが、`np.array([np.arange(i, n+i) for i in range(n)])` の全体的な流れと、各部分がどのように機能しているかの説明です。この式は、NumPyの機能を効率的に使って、規則性のある正方行列を簡潔に生成するためのPythonのテクニックと言えます。

## `print(all(map(all,(arange_square_matrix(3) == np.array([[0,1,2],[1,2,3],[2,3,4]])))))` の説明

### 1. `arange_square_matrix(3)`

まず、一番内側から見ていきます。これは、定義した関数 `arange_square_matrix` を `n=3` という値で実行しています。

以前に説明したように、`arange_square_matrix(3)` は、以下のNumPy配列（3x3の行列）を生成します。

```
[[0 1 2]
 [1 2 3]
 [2 3 4]]
```

### 2. `np.array([[0,1,2],[1,2,3],[2,3,4]])`

これは、NumPyを使って直接的に作成した配列です。これは、`arange_square_matrix(3)` が生成する**はず**の正しい結果を表しています。

### 3. `arange_square_matrix(3) == np.array([[0,1,2],[1,2,3],[2,3,4]])`

ここで、先ほど生成された2つのNumPy配列を `==` で比較しています。NumPy配列同士を `==` で比較すると、配列の**各要素ごと**に比較が行われ、結果として同じ形状の真偽値（TrueまたはFalse）を持つ配列が返されます。

今回の例では、`arange_square_matrix(3)` が生成する配列と、期待される配列は完全に一致するので、この比較の結果は以下のようになります。

```
[[ True  True  True]
 [ True  True  True]
 [ True  True  True]]
```

すべての要素が一致しているので、すべて `True` になります。

### 4. `map(all, ...)`

次に、`map(all, ...)` の部分を見ていきましょう。

* **`map()`**: これはPythonの組み込み関数で、指定された関数を、イテラブル（リストや配列など）のすべての要素に適用します。
* **`all`**: これはPythonの組み込み関数で、与えられたイテラブルのすべての要素が `True` の場合に `True` を返し、そうでない場合に `False` を返します。

`map(all, (先ほどの比較結果))` ということは、比較結果の配列の**各行**に対して `all` 関数を適用するということです。

比較結果は以下の通りでした。

```
[[ True  True  True]
 [ True  True  True]
 [ True  True  True]]
```

`map(all, ...)` は、この各行に対して `all` を実行します。

* 1行目: `all([True, True, True])` → `True`
* 2行目: `all([True, True, True])` → `True`
* 3行目: `all([True, True, True])` → `True`

`map()` の結果として、`[True, True, True]` というリストが得られます。これは、「各行のすべての要素が `True` である」という結果を表しています。

### 5. `all(...)`

最後に、一番外側の `all()` 関数です。これは、`map()` の結果である `[True, True, True]` というリストに対して適用されます。

`all([True, True, True])` は、リストのすべての要素が `True` なので、最終的に `True` を返します。

### 6. `print(...)`

そして、この最終的な結果である `True` が `print()` 関数によって画面に出力されます。

**まとめると:**

この `print` 文は、以下の手順で処理を行い、最終的に `True` か `False` を出力します。

1. あなたの関数 `arange_square_matrix(3)` を実行して行列を作成。
2. 期待される正しい行列と比較して、各要素が一致するかどうかを確認。
3. 各行のすべての要素が一致するかどうかをチェック。
4. すべての行が期待通りかどうかをチェック。
5. 最終的な結果（`True` または `False`）を画面に表示。

このコードは、あなたの関数が正しく動作しているかを自動的に確認するための、簡単なテストのようなものです。今回の場合は、関数が期待通りに動作しているので `True` が出力されます。もし関数が間違った行列を生成した場合、比較結果の一部が `False` になり、最終的な出力は `False` になります。

<br>
<br>

---

# 6-1

## コード解説：Pythonのリスト操作、関数、行列演算

それぞれのコードスニペットについて、初心者の方にも分かりやすいように、文法を分解しながら詳しく解説していきます。

### 1. リスト内包表記の基本：文字列の長さ

```python
strings = ['The', 'quick', 'brown']
print([len(x) for x in strings])
```

**コードの概要:**

このコードは、リスト `strings` に含まれる各文字列の長さを計算し、その結果を新しいリストとして出力します。

**文法の分解:**

* **`strings = ['The', 'quick', 'brown']`**:
    * これは、文字列を要素とするリストを変数 `strings` に代入しています。
    * `['The', 'quick', 'brown']` のように、角括弧 `[]` で囲み、要素をカンマ `,` で区切ることでリストを作成します。

* **`[len(x) for x in strings]`**: これは**リスト内包表記**と呼ばれる、リストを簡潔に作成するための記法です。

    * **`for x in strings`**:  これは `for` ループで、リスト `strings` の各要素を順番に取り出し、変数 `x` に代入します。
        * 1回目のループでは `x` は `'The'` になります。
        * 2回目のループでは `x` は `'quick'` になります。
        * 3回目のループでは `x` は `'brown'` になります。

    * **`len(x)`**:  これは組み込み関数 `len()` を使って、文字列 `x` の長さを計算しています。
        * `x` が `'The'` の場合、`len(x)` は `3` になります。
        * `x` が `'quick'` の場合、`len(x)` は `5` になります。
        * `x` が `'brown'` の場合、`len(x)` は `5` になります。

    * **`[ ... ]`**: 角括弧で囲むことで、`for` ループで処理された結果が新しいリストの要素として格納されます。

* **`print(...)`**: 計算されたリストの内容を画面に出力します。

**実行例:**

1. `strings` は `['The', 'quick', 'brown']` というリストです。
2. リスト内包表記が実行されます。
3. 1回目のループ: `x` は `'The'`、`len(x)` は `3`。新しいリストに `3` が追加されます。
4. 2回目のループ: `x` は `'quick'`、`len(x)` は `5`。新しいリストに `5` が追加されます。
5. 3回目のループ: `x` は `'brown'`、`len(x)` は `5`。新しいリストに `5` が追加されます。
6. 最終的に、新しいリスト `[3, 5, 5]` が作成され、`print()` 関数によって出力されます。

**出力結果:**

```
[3, 5, 5]
```

### 2. リスト内包表記と文字列操作、型変換

```python
str1 = '123,45,-3'
print([int(x) for x in str1.split(',')])
```

**コードの概要:**

このコードは、カンマで区切られた文字列 `str1` を数値のリストに変換して出力します。

**文法の分解:**

* **`str1 = '123,45,-3'`**:
    * 文字列 `'123,45,-3'` を変数 `str1` に代入しています。

* **`str1.split(',')`**:
    * これは文字列のメソッド `split()` を使って、文字列 `str1` を指定された区切り文字（ここではカンマ `,`）で分割し、分割された文字列のリストを返します。
    * `'123,45,-3'.split(',')` の結果は `['123', '45', '-3']` というリストになります。

* **`[int(x) for x in str1.split(',')]`**: リスト内包表記です。

    * **`for x in str1.split(',')`**: `str1.split(',')` で生成されたリスト `['123', '45', '-3']` の各要素を順番に取り出し、変数 `x` に代入します。
        * 1回目のループでは `x` は `'123'` になります。
        * 2回目のループでは `x` は `'45'` になります。
        * 3回目のループでは `x` は `'-3'` になります。

    * **`int(x)`**: 組み込み関数 `int()` を使って、文字列 `x` を整数に変換します。
        * `x` が `'123'` の場合、`int(x)` は `123` になります。
        * `x` が `'45'` の場合、`int(x)` は `45` になります。
        * `x` が `'-3'` の場合、`int(x)` は `-3` になります。

    * **`[ ... ]`**: `for` ループで処理された結果（整数）が新しいリストの要素として格納されます。

* **`print(...)`**: 計算されたリストの内容を画面に出力します。

**実行例:**

1. `str1` は `'123,45,-3'` という文字列です。
2. `str1.split(',')` が実行され、`['123', '45', '-3']` というリストが生成されます。
3. リスト内包表記が実行されます。
4. 1回目のループ: `x` は `'123'`、`int(x)` は `123`。新しいリストに `123` が追加されます。
5. 2回目のループ: `x` は `'45'`、`int(x)` は `45`。新しいリストに `45` が追加されます。
6. 3回目のループ: `x` は `'-3'`、`int(x)` は `-3`。新しいリストに `-3` が追加されます。
7. 最終的に、新しいリスト `[123, 45, -3]` が作成され、`print()` 関数によって出力されます。

**出力結果:**

```
[123, 45, -3]
```

### 3. 関数の定義とリスト内包表記を使った分散の計算

```python
def var(lst):
    n = len(lst)
    av = sum(lst) / n
    return sum([(x - av)**2 for x in lst]) / n
print(var([3,4,1,2]) == 1.25)
```

**コードの概要:**

このコードは、リストを受け取り、その分散を計算する関数 `var` を定義し、具体的なリストで計算した結果が期待値と一致するかどうかを出力します。

**文法の分解:**

* **`def var(lst):`**:
    * `def` は関数を定義するためのキーワードです。
    * `var` は関数の名前です。
    * `(lst)` は仮引数で、関数を呼び出す際に渡されるリストを受け取るための変数です。
    * `:` は関数定義の開始を示します。

* **`n = len(lst)`**:
    * 組み込み関数 `len()` を使って、リスト `lst` の要素数を計算し、変数 `n` に代入します。

* **`av = sum(lst) / n`**:
    * 組み込み関数 `sum()` を使って、リスト `lst` の要素の合計を計算します。
    * その合計を要素数 `n` で割ることで、リストの平均値（average）を計算し、変数 `av` に代入します。

* **`return sum([(x - av)**2 for x in lst]) / n`**:
    * `return` は関数の結果を返すためのキーワードです。
    * **`[(x - av)**2 for x in lst]`**: リスト内包表記です。
        * **`for x in lst`**: リスト `lst` の各要素を順番に取り出し、変数 `x` に代入します。
        * **`(x - av)**2`**: 各要素 `x` から平均値 `av` を引き、その結果を2乗します。これは分散の計算における偏差の2乗を表します。
        * **`[ ... ]`**: 計算された偏差の2乗が新しいリストの要素として格納されます。
    * **`sum(...)`**:  リスト内包表記で作成された偏差の2乗のリストの要素を合計します。
    * **`/ n`**:  偏差の2乗の合計を要素数 `n` で割ることで、分散を計算します。

* **`print(var([3,4,1,2]) == 1.25)`**:
    * 関数 `var` を引数 `[3, 4, 1, 2]` で呼び出し、その戻り値（分散）を計算します。
    * 計算された分散が `1.25` と等しいかどうかを `==` で比較し、その結果（True または False）を `print()` 関数で出力します。

**実行例:**

1. 関数 `var` が引数 `[3, 4, 1, 2]` で呼び出されます。
2. `n` は `len([3, 4, 1, 2])` で `4` になります。
3. `av` は `sum([3, 4, 1, 2]) / 4` で `10 / 4 = 2.5` になります。
4. リスト内包表記が実行されます。
    * `x` が `3` のとき: `(3 - 2.5)**2` は `0.25`
    * `x` が `4` のとき: `(4 - 2.5)**2` は `2.25`
    * `x` が `1` のとき: `(1 - 2.5)**2` は `2.25`
    * `x` が `2` のとき: `(2 - 2.5)**2` は `0.25`
   リスト `[0.25, 2.25, 2.25, 0.25]` が生成されます。
5. `sum([0.25, 2.25, 2.25, 0.25])` は `5.0` になります。
6. 最終的な分散は `5.0 / 4` で `1.25` になります。
7. `print(1.25 == 1.25)` が実行され、`True` が出力されます。

**出力結果:**

```
True
```

### 4. ネストしたリスト内包表記：リストのリストの合計

```python
def sum_lists(list1):
    return sum([sum(x) for x in list1])
print(sum_lists([[20, 5], [6, 16, 14, 5], [16, 8, 16, 17, 14], [1], [5, 3, 5, 7]]) == 158)
```

**コードの概要:**

このコードは、リストのリストを受け取り、内側の各リストの合計を計算し、さらにそれらの合計を足し合わせた総和を返す関数 `sum_lists` を定義し、期待値との比較結果を出力します。

**文法の分解:**

* **`def sum_lists(list1):`**:
    * 関数 `sum_lists` を定義し、引数としてリスト `list1` を受け取ります。この `list1` は、リストを要素とするリスト（ネストしたリスト）です。

* **`return sum([sum(x) for x in list1])`**:
    * **`[sum(x) for x in list1]`**: リスト内包表記です。
        * **`for x in list1`**: 外側のリスト `list1` の各要素を順番に取り出し、変数 `x` に代入します。ここで、`x` は内側のリストそのものです。
        * **`sum(x)`**: 組み込み関数 `sum()` を使って、内側のリスト `x` の要素の合計を計算します。
        * **`[ ... ]`**: 内側のリストの合計が新しいリストの要素として格納されます。
    * **`sum(...)`**: 外側の `sum()` 関数は、リスト内包表記で作成された、内側のリストの合計を要素とするリストの要素を合計します。これが全体の総和となります。

* **`print(sum_lists([[20, 5], [6, 16, 14, 5], [16, 8, 16, 17, 14], [1], [5, 3, 5, 7]]) == 158)`**:
    * 関数 `sum_lists` を、ネストしたリスト `[[20, 5], [6, 16, 14, 5], [16, 8, 16, 17, 14], [1], [5, 3, 5, 7]]` を引数として呼び出します。
    * 関数の戻り値（総和）が `158` と等しいかどうかを比較し、結果を出力します。

**実行例:**

1. 関数 `sum_lists` がネストしたリストを引数として呼び出されます。
2. リスト内包表記が実行されます。
    * 1回目のループ: `x` は `[20, 5]`、`sum(x)` は `25`。
    * 2回目のループ: `x` は `[6, 16, 14, 5]`、`sum(x)` は `41`。
    * 3回目のループ: `x` は `[16, 8, 16, 17, 14]`、`sum(x)` は `71`。
    * 4回目のループ: `x` は `[1]`、`sum(x)` は `1`。
    * 5回目のループ: `x` は `[5, 3, 5, 7]`、`sum(x)` は `20`。
   リスト `[25, 41, 71, 1, 20]` が生成されます。
3. `sum([25, 41, 71, 1, 20])` は `158` になります。
4. `print(158 == 158)` が実行され、`True` が出力されます。

**出力結果:**

```
True
```

### 5. ネストしたリスト内包表記：行列の足し算

```python
def sum_matrix(list1, list2):
    return [[list1[i][j] + list2[i][j] for j in range(len(list2))] for i in range(len(list1))]

print(sum_matrix([[1,5,3],[4,5,6],[7,8,9]], [[1,4,7],[2,5,8],[3,6,9]])==[[2, 9, 10], [6, 10, 14], [10, 14, 18]])
```

**コードの概要:**

このコードは、2つの同じサイズの行列（リストのリスト）を受け取り、対応する要素同士を足し合わせて新しい行列を作成する関数 `sum_matrix` を定義し、期待値との比較結果を出力します。

**文法の分解:**

* **`def sum_matrix(list1, list2):`**:
    * 関数 `sum_matrix` を定義し、引数として2つのリスト `list1` と `list2` を受け取ります。これらは行列を表すネストしたリストです。

* **`return [[list1[i][j] + list2[i][j] for j in range(len(list2))] for i in range(len(list1))]`**:
    * これは**ネストしたリスト内包表記**です。外側のリスト内包表記が各行を生成し、内側のリスト内包表記が各行の要素を生成します。
    * **`for i in range(len(list1))`**: 外側のループで、`list1` の行数だけ繰り返します。変数 `i` は行のインデックスを表します。
    * **`[list1[i][j] + list2[i][j] for j in range(len(list2))]`**: 内側のリスト内包表記で、現在の行の各要素を生成します。
        * **`for j in range(len(list2))`**: 内側のループで、`list2` の列数（`list1` と同じと仮定）だけ繰り返します。変数 `j` は列のインデックスを表します。
        * **`list1[i][j] + list2[i][j]`**: `list1` の `i` 行 `j` 列の要素と `list2` の `i` 行 `j` 列の要素を足し合わせます。
        * **`[ ... ]`**: 足し合わされた結果が、新しい行列の現在の行の要素として格納されます。
    * **`[[ ... ]]`**: 外側の角括弧は、内側のリスト内包表記で生成された行を要素とする、新しい行列（リストのリスト）を作成することを示します。

* **`print(sum_matrix([[1,5,3],[4,5,6],[7,8,9]], [[1,4,7],[2,5,8],[3,6,9]])==[[2, 9, 10], [6, 10, 14], [10, 14, 18]])`**:
    * 関数 `sum_matrix` を、2つの具体的な行列を引数として呼び出します。
    * 関数の戻り値（足し合わされた新しい行列）が、期待される行列 `[[2, 9, 10], [6, 10, 14], [10, 14, 18]]` と等しいかどうかを比較し、結果を出力します。

**実行例:**

1. 関数 `sum_matrix` が2つの行列を引数として呼び出されます。
2. 外側のリスト内包表記が実行されます。
    * `i = 0` の場合: 内側のリスト内包表記が実行され、1行目の要素が生成されます。
        * `j = 0`: `list1[0][0] + list2[0][0]` は `1 + 1 = 2`
        * `j = 1`: `list1[0][1] + list2[0][1]` は `5 + 4 = 9`
        * `j = 2`: `list1[0][2] + list2[0][2]` は `3 + 7 = 10`
       1行目は `[2, 9, 10]` となります。
    * `i = 1` の場合: 同様に2行目の要素が生成されます。
       2行目は `[6, 10, 14]` となります。
    * `i = 2` の場合: 同様に3行目の要素が生成されます。
       3行目は `[10, 14, 18]` となります。
3. 新しい行列 `[[2, 9, 10], [6, 10, 14], [10, 14, 18]]` が生成されます。
4. `print([[2, 9, 10], [6, 10, 14], [10, 14, 18]] == [[2, 9, 10], [6, 10, 14], [10, 14, 18]])` が実行され、`True` が出力されます。

**出力結果:**

```
True
```

これらの解説を通して、Pythonのリスト操作、関数、リスト内包表記といった基本的ながらも重要な概念を理解する助けになれば幸いです。


<br>
<br>

---

# 6-2

## コード解説

### Practice 1

```python
print(f'=========================== Practice 1')
def max_value_key(d):
    return max(d, key=lambda x: d[x])

print(max_value_key({3:10, 5:2, 9:1}) == 3)
```

この関数 `max_value_key(d)` は、**ディクショナリ（辞書） `d` の中で、値が最も大きいキー** を見つけ出すものです。

*   **`def max_value_key(d):`**:  `max_value_key` という名前の関数を定義します。この関数は `d` という引数を受け取ります。`d` はディクショナリを想定しています。
*   **`return max(d, key=lambda x: d[x])`**:  この部分が関数の中心となる処理です。
    *   **`max(d, ...)`**:  Pythonの組み込み関数 `max()` は、与えられたものの中から最大の要素を見つけ出す関数です。通常、リストやタプルなどの要素を比較して最大値を見つけますが、ここでは少し変わった使い方をしています。
    *   **`key=lambda x: d[x]`**:  `max()` 関数の `key` 引数に、`lambda x: d[x]` という記述があります。これは **無名関数（ラムダ式）** と呼ばれるもので、簡単に言うと「名前のない小さな関数」です。
        *   **`lambda x:`**:  「`x` という引数を受け取る関数」という意味です。`x` には、ディクショナリ `d` の各 **キー** が順番に入ってきます。
        *   **`d[x]`**:  ディクショナリ `d` に対して、キー `x` に対応する **値** を取り出す操作です。
    *   **まとめると**: `max(d, key=lambda x: d[x])` は、「ディクショナリ `d` の各キーに対して、そのキーに対応する値を比較し、最も大きい値を持つキーを返す」という意味になります。
*   **`print(max_value_key({3:10, 5:2, 9:1}) == 3)`**:  この部分は関数の動作を確認するためのものです。
    *   **`max_value_key({3:10, 5:2, 9:1})`**:  `max_value_key` 関数に、`{3:10, 5:2, 9:1}` というディクショナリを渡して実行します。このディクショナリでは、キー `3` の値は `10`、キー `5` の値は `2`、キー `9` の値は `1` です。したがって、最も大きい値を持つキーは `3` になります。
    *   **`== 3`**:  関数の実行結果が `3` と等しいかどうかを比較しています。結果が `True` であれば、関数は正しく動作していることになります。

### Practice 2

```python
print(f'=========================== Practice 2')
def max_abs(ln):
    return max(map(abs, ln))

print(max_abs([3,-8,1,0,7,-5]) == 8)
```

この関数 `max_abs(ln)` は、**数値のリスト `ln` の中で、絶対値が最も大きい数値** を見つけ出すものです。

*   **`def max_abs(ln):`**: `max_abs` という名前の関数を定義します。この関数は `ln` という引数を受け取ります。`ln` は数値のリストを想定しています。
*   **`return max(map(abs, ln))`**:  この部分が関数の中心となる処理です。
    *   **`map(abs, ln)`**:  `map()` 関数は、リストなどの要素すべてに対して、指定した関数を順番に適用するものです。
        *   **`abs`**:  Pythonの組み込み関数 `abs()` は、数値の絶対値を返す関数です。例えば、`abs(-8)` は `8` になります。
        *   **`ln`**:  入力となる数値のリストです。
        *   **まとめると**: `map(abs, ln)` は、リスト `ln` の各数値に対して `abs()` 関数を適用し、その結果（絶対値）を順番に生成する **イテレータ** というものを作ります。（イテレータは、必要になるたびに要素を生成する便利な仕組みです。）
    *   **`max(...)`**:  `max()` 関数は、`map()` が生成したイテレータから、最大の要素（ここでは絶対値が最大の値）を見つけ出して返します。
*   **`print(max_abs([3,-8,1,0,7,-5]) == 8)`**:  この部分は関数の動作を確認するためのものです。
    *   **`max_abs([3,-8,1,0,7,-5])`**:  `max_abs` 関数に、`[3,-8,1,0,7,-5]` という数値のリストを渡して実行します。リスト内の各数値の絶対値は、それぞれ `3`, `8`, `1`, `0`, `7`, `5` となります。この中で最も大きい値は `8` です。
    *   **`== 8`**:  関数の実行結果が `8` と等しいかどうかを比較しています。結果が `True` であれば、関数は正しく動作していることになります。

### Practice 3

```python
print(f'=========================== Practice 3')
def number_of_big_numbers(ln, n):
    return len(list(filter(lambda x: x > n, ln)))

print(number_of_big_numbers([10, 0, 7, 1, 5, 2, 9], 5) == 3)
```

この関数 `number_of_big_numbers(ln, n)` は、**数値のリスト `ln` の中で、数値 `n` よりも大きい数値がいくつあるか** を数えるものです。

*   **`def number_of_big_numbers(ln, n):`**:  `number_of_big_numbers` という名前の関数を定義します。この関数は `ln` （数値のリスト）と `n` （比較する数値）の2つの引数を受け取ります。
*   **`return len(list(filter(lambda x: x > n, ln)))`**:  この部分が関数の中心となる処理です。
    *   **`filter(lambda x: x > n, ln)`**:  `filter()` 関数は、リストなどの要素の中から、特定の条件を満たすものだけを抽出するものです。
        *   **`lambda x: x > n`**:  ラムダ式で、「`x` という引数を受け取り、`x` が `n` よりも大きければ `True` を、そうでなければ `False` を返す」という条件を表しています。`x` には、リスト `ln` の各数値が順番に入ってきます。
        *   **`ln`**:  入力となる数値のリストです。
        *   **まとめると**: `filter(lambda x: x > n, ln)` は、リスト `ln` の数値の中から、`n` よりも大きい数値だけを取り出した **イテレータ** を作ります。
    *   **`list(...)`**:  `filter()` が作ったイテレータを `list()` 関数に渡すことで、イテレータの中身をすべて含んだ **リスト** を新しく作成します。
    *   **`len(...)`**:  `len()` 関数は、リストや文字列などの **要素の数（長さ）** を数える関数です。ここでは、`filter` で抽出された「`n` より大きい数値」のリストの長さを数えています。
*   **`print(number_of_big_numbers([10, 0, 7, 1, 5, 2, 9], 5) == 3)`**:  この部分は関数の動作を確認するためのものです。
    *   **`number_of_big_numbers([10, 0, 7, 1, 5, 2, 9], 5)`**:  `number_of_big_numbers` 関数に、数値のリスト `[10, 0, 7, 1, 5, 2, 9]` と数値 `5` を渡して実行します。リストの中で `5` より大きい数値は `10`, `7`, `9` の3つです。
    *   **`== 3`**:  関数の実行結果が `3` と等しいかどうかを比較しています。結果が `True` であれば、関数は正しく動作していることになります。

### Practice 4

```python
print(f'=========================== Practice 4')
def number_of_long_lines(file, n):
    with open(file, 'r', encoding='utf-8') as f:
        return len(list(filter(lambda x: len(x) > n, f)))

print(number_of_long_lines('jugemu.txt', 10) == 6)
```

この関数 `number_of_long_lines(file, n)` は、**指定されたファイル `file` の中で、長さ（文字数）が `n` よりも長い行がいくつあるか** を数えるものです。

*   **`def number_of_long_lines(file, n):`**:  `number_of_long_lines` という名前の関数を定義します。この関数は `file` （ファイルの名前）と `n` （比較する長さ）の2つの引数を受け取ります。
*   **`with open(file, 'r', encoding='utf-8') as f:`**:  この部分は、ファイルを安全に開いて処理するための構文です。
    *   **`open(file, 'r', encoding='utf-8')`**:  指定された名前のファイルを **読み込みモード (`'r'`)** で開きます。
        *   **`file`**:  関数の引数として渡されたファイルの名前です。
        *   **`encoding='utf-8'`**:  ファイルの中身が **UTF-8** という文字コードで書かれていることを指定します。これにより、日本語などの文字も正しく読み込めます。
    *   **`as f`**:  開いたファイルは `f` という名前でプログラムの中で扱えるようになります。
    *   **`with ...:`**:  `with` を使うと、ファイルを使った処理が終わった後、自動的にファイルが閉じられるため、安全にファイルを扱うことができます。
*   **`return len(list(filter(lambda x: len(x) > n, f)))`**:  この部分は、Practice 3 の `number_of_big_numbers` 関数と非常によく似た構造をしています。
    *   **`filter(lambda x: len(x) > n, f)`**:
        *   **`f`**:  開かれたファイルオブジェクトです。ファイルオブジェクトは、テキストファイルを1行ずつ順番に読み込むことができる **イテレータ** のような働きをします。
        *   **`lambda x: len(x) > n`**:  ラムダ式で、「`x` という引数（ここではファイルの1行）を受け取り、その行の長さ `len(x)` が `n` よりも大きければ `True` を、そうでなければ `False` を返す」という条件を表しています。
        *   **まとめると**: `filter(lambda x: len(x) > n, f)` は、ファイル `f` の各行の中から、長さが `n` よりも長い行だけを取り出した **イテレータ** を作ります。
    *   **`list(...)`**:  `filter()` が作ったイテレータを `list()` 関数に渡すことで、イテレータの中身（長さが `n` より長い行）をすべて含んだ **リスト** を新しく作成します。
    *   **`len(...)`**:  `len()` 関数で、`filter` で抽出された「長さが `n` より長い行」のリストの長さを数えています。
*   **`print(number_of_long_lines('jugemu.txt', 10) == 6)`**:  この部分は関数の動作を確認するためのものです。
    *   **`number_of_long_lines('jugemu.txt', 10)`**:  `number_of_long_lines` 関数に、ファイル名 `'jugemu.txt'` と長さ `10` を渡して実行します。この例では、`jugemu.txt` というファイルの中で、長さが `10` より長い行がいくつあるかを数えます。
    *   **`== 6`**:  関数の実行結果が `6` と等しいかどうかを比較しています。結果が `True` であれば、関数は正しく動作していることになります。


<br>
<br>

---

# 6-3


```python
class HelloFileIterator(HelloFile):
    def __iter__(self):
        return self
    def __next__(self):
        line = self.readline()
        if line == '':
            raise StopIteration
        return line

print(f'================================== Practice1')

class StringFileIterator(HelloFileIterator):
    def __init__(self, s, n):
        self.s = s
        self.n = n

    def readline(self):
        if self.n == 0:
            return ''
        self.n = self.n - 1
        return self.s

f = StringFileIterator('abc', 3)
print(list(f) == ['abc','abc','abc'])
```

## **`StringFileIterator` クラスの概要:**

`StringFileIterator` クラスは、`HelloFileIterator` クラスを **継承** しています。これは、`StringFileIterator` が `HelloFileIterator` の機能を受け継ぎ、さらに独自の機能を追加できるということです。

### **`__init__` メソッド:**

```python
    def __init__(self, s, n):
        self.s = s
        self.n = n
```

- `__init__` は、クラスの **コンストラクタ** と呼ばれ、オブジェクトが作成されるときに最初に実行される特別なメソッドです。
- `StringFileIterator('abc', 3)` のようにオブジェクトを作成する際に、`'abc'` が `s` に、`3` が `n` に渡されます。
- `self.s = s` は、渡された文字列 `'abc'` をオブジェクトの属性 `s` に保存します。
- `self.n = n` は、渡された数値 `3` をオブジェクトの属性 `n` に保存します。この `n` は、文字列を何回繰り返すかを制御するために使われます。

### **`readline` メソッド (オーバーライド):**

```python
    def readline(self):
        if self.n == 0:
            return ''
        self.n = self.n - 1
        return self.s
```

- `readline` メソッドは、親クラスである `HelloFileIterator` (さらにその親クラスである `HelloFile`) にも定義されていますが、`StringFileIterator` では **オーバーライド (上書き)** されています。
- `if self.n == 0:` は、オブジェクトの属性 `n` が `0` かどうかをチェックします。もし `0` であれば、空文字列 `''` を返します。これは、もう文字列を返す必要がないことを意味します。
- `self.n = self.n - 1` は、`n` の値を `1` 減らします。
- `return self.s` は、オブジェクトの属性 `s` に保存されている文字列（この場合は `'abc'`）を返します。

### **`f = StringFileIterator('abc', 3)` の実行:**

この行で、`StringFileIterator` クラスの新しいオブジェクト `f` が作成されます。`__init__` メソッドが実行され、`f.s` は `'abc'`、`f.n` は `3` に設定されます。

### **`print(list(f) == ['abc','abc','abc'])` の評価:**

#### 1. **`list(f)` の処理:**
   - `list()` 関数は、引数として与えられたイテレータ（この場合は `f`）からすべての要素を取り出し、新しいリストを作成します。
   - `f` は `StringFileIterator` のインスタンスであり、`HelloFileIterator` から `__iter__` と `__next__` メソッドを継承しています。
   - `list(f)` は、内部的に `f` の `__next__` メソッドを繰り返し呼び出し、要素を取得していきます。

#### 2. **`f.__next__()` メソッドの呼び出しと `readline` メソッドの動作 (繰り返し):**
   - **1回目:** `f.__next__()` が呼ばれると、`readline()` が実行されます。`f.n` は `3` なので、`'abc'` が返され、`f.n` は `2` になります。
   - **2回目:** `f.__next__()` が呼ばれると、`readline()` が実行されます。`f.n` は `2` なので、`'abc'` が返され、`f.n` は `1` になります。
   - **3回目:** `f.__next__()` が呼ばれると、`readline()` が実行されます。`f.n` は `1` なので、`'abc'` が返され、`f.n` は `0` になります。
   - **4回目:** `f.__next__()` が呼ばれると、`readline()` が実行されます。`f.n` は `0` なので、空文字列 `''` が返されます。
   - `__next__()` メソッド内で `line == ''` の条件が満たされ、`raise StopIteration` が実行されます。`list()` はこの例外を受け取り、要素の取り出しを終了します。

#### 3. **`list(f)` の結果:**
   - `list(f)` は、`__next__()` から返された `'abc'`、`'abc'`、`'abc'` を要素とするリスト `['abc', 'abc', 'abc']` を作成します。

#### 4. **`== ['abc','abc','abc']` の比較:**
   - `list(f)` の結果である `['abc', 'abc', 'abc']` と、`['abc', 'abc', 'abc']` というリストリテラルを比較します。
   - 2つのリストは内容が完全に一致するため、この比較は `True` を返します。

#### 5. **`print()` 関数の出力:**
   - `print(True)` が実行され、コンソールに `True` と表示されます。

## **まとめ:**

`StringFileIterator` は、指定された文字列を指定された回数だけ繰り返すイテレータを作成するクラスです。`list(f)` は、このイテレータからすべての文字列を取り出してリストに変換し、そのリストが期待されるリストと一致するかどうかを評価しています。

<br>
<br>

---

# 9-recursive

## power (べき乗の計算)

```python
def power(base, expt):
    if expt == 0:
        return 1
    else:
        return base * power(base, expt - 1)

power(2, 10)
```

```python
def power(base, expt):
    if expt == 0:
        return 1
    elif expt % 2 == 0:
        return power(base, expt // 2) ** 2 # x**(2m) == (x*x)**m
    else:
        return base * power(base, expt - 1)

power(2, 10)
```

2つ目のコードの方が一般的に高速です。その理由と仕組みについて説明します。

**2つ目のコードが速い理由**

2つ目のコードは、指数 (`expt`) が偶数の場合に、計算回数を大幅に減らす最適化を行っているためです。

最初のコードは、指数が1減るごとに再帰呼び出しを行い、最終的に指数が0になるまで `base` を掛け続けます。例えば `power(2, 10)` の場合、10回の掛け算が行われます。

一方、2つ目のコードでは、指数が偶数の場合、`power(base, expt // 2) ** 2` という計算を行います。これは、例えば `power(2, 10)` なら `power(2, 5) ** 2` となり、指数を半分にしてから結果を2乗します。これにより、再帰呼び出しの回数が大幅に減り、計算量が削減されます。

**2つ目のコードの仕組み**

2つ目のコードは、指数が偶数か奇数かで処理を分けています。

* **指数が0の場合:**  これは最初のコードと同じで、どんな数の0乗も1なので `1` を返します。

* **指数が偶数の場合 (`elif expt % 2 == 0`):**
    * `power(base, expt // 2)` を呼び出します。これは、元の問題の指数を半分にした部分問題を解くことに相当します。
    * その結果を2乗 (`** 2`) します。これは、数学的な性質 `x**(2m) == (x*x)**m`  を利用しています。例えば、`2**10` は `(2**5)**2` と同じです。

* **指数が奇数の場合 (`else`):**
    * `base * power(base, expt - 1)` を呼び出します。これは、奇数の指数を「base * (baseの偶数乗)」という形に分解して計算する方法です。例えば、`2**11` は `2 * 2**10` と同じです。

**具体例: `power(2, 10)` の計算過程**

**最初のコード:**

1. `power(2, 10)` -> `2 * power(2, 9)`
2. `power(2, 9)`  -> `2 * power(2, 8)`
3. ...
4. `power(2, 1)`  -> `2 * power(2, 0)`
5. `power(2, 0)`  -> `1`
6. 最終的に `2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 2 * 1 = 1024`

**2つ目のコード:**

1. `power(2, 10)` (10は偶数) -> `power(2, 5) ** 2`
2. `power(2, 5)`  (5は奇数) -> `2 * power(2, 4)`
3. `power(2, 4)`  (4は偶数) -> `power(2, 2) ** 2`
4. `power(2, 2)`  (2は偶数) -> `power(2, 1) ** 2`
5. `power(2, 1)`  (1は奇数) -> `2 * power(2, 0)`
6. `power(2, 0)`  -> `1`
7. 計算を遡る:
   - `power(2, 1)` は `2 * 1 = 2`
   - `power(2, 2)` は `2 ** 2 = 4`
   - `power(2, 4)` は `4 ** 2 = 16`
   - `power(2, 5)` は `2 * 16 = 32`
   - `power(2, 10)` は `32 ** 2 = 1024`

このように、2つ目のコードでは再帰呼び出しの回数が大幅に減っていることがわかります。

**計算量の比較**

* **最初のコード:** 指数 `n` に対して、ほぼ `n` 回の掛け算が行われるため、計算量は O(n) となります。
* **2つ目のコード:** 指数が半分になるごとに再帰呼び出しが行われるため、計算量は O(log n) となります。

指数が大きくなるほど、この計算量の違いは顕著になり、2つ目のコードの効率が際立ちます。

**補足**

2つ目のコードで使われている手法は、「再帰的平方」や「バイナリ法」と呼ばれることもあります。これは、指数の二進数表現を利用して効率的にべき乗を計算する考え方に基づいています。

<br>
<br>

---

# 10-matplotlib

## ソートアルゴリズムの説明 (bubble_sort, merge_sort)

ソートアルゴリズムとは、データの集まり（例えば、数字のリスト）を特定の順序（例えば、小さい順）に並び替えるための手順のことです。身近な例で言うと、図書館で本の背表紙の番号順に本を並べたり、名簿を五十音順に並べたりする作業がソートのイメージです。

ここでは、提示された2つのソートアルゴリズム、**バブルソート**と**マージソート**について、それぞれ分かりやすく説明していきます。

### 1. バブルソート

#### アルゴリズムの概要

バブルソートは、リストの隣り合う要素を比較し、もし順番が逆なら交換する、という操作を繰り返すことでリストをソートするアルゴリズムです。まるで泡（バブル）が水面に向かって上がっていくように、大きい要素が徐々にリストの右端（または小さい要素が左端）に移動していく様子から、この名前が付けられました。

#### コードの説明

```python
import random

def bubble_sort(lst):
    n = 0  # 比較回数を数える変数
    for j in range(len(lst) - 1):  # リストの最後まで繰り返す（外側のループ）
        for i in range(len(lst) - 1 - j):  # 隣り合う要素を比較する（内側のループ）
            n = n + 1  # 比較回数をカウント
            if lst[i] > lst[i+1]:  # 左側の要素が右側の要素より大きければ
                lst[i + 1], lst[i] = lst[i], lst[i+1]  # 要素を交換
    return n  # 比較回数を返す
```

* **`for j in range(len(lst) - 1):`**: このループは、ソートのパス（一連の比較と交換）を制御します。リストの要素数より1回少ない回数だけ繰り返します。なぜなら、最後の要素は自動的に正しい位置に落ち着くからです。
* **`for i in range(len(lst) - 1 - j):`**: このループは、隣り合う要素の比較を行います。`j`の値が増えるにつれて、ソート済みの要素がリストの右端に移動していくため、比較する範囲が徐々に狭まります。
* **`if lst[i] > lst[i+1]:`**: 現在の要素 (`lst[i]`) が次の要素 (`lst[i+1]`) より大きい場合、順番が逆なので交換します。
* **`lst[i + 1], lst[i] = lst[i], lst[i+1]`**: これはPythonの便利な機能で、2つの変数の値を同時に交換します。

#### 事例

例えば、以下のリストをバブルソートで並び替えることを考えてみましょう。

```
[5, 1, 4, 2, 8]
```

1. **1回目のパス:**
   - `5` と `1` を比較 -> 交換 -> `[1, 5, 4, 2, 8]`
   - `5` と `4` を比較 -> 交換 -> `[1, 4, 5, 2, 8]`
   - `5` と `2` を比較 -> 交換 -> `[1, 4, 2, 5, 8]`
   - `5` と `8` を比較 -> 交換しない -> `[1, 4, 2, 5, 8]`

2. **2回目のパス:**
   - `1` と `4` を比較 -> 交換しない -> `[1, 4, 2, 5, 8]`
   - `4` と `2` を比較 -> 交換 -> `[1, 2, 4, 5, 8]`
   - `4` と `5` を比較 -> 交換しない -> `[1, 2, 4, 5, 8]`

3. **3回目のパス:**
   - `1` と `2` を比較 -> 交換しない -> `[1, 2, 4, 5, 8]`
   - `2` と `4` を比較 -> 交換しない -> `[1, 2, 4, 5, 8]`

4. **4回目のパス:**
   - `1` と `2` を比較 -> 交換しない -> `[1, 2, 4, 5, 8]`

最終的に、リストは `[1, 2, 4, 5, 8]` とソートされます。

#### メリットとデメリット

* **メリット:**
    * **実装が簡単:** コードが比較的短く、理解しやすいです。
    * **追加のメモリがほとんど不要:** リスト内で要素を交換するだけでソートできるため、余分な記憶領域をあまり使いません。
* **デメリット:**
    * **効率が悪い:** リストの要素数が多いほど、比較と交換の回数が非常に多くなり、ソートに時間がかかります。特に、逆順に並んだリストをソートする場合、最も時間がかかります。

#### 計算速度

バブルソートの計算速度は、一般的に **O(n^2)** と表現されます。これは、リストの要素数をnとしたとき、比較回数が最大でnの2乗に比例することを意味します。

* **最良の場合:** リストがすでにソートされている場合でも、すべての比較を行うため、O(n^2)となります。ただし、わずかな改良を加えることで、ソート済みの場合はO(n)にすることができます。
* **最悪の場合:** リストが逆順に並んでいる場合、すべての比較と交換を行うため、O(n^2)となります。
* **平均の場合:** 一般的にはO(n^2)となります。

### 2. マージソート

#### アルゴリズムの概要

マージソートは、「分割統治法」という考え方に基づいたソートアルゴリズムです。大きな問題を小さな問題に分割し、それぞれの小さな問題を解決した後、それらを組み合わせて元の大きな問題を解決します。

具体的には、以下の手順で行います。

1. **分割:** リストを要素が一つになるまで、再帰的に半分に分割します。
2. **ソート (マージ):** 分割された要素が一つになったら、隣り合うリストを順番に並べ替えながら結合（マージ）していきます。

#### コードの説明

```python
def merge_sort_rec(data, l, r, work):
    if l+1 >= r:  # リストの要素が1つ以下ならソート済み
        return 0
    m = l+(r-l)//2  # 中央のインデックスを計算
    n1 = merge_sort_rec(data, l, m, work)  # 左半分を再帰的にソート
    n2 = merge_sort_rec(data, m, r, work)  # 右半分を再帰的にソート
    n = 0
    i1 = l  # 左側のリストの開始インデックス
    i2 = m  # 右側のリストの開始インデックス
    for i in range(l, r):  # マージ処理
        from1 = False
        if i2 >= r:  # 右側のリストが空になったら
            from1 = True
        elif i1 < m:  # 左側のリストに要素が残っていて
            n = n + 1  # 比較回数をカウント
            if data[i1] <= data[i2]:  # 左側の要素が小さいか等しい場合
                from1 = True
        if from1:
            work[i] = data[i1]  # 左側の要素を一時的なリストにコピー
            i1 = i1 + 1
        else:
            work[i] = data[i2]  # 右側の要素を一時的なリストにコピー
            i2 = i2 + 1
    for i in range(l, r):  # 一時的なリストから元のリストにコピー
        data[i] = work[i]
    return n1+n2+n

def merge_sort(data):
    return merge_sort_rec(data, 0, len(data), [0]*len(data))
```

* **`merge_sort_rec(data, l, r, work)`**: この関数が再帰的にリストを分割し、マージを行います。
    * `data`: ソート対象のリスト。
    * `l`: ソートする部分リストの開始インデックス。
    * `r`: ソートする部分リストの終了インデックス（実際にはこのインデックスの1つ手前まで）。
    * `work`: 一時的なリスト（作業用バッファ）。
* **`if l+1 >= r:`**: 部分リストの要素が1つ以下になったら、すでにソートされているとみなして処理を終了します。
* **`m = l+(r-l)//2`**: 中央のインデックスを計算します。
* **`merge_sort_rec(data, l, m, work)`** と **`merge_sort_rec(data, m, r, work)`**: リストを左右に分割し、それぞれを再帰的にソートします。
* **マージ処理の部分:** 2つのソート済み部分リストを比較しながら、`work`リストに順番に格納していきます。
* **最後のループ:** `work`リストに格納されたソート済みの要素を元の`data`リストにコピーします。
* **`merge_sort(data)`**: マージソートを開始するための関数です。`merge_sort_rec`関数を呼び出す際に、初期値と作業用リストを渡します。

#### 事例

例えば、以下のリストをマージソートで並び替えることを考えてみましょう。

```
[5, 1, 4, 2, 8]
```

1. **分割:**
   - `[5, 1, 4, 2, 8]` -> `[5, 1]` と `[4, 2, 8]`
   - `[5, 1]` -> `[5]` と `[1]`
   - `[4, 2, 8]` -> `[4]` と `[2, 8]`
   - `[2, 8]` -> `[2]` と `[8]`

2. **マージ:**
   - `[5]` と `[1]` をマージ -> `[1, 5]`
   - `[4]` と `[2]` をマージ -> `[2, 4]`
   - `[2, 4]` と `[8]` をマージ -> `[2, 4, 8]`
   - `[1, 5]` と `[2, 4, 8]` をマージ -> `[1, 2, 4, 5, 8]`

最終的に、リストは `[1, 2, 4, 5, 8]` とソートされます。

#### メリットとデメリット

* **メリット:**
    * **安定した速度:** データの並び順に左右されにくく、常に比較的速い速度でソートできます。
    * **大規模なデータに適している:** 要素数が増えても、効率の低下がバブルソートほど大きくありません。
* **デメリット:**
    * **追加のメモリが必要:** マージ処理のために、元のリストと同じくらいの大きさの一時的なリスト（`work`）が必要です。
    * **再帰処理の理解が必要:** コードが少し複雑で、再帰的な考え方を理解する必要があります。

#### 計算速度

マージソートの計算速度は、常に**O(n log n)**と表現されます。これは、リストの要素数をnとしたとき、比較回数がnにlog nをかけた値に比例することを意味します。

* **最良の場合:** O(n log n)
* **最悪の場合:** O(n log n)
* **平均の場合:** O(n log n)

### 違い

| 特徴           | バブルソート                      | マージソート                        |
|----------------|-----------------------------------|------------------------------------|
| アルゴリズム     | 隣接要素の比較と交換              | 分割統治法 (分割とマージ)         |
| 実装           | 簡単                              | 比較的複雑                         |
| 追加メモリ       | ほとんど不要                      | 必要 (元のリストと同程度)           |
| 計算速度       | O(n^2) (最良はO(n)にできる)     | O(n log n)                         |
| 安定性         | 安定                              | 安定                              |
| 得意なデータ     | ほとんどソート済みのデータ       | 大規模なデータ                     |
| 不得意なデータ   | 逆順に並んだデータ、大規模なデータ | 特になし                             |

**安定性:** 同じ値を持つ要素の相対的な順序がソート後も保たれる性質を指します。どちらのアルゴリズムも安定です。

### メリットとデメリットの比較

* **バブルソート:**
    * **メリット:** コーディングが簡単で、小さなデータセットやほぼソート済みのデータに対しては手軽に使えます。
    * **デメリット:** 大きなデータセットに対しては非常に遅く、実用的な場面ではあまり使われません。

* **マージソート:**
    * **メリット:** 大きなデータセットでも安定して高速にソートできます。
    * **デメリット:** 実装が少し複雑で、追加のメモリが必要です。

### 計算速度の比較

一般的に、データの数が少ない場合は、バブルソートでもマージソートでも処理時間に大きな差は見られません。しかし、データの数が多くなるにつれて、計算速度の差は顕著になります。

例えば、10個のデータをソートする場合、バブルソートでも瞬時に終わりますが、100万個のデータをソートする場合、バブルソートでは非常に時間がかかりますが、マージソートは比較的短時間で処理を終えることができます。

**まとめると:**

* **バブルソート:** プログラミングの学習用として、アルゴリズムの基本的な考え方を理解するのに役立ちます。実用的な大規模データのソートには不向きです。
* **マージソート:** 実際のシステム開発などで、効率的なソート処理が必要な場合に広く利用されるアルゴリズムです。

どちらのアルゴリズムも、ソート処理の基本的な考え方を学ぶ上で重要です。それぞれの特性を理解し、状況に応じて適切なアルゴリズムを選択できるようになることが大切です。

<br>

### [補足] マージの具体例

`[1, 5]` と `[2, 4, 8]` をマージして `[1, 2, 4, 5, 8]` になる過程を具体的に説明しますね。マージ処理は、2つのソート済みのリストを1つのソート済みリストにまとめる操作です。

ここでは、2つのリストの先頭から順番に要素を比較し、小さい方を新しいリストに追加していくという手順で行われます。

**ステップごとの説明**

1. **初期状態:**
   - リストA: `[1, 5]`
   - リストB: `[2, 4, 8]`
   - 結果リスト: `[]` (最初は空)

2. **最初の比較:**
   - リストAの先頭要素は `1`、リストBの先頭要素は `2` です。
   - `1` と `2` を比較すると、`1` の方が小さいです。

3. **`1` を追加:**
   - 小さい方の `1` を結果リストに追加します。
   - 結果リスト: `[1]`
   - リストAのポインタを次の要素 (`5`) に進めます。

4. **次の比較:**
   - リストAの現在の要素は `5`、リストBの先頭要素は `2` です。
   - `5` と `2` を比較すると、`2` の方が小さいです。

5. **`2` を追加:**
   - 小さい方の `2` を結果リストに追加します。
   - 結果リスト: `[1, 2]`
   - リストBのポインタを次の要素 (`4`) に進めます。

6. **さらに比較:**
   - リストAの現在の要素は `5`、リストBの現在の要素は `4` です。
   - `5` と `4` を比較すると、`4` の方が小さいです。

7. **`4` を追加:**
   - 小さい方の `4` を結果リストに追加します。
   - 結果リスト: `[1, 2, 4]`
   - リストBのポインタを次の要素 (`8`) に進めます。

8. **さらに比較:**
   - リストAの現在の要素は `5`、リストBの現在の要素は `8` です。
   - `5` と `8` を比較すると、`5` の方が小さいです。

9. **`5` を追加:**
   - 小さい方の `5` を結果リストに追加します。
   - 結果リスト: `[1, 2, 4, 5]`
   - リストAの要素はすべて使い終わりました。

10. **残りの要素を追加:**
    - リストAの要素がなくなったので、リストBに残っている要素 (`8`) をすべて結果リストに追加します。
    - 結果リスト: `[1, 2, 4, 5, 8]`

**図で表すと:**

```
リストA: [1,  5]
          ↑

リストB: [2,  4,  8]
          ↑

結果リスト: []

---

リストA: [1,  5]
             ↑

リストB: [2,  4,  8]
          ↑

結果リスト: [1]

---

リストA: [1,  5]
             ↑

リストB: [2,  4,  8]
             ↑

結果リスト: [1, 2]

---

リストA: [1,  5]
             ↑

リストB: [2,  4,  8]
                ↑

結果リスト: [1, 2, 4]

---

リストA: [1,  5]
                (終了)

リストB: [2,  4,  8]
                   ↑

結果リスト: [1, 2, 4, 5]

---

リストA: [1,  5]
                (終了)

リストB: [2,  4,  8]
                      (終了)

結果リスト: [1, 2, 4, 5, 8]
```

このように、マージ処理は2つのソート済みリストの要素を順番に比較し、小さい方を結果リストに追加していくことで、最終的に1つのソート済みリストを作り上げます。

<br>
<br>

## 練習 1 (plot_exp)

```python
def plot_exp():
    x = np.arange(-2, 2.1, 0.1)
    y = np.exp(x)

    plt.plot(x, y, label='$e^{x}$')
    plt.legend()
    plt.title('$y = e^{x}$')
    plt.xlabel('x')
    plt.ylabel('$e^{x}$')
    plt.grid(True);
    return x
```

```python
res_x = plot_exp()
print(f'{res_x}')
print(len(res_x) == 41, int(res_x[0]) == -2, int(res_x[9]) == -1)
```

```
[-2.00000000e+00 -1.90000000e+00 -1.80000000e+00 -1.70000000e+00
 -1.60000000e+00 -1.50000000e+00 -1.40000000e+00 -1.30000000e+00
 -1.20000000e+00 -1.10000000e+00 -1.00000000e+00 -9.00000000e-01
 -8.00000000e-01 -7.00000000e-01 -6.00000000e-01 -5.00000000e-01
 -4.00000000e-01 -3.00000000e-01 -2.00000000e-01 -1.00000000e-01
  1.77635684e-15  1.00000000e-01  2.00000000e-01  3.00000000e-01
  4.00000000e-01  5.00000000e-01  6.00000000e-01  7.00000000e-01
  8.00000000e-01  9.00000000e-01  1.00000000e+00  1.10000000e+00
  1.20000000e+00  1.30000000e+00  1.40000000e+00  1.50000000e+00
  1.60000000e+00  1.70000000e+00  1.80000000e+00  1.90000000e+00
  2.00000000e+00]
True True True
```
![](./10-matplotlib/image1.png)

この `print` 文は、`plot_exp` 関数が正しく動作しているかどうかを確認するためのテストです。具体的には、以下の3つの条件を確認しています：

---

### 1. `len(res_x) == 41`
- **確認内容**: `res_x` の長さが 41 であるかどうか。
- **意味**: `np.arange(-2, 2, 0.1)` で生成される配列の要素数が 41 個であることを確認しています。
  - `np.arange(-2, 2, 0.1)` は、-2 から 2 未満まで 0.1 刻みで値を生成します。
  - 計算式: `(2 - (-2)) / 0.1 = 40` ですが、`np.arange` は開始値を含むため、要素数は 41 になります。
  - 生成される値: `[-2.0, -1.9, -1.8, ..., 1.9]`（合計 41 個）

---

### 2. `int(res_x[0]) == -2`
- **確認内容**: `res_x` の最初の要素が -2 であるかどうか。
- **意味**: `np.arange(-2, 2, 0.1)` で生成される配列の最初の値が -2 であることを確認しています。
  - `res_x[0]` は `-2.0` なので、`int(res_x[0])` は `-2` になります。

---

### 3. `int(res_x[9]) == -1`
- **確認内容**: `res_x` の 10 番目の要素が -1 であるかどうか。
- **意味**: `np.arange(-2, 2, 0.1)` で生成される配列の 10 番目の値が -1 であることを確認しています。
  - `res_x[9]` は `-1.1 + 0.1 * 9 = -1.0` なので、`int(res_x[9])` は `-1` になります。

---

### テストの目的
このテストは、以下のことを確認するために行われています：
1. **配列の長さが正しいか**: `np.arange` で生成される配列の要素数が期待通りであるか。
2. **配列の値が正しいか**: 特定のインデックスの値が期待通りであるか。
3. **関数が正しく値を返しているか**: `plot_exp` 関数が `x` の値を正しく返しているか。

---

### テスト結果の解釈
- `True True True` が出力された場合:
  - すべての条件が満たされているため、関数が正しく動作していることを意味します。
- `False` が含まれる場合:
  - どこかで誤りがあるため、コードを確認する必要があります。

---

### 例
例えば、以下のような出力が得られます：
```
True True True
```
これは、すべての条件が満たされていることを示しています。

---

### 補足
- `int(res_x[0])` や `int(res_x[9])` のように `int` を使っている理由は、浮動小数点数の比較を避けるためです。
  - `res_x[0]` は `-2.0` ですが、`int(res_x[0])` は `-2` になります。
  - 浮動小数点数は精度の問題があるため、直接比較すると誤差が発生する可能性があります。


## 練習 2 (xxx)

## 練習 3 (xxx)

