# アルゴリズムと数学 演習問題集

https://atcoder.jp/contests/math-and-algorithm

---
### 009

```
def bf2(S, A):
    dp = [1] + [0] * S
    for i in A:
        print(f'----------------------------------------------------- i : {i}')
        print(range(S - i, -1, -1))
        for j in range(S - i, -1, -1):
            print(f'------------------------------------------ j : {j}')
            print(f'dp[{j}] : {dp[j]}')
            if dp[j] == 1:
                dp[j + i] = 1
                print(f'dp[{j}] == 1 => {dp[j] == 1}')
                print(f'dp[{j} + {i}] = 1')
            print(dp)
    print(f'========')
    print(dp)
    print("Yes" if dp[-1] == 1 else "No")

N, S = map(int, input().split())
A = list(map(int, input().split()))
bf2(S, A)
```

dp[i]は、「i」という合計値を作ることができるかどうかを表しています。<br>
1なら作れる、0なら作れないという意味です。

```
if dp[i]:
    dp[i + n] = 1
```

この部分は、「もしiという合計値が作れるなら、iにnを足した数も作れる」という意味になります。<br>
なぜなら、iが作れて、その上にnを足すことができるからです。

具体的な例で説明しますね。<br>
カードが[1, 2, 4]の3枚だけで、その合計がちょうど7になる組み合わせがあるかどうかを探すとします。

最初に、0から目標の数（この場合は7）までの各数値が作れるかどうかを記録するためのリスト（dp）を作ります。<br>
最初は全て「作れない（=0）」としておきますが、0だけは何も選ばないことで作れるので、「作れる（=1）」とします。

```
dp = [1, 0, 0, 0, 0, 0, 0, 0]
```

次に、各カードについて考えます。

最初のカードは1です。<br>
これを使って作れる数値は1と0（何も選ばない）です。<br>
したがって、dp[1]を「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 0, 0, 0, 0, 0, 0]
```

次に2が書かれたカードを考えます。<br>
このカードを使って作れる数値は2と0（何も選ばない）です。<br>
また、1が作れることがわかっているので、1+2=3も作れます。<br>
したがって、dp[2]とdp[3]を「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 1, 1, 0, 0, 0, 0]
```

最後に4が書かれたカードを考えます。<br>
このカードを使って作れる数値は4と0（何も選ばない）です。<br>
また、1から3までの全ての数が作れることがわかっているので、これらの数に4を足した5から7までの全ての数も作れます。<br>
したがって、dp[4]からdp[7]までを「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 1, 1, 1, 1, 1, 1]
```

以上の手順で、目標の数7が作れることがわかりました。<br>
したがって、「Yes」と出力します。

このように動的計画法では、
小さな問題（小さい数が作れるかどうか）から順に解いていき、最終的に大きな問題（目標の数が作れるかどうか）を解くことができます。<br>
この手法はプログラミングだけでなく、様々な問題解決に応用することができますよ。

---
### 011

このコードは素数判定を行う別のアプローチを示しています。
```
while i * i <= n:
    if n % i == 0 or n % (i + 2) == 0:
        return False
    i += 6
```

このループの目的と仕組みは以下の通りです：

```
i * i <= n：
```

この条件は、nの平方根までしか確認する必要がないことを利用しています。<br>
nが合成数の場合、少なくとも1つの因数はnの平方根以下になるためです。


if n % i == 0 or n % (i + 2) == 0:

これは6k±1の形の数のみをチェックしています。<br>
2と3で割り切れない全ての素数は、6k±1の形（6の倍数の前後）になるという性質を利用しています。

```
i += 6:
```

iを6ずつ増やしています。これにより、6k-1と6k+1の形の数をチェックできます。


このアプローチの利点：

効率性：2と3の倍数を事前に除外し、残りの数について6k±1の形のみをチェックすることで、チェックする数を大幅に減らしています。<br>
最適化：nの平方根までしかチェックしないことで、不必要な計算を避けています。<br>
高速性：大きな数に対しても比較的高速に動作します。<br>

ただし、このアプローチは前のエラトステネスの篩と比べると、大量の素数を生成する場合には若干効率が劣る可能性があります。<br>
エラトステネスの篩は一度の処理で複数の素数を見つけられるのに対し、このメソッドは各数を個別にチェックする必要があるためです。<br>
しかし、単一の数が素数かどうかを判定するだけなら、このアプローチの方が効率的な場合もあります。<br>
特に、判定する数の範囲が広く、密度が低い場合に有効です。
