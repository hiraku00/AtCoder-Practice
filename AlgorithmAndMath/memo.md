# アルゴリズムと数学 演習問題集

https://atcoder.jp/contests/math-and-algorithm

<br>

---
# 007

### 数学的な説明

まず、N以下の正の整数の中で、Xの倍数またはYの倍数であるものの個数を求める方法について説明します。

1. **Xの倍数の個数**:
   - N以下の正の整数の中でXの倍数の個数は、NをXで割った商です。例えば、N=15, X=3の場合、15以下の3の倍数は3, 6, 9, 12, 15の5個です。これは15 // 3 = 5で求められます。

2. **Yの倍数の個数**:
   - 同様に、N以下の正の整数の中でYの倍数の個数は、NをYで割った商です。例えば、N=15, Y=5の場合、15以下の5の倍数は5, 10, 15の3個です。これは15 // 5 = 3で求められます。

3. **XとYの両方の倍数の個数**:
   - XとYの両方の倍数は、XとYの最小公倍数（LCM）で割り切れる数です。例えば、X=3, Y=5の場合、最小公倍数は15です。N=15の場合、15以下の15の倍数は15の1個です。これは15 // 15 = 1で求められます。

4. **重複を取り除く**:
   - Xの倍数とYの倍数の合計から、XとYの両方の倍数の個数を引くことで、重複を取り除きます。例えば、N=15, X=3, Y=5の場合、Xの倍数は5個、Yの倍数は3個、両方の倍数は1個です。したがって、5 + 3 - 1 = 7個が答えです。

### コード全体の説明

```python
def gcd(x, y):
    while y != 0:
        x, y = y, x % y
    return x

def lcm(x, y):
    return x * y // gcd(x, y)

def count_multiples(N, X, Y):
    cnt_X = N // X
    cnt_Y = N // Y
    lcm_xy = lcm(X, Y)
    cnt_XY = N // lcm_xy
    return cnt_X + cnt_Y - cnt_XY

def main():
    N, X, Y = map(int, input().split())
    print(count_multiples(N, X, Y))

if __name__ == "__main__":
    main()
```

次に、コード全体で何をやっているかを説明します。

1. **最大公約数（GCD）を求める関数**:
   - `gcd(x, y)`は、ユークリッドの互除法を使って2つの数の最大公約数を求めます。

2. **最小公倍数（LCM）を求める関数**:
   - `lcm(x, y)`は、2つの数の積をその最大公約数で割ることで最小公倍数を求めます。

3. **倍数の個数をカウントする関数**:
   - `count_multiples(N, X, Y)`は、N以下の正の整数の中でXの倍数またはYの倍数であるものの個数を計算します。

4. **メイン関数**:
   - `main()`は、標準入力からN, X, Yの3つの整数を読み込み、`count_multiples`関数を使って結果を出力します。

### コードの詳細な説明

それでは、コードの各部分を事例を用いて詳細に説明します。

#### gcd関数
```python
def gcd(x, y):
    while y != 0:
        x, y = y, x % y
    return x
```
この関数は、ユークリッドの互除法を使って2つの数の最大公約数を求めます。例えば、`gcd(12, 15)`の場合、次のように計算します：
- 12 % 15 = 12
- 15 % 12 = 3
- 12 % 3 = 0
- よって、最大公約数は3です。

#### lcm関数
```python
def lcm(x, y):
    return x * y // gcd(x, y)
```
この関数は、2つの数の最小公倍数を求めます。例えば、`lcm(12, 15)`の場合、次のように計算します：
- 12 * 15 = 180
- gcd(12, 15) = 3
- 180 // 3 = 60
- よって、最小公倍数は60です。

#### count_multiples関数
```python
def count_multiples(N, X, Y):
    cnt_X = N // X
    cnt_Y = N // Y
    lcm_xy = lcm(X, Y)
    cnt_XY = N // lcm_xy
    return cnt_X + cnt_Y - cnt_XY
```
この関数は、N以下の正の整数の中でXの倍数またはYの倍数であるものの個数を計算します。例えば、`count_multiples(15, 3, 5)`の場合、次のように計算します：
- `cnt_X = 15 // 3 = 5`（3の倍数の個数）
- `cnt_Y = 15 // 5 = 3`（5の倍数の個数）
- `lcm_xy = lcm(3, 5) = 15`（3と5の最小公倍数）
- `cnt_XY = 15 // 15 = 1`（3と5の両方の倍数の個数）
- 結果: `5 + 3 - 1 = 7`

#### main関数
```python
def main():
    N, X, Y = map(int, input().split())
    print(count_multiples(N, X, Y))
```
この関数は、標準入力からN, X, Yの3つの整数を読み込み、`count_multiples`関数を使って結果を出力します。

### まとめ

このコードは、N以下の正の整数の中で、Xの倍数またはYの倍数であるものの個数を効率的に計算する方法を示しています。数学的な背景とコードの詳細な説明を通じて、初心者でも理解しやすいように説明しました。何か質問があれば教えてくださいね！

<br>
<br>

---
# 008

はい、承知しました。このコードについて、初心者にも分かりやすく、事例を交えながら詳しく説明していきます。



まず、コードの全体構造を見てみましょう：

1. `count_combination` 関数：この関数が主な計算を行います。
2. `main` 関数：入力を受け取り、結果を出力します。
3. `if __name__ == "__main__":` 部分：このスクリプトが直接実行された時に `main` 関数を呼び出します。

それでは、`count_combination` 関数を詳しく見ていきましょう。

```python
def count_combination(N, S):
    cnt = 0
    for red in range(1, N+1):
        max_blue = min(N, S - red)
        if max_blue >= 1:
            cnt += max_blue
        else:
            break
    return cnt
```

この関数の動作を、具体的な例を使って説明します。
例えば、N = 5（カードに書ける最大の数）、S = 7（合計の上限）とします。

1. `cnt = 0` で、組み合わせの数を数えるカウンターを初期化します。

2. `for red in range(1, N+1):` で、赤いカードに書く数を1から5まで順番に試していきます。

3. 各赤いカードの数に対して、`max_blue = min(N, S - red)` で青いカードに書ける最大の数を計算します。
   - 例えば、赤いカードが2の場合、S - red = 7 - 2 = 5 となります。
   - この5と、カードに書ける最大の数N（この場合も5）を比較し、小さい方を選びます。
   - つまり、青いカードには最大で5まで書けることになります。

4. `if max_blue >= 1:` で、青いカードに正の整数が書けるかチェックします。
   - もし書けるなら、`cnt += max_blue` でその数だけカウンターに加算します。
   - 例えば、赤が2の時、青は1から5まで書けるので、5通りの組み合わせがあります。

5. もし `max_blue < 1` になったら、それ以降の赤いカードの数ではもう条件を満たせないので、`break` でループを抜けます。




### 具体的な計算過程

`N = 5`（カードに書ける最大の数）、`S = 7`（合計の上限）という具体例でコードがどのように動作するかを詳しく説明します。

### 前提条件
- **赤のカード**と**青のカード**に書ける整数は `1` から `5` です。
- **合計**は `7` 以下でなければならないので、赤と青に書いた数字の合計が `7` 以下になる組み合わせを探します。

### 各ステップの具体例

1. **赤のカードに `1` が書かれる場合**:
   - 赤のカードが `1` のとき、青のカードに書ける最大の値は `S - red = 7 - 1 = 6` ですが、青に書ける最大の数は `5` なので、`min(5, 6) = 5`。
   - 青のカードに書ける値は `1` から `5` までです。
   - 組み合わせ: `(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)` の **5通り**

2. **赤のカードに `2` が書かれる場合**:
   - 赤のカードが `2` のとき、青のカードに書ける最大の値は `S - red = 7 - 2 = 5` なので、`min(5, 5) = 5`。
   - 青のカードに書ける値は `1` から `5` までです。
   - 組み合わせ: `(2, 1), (2, 2), (2, 3), (2, 4), (2, 5)` の **5通り**

3. **赤のカードに `3` が書かれる場合**:
   - 赤のカードが `3` のとき、青のカードに書ける最大の値は `S - red = 7 - 3 = 4` なので、`min(5, 4) = 4`。
   - 青のカードに書ける値は `1` から `4` までです。
   - 組み合わせ: `(3, 1), (3, 2), (3, 3), (3, 4)` の **4通り**

4. **赤のカードに `4` が書かれる場合**:
   - 赤のカードが `4` のとき、青のカードに書ける最大の値は `S - red = 7 - 4 = 3` なので、`min(5, 3) = 3`。
   - 青のカードに書ける値は `1` から `3` までです。
   - 組み合わせ: `(4, 1), (4, 2), (4, 3)` の **3通り**

5. **赤のカードに `5` が書かれる場合**:
   - 赤のカードが `5` のとき、青のカードに書ける最大の値は `S - red = 7 - 5 = 2` なので、`min(5, 2) = 2`。
   - 青のカードに書ける値は `1` から `2` までです。
   - 組み合わせ: `(5, 1), (5, 2)` の **2通り**

### 全体の組み合わせの数
これらすべての組み合わせを足すと、次のようになります：
- 赤のカードが `1` の場合: **5通り**
- 赤のカードが `2` の場合: **5通り**
- 赤のカードが `3` の場合: **4通り**
- 赤のカードが `4` の場合: **3通り**
- 赤のカードが `5` の場合: **2通り**

したがって、合計は:

```
5 + 5 + 4 + 3 + 2 = 19 通り
```

この方法の数学的な考え方：
- 合計がS以下という条件は、「青 ≤ S - 赤」と言い換えられます。
- また、青はNを超えてはいけません。
- したがって、青の取りうる最大値は「min(N, S - 赤)」となります。
- この最大値から1までの整数の数が、各赤の値に対する組み合わせの数になります。

この解法の利点は、すべての組み合わせを個別に数える必要がなく、各赤の値に対して可能な青の値の数を一度に計算できることです。これにより、計算速度が大幅に向上します。

最後に、`main` 関数では `input().split()` で入力を受け取り、`map(int, ...)` でそれぞれを整数に変換しています。そして `count_combination` 関数を呼び出し、結果を出力します。

このように、このコードは効率的に組み合わせの数を計算し、大きな入力に対しても高速に動作します。

<br>
<br>

---
# 009

## コードの全体構造

このプログラムは、カードの合計が特定の数になるかどうかを判断するものです。大きく分けて2つの関数があります：

1. `can_make_sum(S, A)`: 実際の計算を行う関数
2. `main()`: 入力を受け取り、結果を出力する関数

## 入力の解釈

まず、入力を解釈します：
- N = 4 (カードの枚数)
- S = 11 (目標の合計)
- A = [3, 1, 4, 5] (各カードの数値)

## can_make_sum 関数の詳細説明

```python
def can_make_sum(S, A):
    dp = [0] * (S+1)
    dp[0] = 1
    for i in A:
        for j in range(S-i, -1, -1):
            if dp[j] == 1:
                dp[j+i] = 1
    return 'Yes' if dp[-1] == 1 else 'No'
```

### dpリストの初期化

```python
dp = [0] * (S+1)
dp[0] = 1
```

この部分で、長さ12（S+1 = 11+1 = 12）のリストを作成し、全て0で初期化します。そして、dp = 1 とします。

初期状態：
```
dp = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      0  1  2  3  4  5  6  7  8  9 10 11
```

### メインのループ処理

```python
for i in A:
    for j in range(S-i, -1, -1):
        if dp[j] == 1:
            dp[j+i] = 1
```

このループは各カードの数値（i）について処理を行います。

#### なぜ range(S-i, -1, -1) を使うのか？

この部分は非常に重要で、巧妙な工夫がされています：

1. 逆順で処理する理由：
   各カードを1回だけ使用することを保証するためです。前から処理すると、同じカードを複数回使ってしまう可能性があります。

2. S-i から始める理由：
   i を加えて S を超える合計は考慮する必要がないからです。

3. -1 まで処理する理由：
   Python のrange は終点を含まないので、0まで処理するには-1を指定する必要があります。

それでは、各カードについて処理を見ていきましょう：

1. i = 3 の場合：
   ```
   for j in range(8, -1, -1):
       if dp[j] == 1:
           dp[j+3] = 1
   ```
   結果：
   ```
   dp = [1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]
         0  1  2  3  4  5  6  7  8  9 10 11
   ```
   3を加えて新しく作れる合計は3だけです。

2. i = 1 の場合：
   ```
   for j in range(10, -1, -1):
       if dp[j] == 1:
           dp[j+1] = 1
   ```
   結果：
   ```
   dp = [1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0]
         0  1  2  3  4  5  6  7  8  9 10 11
   ```
   1を加えて新しく作れる合計は1と4（3+1）です。

3. i = 4 の場合：
   ```
   for j in range(7, -1, -1):
       if dp[j] == 1:
           dp[j+4] = 1
   ```
   結果：
   ```
   dp = [1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0]
         0  1  2  3  4  5  6  7  8  9 10 11
   ```
   4を加えて新しく作れる合計は4、5（1+4）、7（3+4）、8（4+4）です。

4. i = 5 の場合：
   ```
   for j in range(6, -1, -1):
       if dp[j] == 1:
           dp[j+5] = 1
   ```
   結果：
   ```
   dp = [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0]
         0  1  2  3  4  5  6  7  8  9 10 11
   ```
   5を加えて新しく作れる合計は5、6（1+5）、8（3+5）、9（4+5）です。

### 結果の判定

```python
return 'Yes' if dp[-1] == 1 else 'No'
```

最後に、dp[-1]（つまりdp）が1かどうかをチェックします。この例では0なので、'No'が返されます。

つまり、3, 1, 4, 5 のカードを使って合計11を作ることはできないという結論になります。

このアルゴリズムは、可能な全ての組み合わせを効率的に探索し、目標の合計を作れるかどうかを判断します。動的計画法を使うことで、重複計算を避け、効率的に解を求めることができるのです。

<br>
<br>

---
# 011

## 素数判定プログラムを解説！

```python
def prime(N):
    primes = [True] * (N+1)
    primes[0] = primes[1] = False
    for i in range(2, int(N**0.5)+1):
        if primes[i]:
            for j in range(i*i, N+1, i):
                primes[j] = False
    return [i for i in range(N+1) if primes[i]]

def main():
    N = int(input())
    print(*prime(N))

if __name__ == "__main__":
    main()
```

このプログラムは、**エラトステネスの篩** という方法を使って、ある数までの素数を効率的に見つけるよ！
難しそうな名前だけど、仕組みはとってもシンプルなんだ！

**具体的な例で見てみよう！ N = 10 の場合を考えてみるね！**

**1. prime(N) 関数の解説**

   - まず、`primes = [True] * (N+1)` で、`True` が11個 (`N+1` 個) 並んだリストを作るよ。
     これは、0から10までの数字が、最初は全部「素数かもしれない」状態ってことを表しているんだ。
     ```
     primes = [True, True, True, True, True, True, True, True, True, True, True]
               (0)   (1)   (2)   (3)   (4)   (5)   (6)   (7)   (8)   (9)   (10)
     ```

   - 次に、`primes[0] = primes[1] = False` で、0と1を「素数じゃない」とマークする。
     なぜなら、素数は「1 と自分自身以外に約数を持たない数」のことだけど、0と1はこれに当てはまらないよね？
     ```
     primes = [False, False, True, True, True, True, True, True, True, True, True]
               (0)    (1)    (2)   (3)   (4)   (5)   (6)   (7)   (8)   (9)   (10)
     ```

   - ここからが本番！ `for i in range(2, int(N**0.5)+1):` のループで、2から√10 (≒3.16なので、整数部分は3) までの数字 `i` を順番に見ていくよ。

     - **`i = 2` のとき:**
       - まず、`if primes[i]:` で、`primes[2]` が `True` かどうかを確認する。 今は `True` だね！
       これは、「2はまだ素数だと考えられている」って意味だよ。
       - `primes[2]` が `True` なので、`for j in range(i*i, N+1, i):` のループに入る。
         これは、「2の倍数(4, 6, 8, 10)を全部「素数じゃない」とマークする」処理をする部分だよ。
         - `j` は 4, 6, 8, 10 と変化していき、その度に `primes[j]` を `False` にしていく。
           ```
           primes = [False, False, True, True, False, True, False, True, False, True, False]
                     (0)    (1)    (2)   (3)   (4)    (5)   (6)    (7)   (8)    (9)   (10)
           ```
     - **`i = 3` のとき:**
       - `primes[3]` はまだ `True` なので、3の倍数(9)を「素数じゃない」とマークする。
         ```
         primes = [False, False, True, True, False, True, False, True, False, False, False]
                  (0)     (1)    (2)   (3)   (4)    (5)   (6)    (7)   (8)    (9)   (10)
         ```

     - `i = 4` 以降は、√10 を超えるのでループに入らない。なぜなら、√N より大きい数の倍数は、
     すでに小さい素数の倍数として処理されているからなんだ！  例えば、4 × 5 = 2 × 10 は、
     すでに 2 の倍数として処理されているよね？

   - 最後に、`return [i for i in range(N+1) if primes[i]]` で、`primes` リストの中で `True` になっている要素
    (つまり、素数と判定された数字)だけを 集めたリストを返すよ。
    今回の例では、`[2, 3, 5, 7]` が返されるね！

**2. main() 関数の解説**

   - `N = int(input())` で、ユーザーからの入力を整数として受け取る。
   - `print(*prime(N))` で、`prime(N)` 関数を実行して得られた素数のリストを、空白区切りで表示する。
     `*` はリストの要素を展開する記号だよ！

**3. if __name__ == "__main__":**
   - これは、このプログラムが直接実行されたときにのみ `main()` 関数を実行するためのおまじないみたいなものだよ！
    今のところは深く考えなくても大丈夫！

**数学的な補足: なぜ √N までで良いの？**

- ある数 N が合成数（素数ではない数）の場合、N は必ず √N 以下の約数を持つ。
- 例えば、12 は 2 × 6、3 × 4 と分解できるよね？ √12 (≒ 3.46) より小さい約数 (2, 3) を持っていることがわかるね！
- なので、√N までの数で割り切れなければ、それより大きい数で割り切れるはずがないんだ！

これで、エラトステネスの篩を使った素数判定プログラムの解説は終わり！ どうだったかな？
最初は難しく感じるかもしれないけど、具体的な例を参考にしながら、じっくりと理解していこう！ 😊

<br>
<br>

## [補足] `[i for i in range(N+1) if primes[i]]`表記

`[i for i in range(N+1) if primes[i]]` は一見難しそうに見えますが、**リスト内包表記** と呼ばれるもので、Pythonではよく使われる書き方なんです。

### 分かりやすく分解してみよう！

この部分を、もっとシンプルで分かりやすい書き方に分解してみましょう。

```python
result = []  # 空のリストを用意
for i in range(N+1): # 0 から N まで順番に i を取り出す
    if primes[i]: # もし primes[i] が True なら（つまり i が素数なら）
        result.append(i)  # result リストに i を追加する

# 最終的に result には、素数のリストが格納される
```

ね？ 同じことをしているのが分かりますか？

### リスト内包表記のスゴイところ

リスト内包表記を使うと、上記のようにループと条件分岐で書いていた処理を、1行でスッキリと書くことができます！

- `[i for i in range(N+1) if primes[i]]`
    -  `[]` で囲まれているので、これはリストを作る処理だと分かります。
    -  `for i in range(N+1)` は、先ほどと同じくループを表しています。
    -  `if primes[i]` は、条件に合致する要素だけをリストに追加するための条件です。

### もう少し具体的な例を見てみよう！

例えば、N = 5 の場合を考えてみましょう。

- `primes = [False, False, True, True, False, True]`
   (2, 3, 5 が素数)
- `[i for i in range(N+1) if primes[i]]` は、`primes` が `True` の要素、つまり `primes[2]`, `primes[3]`, `primes[5]` に対応する `i` を集めたリスト、つまり `[2, 3, 5]` を返します。

### まとめ

リスト内包表記は、最初は戸惑うかもしれませんが、慣れるとコードがスッキリと短く書ける便利な方法です。
最初は分解して考えると理解しやすいので、ぜひ試してみてください！ 💪

<br>
<br>

## [補足]`i for i in range(...)` の最初の `i`

`i for i in range(...)` の最初の `i` は、**「最終的にリストに追加したい値」** を表しています。

もう少し詳しく説明すると、

- `for i in range(...)`:  これは、指定された範囲 (例えば `range(5)` なら 0, 1, 2, 3, 4) をループで回す部分を意味しています。  このループの中で、変数 `i` には順番に 0, 1, 2, 3, 4 が代入されます。
- その前にある `i` : これが、それぞれのループで **「実際にリストに追加する値」** となります。

### 具体的な例で見てみましょう！

1. **単純なリストを作る場合**

   ```python
   numbers = [i for i in range(5)]
   print(numbers)  # 出力: [0, 1, 2, 3, 4]
   ```
   - この場合、`i` の値がそのままリストに追加されるので、0から4までの数字が順番に入ったリストが作成されます。

2. **条件に合致する値だけを追加する場合**

   ```python
   even_numbers = [i for i in range(10) if i % 2 == 0]
   print(even_numbers)  # 出力: [0, 2, 4, 6, 8]
   ```
   - この例では、`if i % 2 == 0` という条件を満たす `i` (つまり偶数) だけがリストに追加されます。

3. **値を加工する場合**

   ```python
   squares = [i*i for i in range(5)]
   print(squares)  # 出力: [0, 1, 4, 9, 16]
   ```
   - このように、最初の `i` を `i*i` のように加工することで、各数字の2乗を要素とするリストを作成することもできます。

### まとめ

- `i for i in ...` の最初の `i` は、ループ処理の中で最終的にリストに追加したい値を決める役割を担っています。
- この部分を変更することで、様々な条件で値を抽出したり、加工したりすることが可能になります！

より複雑な処理もできますが、まずは基本的な部分をしっかり理解することが大切です。
頑張ってくださいね！ 😊

<br>
<br>

---
# 012

このコードは、与えられた数 `N` が素数であるかどうかを判定するためのものです。ここでは、コードの各部分を初心者にも分かりやすく、具体的な例を用いて解説します。

### 1. `is_prime` 関数の説明

```python
def is_prime(n):
    if n < 2: return False
    for i in range(2, int(n*0.5)+1):
        if n % i == 0:
            return False
    return True
```

#### - `n < 2` のチェック

まず、`n` が 2 未満の場合、素数とは見なされないため、`False` を返します。素数は 2 以上の自然数なので、例えば `n = 1` や `n = 0` の場合は、必ず `False` となります。

#### - 素数判定のためのループ

次に、`n` が 2 以上である場合、`2` から `n` の半分 (`n*0.5`) までの整数で割り切れるかどうかをチェックします。割り切れる整数が見つかった場合、その数は素数ではないため、`False` を返します。

- 例えば `n = 10` の場合、半分の `5` までの整数（`2`, `3`, `4`, `5`）で割り切れるかどうかをチェックします。`10` は `2` で割り切れるので、`False` が返されます。

- 逆に、`n = 7` の場合、半分の `3.5` を切り上げた `4` までの整数（`2`, `3`, `4`）で割り切れません。よって `True` が返されます。

#### - `return True`

最後に、上記のチェックをすべてクリアした場合、その数は素数であるため、`True` を返します。

### 2. `main` 関数の説明

```python
def main():
    N = int(input())
    print("Yes" if is_prime(N) else "No")
```

#### - `N = int(input())`

この行で、ユーザーから標準入力を通じて整数 `N` を取得します。例えば、ユーザーが `53` と入力した場合、`N` には `53` が代入されます。

#### - `print("Yes" if is_prime(N) else "No")`

`is_prime` 関数を使って、`N` が素数かどうかを判定します。素数であれば `True` が返ってくるので "Yes" を出力し、素数でなければ "No" を出力します。

- 例えば、`N = 53` なら `is_prime(53)` が `True` を返すので "Yes" と出力されます。
- 逆に、`N = 77` なら `is_prime(77)` が `False` を返すので "No" と出力されます。

### 3. 実行部分

```python
if __name__ == "__main__":
    main()
```

この部分は、スクリプトが直接実行されたときに `main` 関数を呼び出すためのものです。これにより、コードが実行されるときに `main()` が動き出します。

### 処理の流れを具体例で説明

#### - `N = 53` の場合

1. `main()` が実行され、`N` に `53` が代入されます。
2. `is_prime(53)` が呼ばれます。
3. `53` は 2 以上なので次のステップへ進みます。
4. `2` から `26` までの数で `53` を割り切れるかをチェックします。割り切れる数がないため `True` が返されます。
5. `True` が返されたので、"Yes" が出力されます。

#### - `N = 77` の場合

1. `main()` が実行され、`N` に `77` が代入されます。
2. `is_prime(77)` が呼ばれます。
3. `77` は 2 以上なので次のステップへ進みます。
4. `2` から `39` までの数で `77` を割り切れるかをチェックします。`77` は `7` で割り切れるため `False` が返されます。
5. `False` が返されたので、"No" が出力されます。

このように、このコードは素数を判定するためのシンプルで効果的な方法を提供しています。具体例を通じてコードの動作を理解することができたかと思います。

---

# 013

## Pythonで約数を求めるプログラム

このプログラムは、入力された整数 `N` の約数を全て求めて、それぞれを改行区切りで出力するものです。

**コードの解説:**

1. **`divisor(n)` 関数:**
   - この関数は、整数 `n` を受け取り、その約数のリストを返します。
   - `div = set()` : まず、空の集合 `div` を作成します。集合は、重複する要素を持たないデータ構造です。これにより、同じ約数が複数回出力されるのを防ぎます。
   - `for i in range(1, int(n**0.5)+1):`: 1 から `n` の平方根までの整数 `i` について、以下の処理を繰り返します。
     - `if n % i == 0:`:  `n` が `i` で割り切れる場合、つまり `i` が `n` の約数である場合、以下の処理を行います。
       - `div.add(i)`: `i` を集合 `div` に追加します。
       - `div.add(n // i)`: `n` を `i` で割った商もまた `n` の約数なので、これも集合 `div` に追加します。
   - `return sorted(div)`: 最後に、集合 `div` を昇順にソートしたリストを返します。

2. **`main()` 関数:**
   - この関数は、プログラムのメインの処理を行います。
   - `N = int(input())`: ユーザーからの入力を整数として受け取り、変数 `N` に格納します。
   - `print(*divisor(N), sep='\n')`: `divisor(N)` を呼び出して `N` の約数のリストを取得し、`print()` 関数を使って、それらの約数を改行 (`\n`) 区切りで出力します。 `*` はリストの要素を展開する役割を果たします。

3. **`if __name__ == "__main__":`:**
   - この部分は、このPythonファイルが直接実行された場合にのみ `main()` 関数を実行することを意味します。他のプログラムからこのファイルをモジュールとしてインポートする場合には、`main()` 関数は実行されません。

**処理の過程の例:**

例えば、`N` に 12 が入力された場合の処理過程は以下のようになります。

1. `divisor(12)` が呼び出されます。
2. `div` という空の集合が作成されます。
3. `for` ループで、`i` が 1 から 3 (12 の平方根は 3.46... なので、`int(12**0.5) + 1` は 4 になります) まで以下の処理が繰り返されます。
   - `i = 1`: 12 は 1 で割り切れるので、1 と 12 (12 // 1) が `div` に追加されます。
   - `i = 2`: 12 は 2 で割り切れるので、2 と 6 (12 // 2) が `div` に追加されます。
   - `i = 3`: 12 は 3 で割り切れるので、3 と 4 (12 // 3) が `div` に追加されます。
4. `div` ( `{1, 12, 2, 6, 3, 4}` ) がソートされ、 `[1, 2, 3, 4, 6, 12]` となります。
5. `[1, 2, 3, 4, 6, 12]` が `main()` 関数に返され、それぞれの要素が改行区切りで出力されます。

**出力:**

```
1
2
3
4
6
12
```

<br>
<br>

---
# 014


こちらのコードは、与えられた自然数 𝑁 を素因数分解して、素因数を小さい順に出力するプログラムです。

### コード全体の流れ
1. `main()` 関数で、ユーザーから数値 $N$ を入力として受け取ります。
2. `prime_fractorization()` 関数で、 $N$ を素因数分解して、素因数をリストに追加します。
3. `print()` でその素因数を空白区切りで出力します。

```python
def prime_fractorization(N):
    fractors = []
    for i in range(2, int(N**0.5)+1):
        while N % i == 0:
            fractors.append(i)
            N //= i
    if N > 1:
        fractors.append(N)
    return fractors

def main():
    N = int(input())
    print(' '.join(map(str, prime_fractorization(N))))

if __name__ == "__main__":
    main()
```

---

### `prime_fractorization(N)` 関数
この関数は、与えられた自然数 $N$ を素因数分解して、結果をリストに格納します。

```python
def prime_fractorization(N):
    fractors = []
```
#### 解説:
- `fractors` というリストを作成し、この中に $N$ の素因数を格納していきます。

```python
    for i in range(2, int(N**0.5)+1):
```
#### 解説:
- 2から $\sqrt{N}$ までの整数 $i$ を、素因数候補として調べます。
- これは、素因数の探索範囲を狭めるためで、平方根まで探索すれば、全ての素因数を見つけることができるからです。

#### 事例: $N = 210$ の場合
- $\sqrt{210} \approx 14.49$ なので、2から14までの整数が素因数の候補になります。

```python
        while N % i == 0:
            fractors.append(i)
            N //= i
```
#### 解説:
- `N % i == 0` で、 $N$ が現在の $i$ で割り切れるかをチェックします。
- 割り切れる場合、その $i$ をリストに追加し、 $N$ をその素因数で割ります (`N //= i`)。
- 割り切れる限り、同じ素因数で $N$ を割り続けます。

#### 事例: $N = 210$ の場合
- $i = 2$ からスタートします。
  - 210は2で割り切れるので、リストに `2` を追加し、210を2で割って $N = 105$ にします。
- 次に、 $i = 3$ をチェックします。
  - $N = 105$ も3で割り切れるので、リストに `3` を追加し、105を3で割って $N = 35$ にします。
- 次に、 $i = 5$ をチェックします。
  - $N = 35$ は5で割り切れるので、リストに `5` を追加し、35を5で割って $N = 7$ にします。
- 最後に、 $i = 7$ をチェックします。
  - $N = 7$ は7で割り切れるので、リストに `7` を追加し、 $N = 1$ になります。

```python
    if N > 1:
        fractors.append(N)
```
#### 解説:
- この部分では、ループが終わった後に、 $N$ が1より大きい場合、その $N$ 自体も素因数としてリストに追加します。
- ここでは、2や3で割り切れずに残った素数がある場合に対応するためです。

#### 事例: $N = 210$ の場合
- 最終的に $N = 1$ なので、ここでは何も追加されません。

```python
    return fractors
```
#### 解説:
- 求めた素因数のリストを返します。事例では、最終的に `fractors = [2, 3, 5, 7]` となります。

---

### `main()` 関数
```python
def main():
    N = int(input())
    print(' '.join(map(str, prime_fractorization(N))))
```
#### 解説:
- `N = int(input())` で、ユーザーから入力された数値を整数として受け取ります。例では、210が入力されると $N = 210$ になります。
- `prime_fractorization(N)` で、210の素因数分解を行い、その結果を `print()` で出力します。
- `map(str, prime_fractorization(N))` は、素因数のリストを文字列に変換し、`' '.join()` で空白区切りにして表示します。

---

### 実行の流れ

#### 事例: $N = 210 $
1. ユーザーが210を入力すると、`main()` 関数で $N = 210$ が設定されます。
2. `prime_fractorization(210)` が実行され、以下のステップで素因数が計算されます:
   - $i = 2$ で割り切れ、2を追加。 $N = 105$ になる。
   - $i = 3$ で割り切れ、3を追加。 $N = 35$ になる。
   - $i = 5$ で割り切れ、5を追加。 $N = 7$ になる。
   - $i = 7$ で割り切れ、7を追加。 $N = 1$ になる。
3. 最終的なリスト `fractors = [2, 3, 5, 7]` を返し、`print()` で「2 3 5 7」が出力されます。

---

### `if __name__ == "__main__":`
```python
if __name__ == "__main__":
    main()
```
#### 解説:
- これは、Pythonファイルが直接実行されたときに `main()` 関数を呼び出すためのコードです。プログラムが他のファイルからインポートされた場合には `main()` が実行されません。

---

### まとめ
このコードは、2から $\sqrt{N}$ までの範囲で $N$ を割りながら、素因数を見つけてリストに追加していきます。これにより、すべての素因数が小さい順にリストに格納され、最後にそれを空白区切りで出力します。

事例のように、 $N = 210$ の場合は「2 3 5 7」が出力されますが、これは $210 = 2 \times 3 \times 5 \times 7$ という素因数分解の結果です。

<br>
<br>

---
# 015

## コード解説： ユークリッドの互除法による最大公約数計算

このPythonコードは、**ユークリッドの互除法**という効率的なアルゴリズムを使って、2つの整数の最大公約数 (GCD) を計算します。

**コードの構成:**

1. **`gcd(a, b)` 関数:**
   - この関数は、引数として2つの整数 `a` と `b` を受け取り、それらの最大公約数を計算して返します。
   - ユークリッドの互除法のロジックを実装しています。

2. **`main()` 関数:**
   - プログラムの主要な処理を行う関数です。
   - ユーザーから2つの整数を入力として受け取り、`gcd()` 関数を呼び出して最大公約数を計算し、結果を表示します。

3. **`if __name__ == "__main__":` ブロック:**
   - このブロックは、スクリプトが直接実行された場合にのみ `main()` 関数を呼び出します。
   - これにより、このスクリプトを他のモジュールからインポートする場合に、`main()` 関数が自動的に実行されるのを防ぎます。

**ユークリッドの互除法の解説:**

このアルゴリズムは、以下の手順で最大公約数を計算します。

1. **大きい方の数を小さい方の数で割った余りを求める。**
2. **元の小さい方の数と余りを用いて、再度1の操作を行う。**
3. **余りが0になるまで1と2の操作を繰り返す。**
4. **余りが0になったときの、割る数（0ではない方）が最大公約数となる。**

**コードの処理内容： 例を用いた説明**

例えば、`A = 24`、`B = 18` の場合を考えます。

1. **`main()` 関数:**
   - `input().split()` によって、ユーザーは "24 18" のように2つの数字をスペースで区切って入力します。
   - `map(int, ...)` は、入力された文字列を整数に変換し、`A` には 24、`B` には 18 がそれぞれ代入されます。
   - `gcd(24, 18)` を呼び出して、最大公約数を計算します。

2. **`gcd(24, 18)` 関数:**
   - **1回目:**
     - `b` (18) は 0 ではないため、`while` ループに入ります。
     - `a` (24) を `b` (18) で割った余り (`24 % 18`) は 6 となります。
     - `a` には `b` の値 (18) が、`b` には余りの値 (6) が代入されます。
   - **2回目:**
     - `b` (6) はまだ 0 ではありません。
     - `a` (18) を `b` (6) で割った余り (`18 % 6`) は 0 となります。
     - `a` には `b` の値 (6) が、`b` には余りの値 (0) が代入されます。
   - **ループ終了:**
     - `b` が 0 になったため、`while` ループが終了します。
   - `a` の値 (6) が `return` されます。

3. **`main()` 関数 (続き):**
   - `gcd(24, 18)` の戻り値 (6) が `print()` によって画面に表示されます。

**まとめ**

このコードは、ユークリッドの互除法という効率的なアルゴリズムを使って、2つの整数の最大公約数を計算します。ユークリッドの互除法は、再帰的に余りを計算することで、最大公約数を高速に見つけることができます。

---
# 016

## 最大公約数を求めるプログラム解説

このプログラムは、複数の整数の最大公約数 (GCD: Greatest Common Divisor) を求めるものです。

### 1. ユークリッドの互除法

最大公約数を求めるために、 **ユークリッドの互除法** という方法を使っています。 これは、2つの数 `a` と `b` (ただし `a > b`) について、

-  `a` を `b` で割った余りを `r` とすると (`a % b = r`)、
-  `a` と `b` の最大公約数は、`b` と `r` の最大公約数と同じになる

という性質を利用した方法です。 これを繰り返していくと、最終的に余りが `0` になり、その時の `b` の値が最大公約数になります。

例えば、12 と 18 の最大公約数を求める場合:

1. 18 ÷ 12 = 1 余り 6
2. 12 ÷ 6 = 2 余り 0

よって、12 と 18 の最大公約数は 6 となります。

### 2. コードの解説

#### 2-1. `gcd(a, b)` 関数:

- この関数は、ユークリッドの互除法を使って、2つの整数 `a` と `b` の最大公約数を計算します。
- `while b != 0:` は、`b` が 0 になるまでループを繰り返すことを意味します。
- ループの中では、`a` と `b` の値を更新しています。 `a` には `b` の値を、`b` には `a` を `b` で割った余り (`a % b`) を代入しています。
- 最終的に `b` が 0 になった時の `a` の値が、`a` と `b` の最大公約数なので、`return a` でその値を返します。

#### 2-2. `gcd_list(A)` 関数:

- この関数は、整数のリスト `A` を受け取り、そのリスト内の全ての要素の最大公約数を計算します。
- `res = A[0]` で、リストの最初の要素を初期値として `res` に代入します。
- `for i in A[1:]:` で、リストの2番目の要素から順番に `i` に代入してループを回します。
- ループの中では、`res` と `i` の最大公約数を `gcd(res, i)` で計算し、その結果を再び `res` に代入します。
- これを繰り返すことで、`res` にはリスト `A` の全ての要素の最大公約数が格納されていきます。
- 最終的に、`return res` で計算結果を返します。

#### 2-3. `main()` 関数:

- プログラムのメイン処理を行います。
- `N = int(input())` で、整数の個数 `N` を入力として受け取ります。
- `A = list(map(int, input().split()))` で、`N` 個の整数をスペース区切りで入力として受け取り、リスト `A` に格納します。
- `print(gcd_list(A))` で、`gcd_list(A)` 関数を呼び出して最大公約数を計算し、その結果を出力します。

#### 2-4. `if __name__ == "__main__":` :

- このプログラムが直接実行された場合にのみ、`main()` 関数を実行します。

### 3. 実行例

例えば、入力として以下のようなデータが与えられたとします。

```
3  # 整数の個数 N
12 18 24 # 整数のリスト A
```

1. `main()` 関数内で、`N` には `3` が、`A` には `[12, 18, 24]` が格納されます。
2. `gcd_list([12, 18, 24])` が実行されます。
    - `res` に `12` が代入されます。
    - 1回目のループ: `gcd(12, 18) = 6` なので、`res` に `6` が代入されます。
    - 2回目のループ: `gcd(6, 24) = 6` なので、`res` に `6` が代入されます。
3. `gcd_list([12, 18, 24])` は `6` を返します。
4. `main()` 関数内の `print()` によって `6` が出力されます。

このように、このプログラムはユークリッドの互除法を用いて、複数の整数の最大公約数を効率的に計算することができます.

---
# 017

## ユークリッドの互除法で最小公倍数が求められる理由

ユークリッドの互除法は、一見最大公約数を求めるためのアルゴリズムですが、なぜ最小公倍数の計算にも使えるのでしょうか？その理由を詳しく解説します。

### 最大公約数と最小公倍数の関係

**最大公約数 (GCD)** と **最小公倍数 (LCM)** の間には、以下の関係が成り立ちます。

- **2 つの自然数 a, b の積** = **a, b の最大公約数** × **a, b の最小公倍数**

つまり、

```
a × b = GCD(a, b) × LCM(a, b)
```

が成り立ちます。

### ユークリッドの互除法と最小公倍数の関係

ユークリッドの互除法を用いて、2 つの数の最大公約数 GCD(a, b) を求めることができます。上記の式を変形すると、

```
LCM(a, b) = (a × b) / GCD(a, b)
```

となります。

つまり、**2 つの数の積を、ユークリッドの互除法で求めた最大公約数で割る**ことで、最小公倍数が求められるのです。

### なぜこの関係が成り立つのか？

この関係が成り立つ直感的な理由としては、以下のことが挙げられます。

- **最大公約数:** 2 つの数に共通する約数のうち、最大のものです。
- **最小公倍数:** 2 つの数を両方割り切ることができる最小の自然数です。

最大公約数は、2 つの数に共通する部分を表し、最小公倍数は、2 つの数を包含する部分を表します。この 2 つの概念は、ある意味で逆の関係にあります。

**具体例:**
2 つの数 12 と 18 を例に考えてみましょう。

- 12 = 2^2 × 3
- 18 = 2 × 3^2

- 最大公約数: 2 × 3 = 6
- 最小公倍数: 2^2 × 3^2 = 36

12 と 18 の積は、2^3 × 3^3 です。この積を最大公約数 6 で割ると、最小公倍数 36 が得られます。

### まとめ

ユークリッドの互除法で最大公約数を求めることで、最小公倍数も計算できるのは、最大公約数と最小公倍数の間の深い関係があるからです。この関係式は、数論において非常に重要な概念であり、様々な問題を解く際に役立ちます。

**ポイント:**

- ユークリッドの互除法は、最大公約数だけでなく、最小公倍数の計算にも応用できる。
- 最大公約数と最小公倍数は、ある意味で逆の関係にある。
- 2 つの数の積を最大公約数で割ると、最小公倍数が得られる。

**コードの解説:**
```python
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def lcm_list(A):
    res = A[0]
    for i in A[1:]:
        res = lcm(res, i)
    return res

def main():
    N = int(input())
    A = list(map(int, input().split()))
    print(lcm_list(A))

if __name__ == "__main__":
    main()
```

1. **`gcd(a, b)` 関数:**
   - 2つの整数 `a` と `b` の最大公約数 (GCD) を計算します。
   - ユークリッドの互除法という効率的なアルゴリズムを使用しています。
     - `b` が 0 になるまで、`(a, b)` を `(b, a % b)` で繰り返し置き換えます。
     - 最終的に `b` が 0 になったときの `a` が最大公約数です。

2. **`lcm(a, b)` 関数:**
   - 2つの整数 `a` と `b` の最小公倍数 (LCM) を計算します。
   - 最小公倍数は、2つの数の積を最大公約数で割ることによって求められます。
     - `return a * b // gcd(a, b)`

3. **`lcm_list(A)` 関数:**
   - 整数のリスト `A` を入力として受け取り、リスト内のすべての整数の最小公倍数を計算します。
   - 最初に、結果を格納する変数 `res` をリストの最初の要素 `A[0]` に初期化します。
   - 次に、リストの2番目の要素から最後の要素まで順番に処理します。
     - 各要素 `i` について、`res` と `i` の最小公倍数を計算し、その結果を `res` に格納します。
   - 最後に、計算された最小公倍数 `res` を返します。

4. **`main()` 関数:**
   - プログラムのメイン処理を行います。
   - まず、入力として整数 `N` を受け取ります。これは、リストの要素数を表します。
   - 次に、空白区切りで入力された `N` 個の整数を `map(int, input().split())` を使って整数に変換し、リスト `A` に格納します。
   - `lcm_list(A)` 関数を呼び出して、リスト `A` の最小公倍数を計算し、結果を出力します。

5. **`if __name__ == "__main__":`:**
   - この部分は、Pythonスクリプトが直接実行された場合にのみ `main()` 関数を呼び出すために使用されます。

**事例:**

入力として `[12, 18, 14]` が与えられた場合の処理内容をステップごとに説明します。

1. `main()` 関数で、`N = 3`, `A = [12, 18, 14]` となります。
2. `lcm_list([12, 18, 14])` が呼び出されます。
   - `res = 12` で初期化されます。
   - `i = 18` のとき:
     - `lcm(12, 18)` が呼び出され、`gcd(12, 18) = 6` なので、`lcm(12, 18) = 36` となります。
     - `res` が 36 に更新されます。
   - `i = 14` のとき:
     - `lcm(36, 14)` が呼び出され、`gcd(36, 14) = 2` なので、`lcm(36, 14) = 252` となります。
     - `res` が 252 に更新されます。
3. `lcm_list([12, 18, 14])` は 252 を返します。
4. `main()` 関数で、252 が出力されます。

したがって、`[12, 18, 14]` の最小公倍数は 252 となります。


---
# 018

このコードは、動的計画法を使って、商品の値段リスト `A` から、2つの商品の合計金額が500円になる組み合わせがいくつあるかを効率的に計算しています。

**コードの解説**

1. **`dp(A)` 関数:**
   - `dp = [0] * 401`: これは、金額を添字としたリスト `dp` を作成し、全ての要素を0で初期化しています。`dp[i]` は、商品の合計金額が `i` 円になる組み合わせの数を表します。
     - 例えば、`dp[100]` は、商品の合計金額が100円になる組み合わせの数、`dp[300]` は合計金額が300円になる組み合わせの数を表します。
     - リストのサイズは401としているのは、商品の最大金額が400円なので、組み合わせで実現できる最大の金額は800円となり、計算に必要な範囲をカバーするためです (今回は500円までで十分ですが)。
   - `count = 0`: これは、合計金額が500円になる組み合わせの数をカウントするための変数です。

   - `for price in A:`: 入力された商品の値段リスト `A` から、一つずつ `price` を取り出して処理を行います。
     - `if price < 500:`:  現在の商品の値段 `price` が500円未満の場合のみ、以下の処理を行います。500円以上の場合は組み合わせで500円を作ることはできないためです。
       - `count += dp[500 - price]`:  `dp[500 - price]` は、現在見ている商品と組み合わせると合計金額が500円になるような、**既に登場した商品の組み合わせの数** を表しています。これを `count` に加算することで、500円になる組み合わせを効率的に数えています。

     - `dp[price] += 1`:  現在の商品の値段 `price` が登場した回数を記録します。これは、以降の商品の処理で、`price` と組み合わせられる可能性があるためです。

   - `return count`:  最後に、合計金額が500円になる組み合わせの数 `count` を返します。

2. **`main()` 関数:**
   - `_ = input()`:  商品の個数を受け取りますが、このコードでは使用しないので、変数には格納せずに読み飛ばしています。
   - `A = map(int, input().split())`:  商品の値段リスト `A` を受け取ります。
   - `print(dp(A))`:  `dp(A)` 関数を呼び出して計算結果を表示します。

**事例を使った処理内容の説明**

例えば、入力例として `A = [100, 300, 400, 400, 200]` が与えられたとします。

1. `price = 100` のとき:
   - `count += dp[400]` (現時点では `dp[400] = 0`)
   - `dp[100] += 1` (`dp[100]` は 1 になります)

2. `price = 300` のとき:
   - `count += dp[200]` (現時点では `dp[200] = 0`)
   - `dp[300] += 1` (`dp[300]` は 1 になります)

3. `price = 400` のとき:
   - `count += dp[100]` (`dp[100]` は 1 なので、`count` が 1 になります)
   - `dp[400] += 1` (`dp[400]` は 1 になります)

4. `price = 400` のとき:
   - `count += dp[100]` (`dp[100]` は 1 なので、`count` が 2 になります)
   - `dp[400] += 1` (`dp[400]` は 2 になります)

5. `price = 200` のとき:
   - `count += dp[300]` (`dp[300]` は 1 なので、`count` が 3 になります)
   - `dp[200] += 1` (`dp[200]` は 1 になります)

最終的に `count` は 3 となり、これが合計金額が500円になる組み合わせの数となります。

このように、このコードは動的計画法を用いることで、効率的に組み合わせの数を計算しています。

<br>
<br>

---
# 019

## カードの色合わせゲーム：Pythonで組み合わせをマスターしよう！

このプログラムは、たくさんのカードの中から同じ色のカードを2枚選ぶ組み合わせが何通りあるかを計算するプログラムです。

例えば、赤、青、黄色のカードがそれぞれ5枚ずつあるとします。この中から同じ色のカードを2枚選ぶ方法は、
* 赤2枚を選ぶ
* 青2枚を選ぶ
* 黄2枚を選ぶ

の3通りの選び方が考えられます。
それぞれ何通りあるかを計算し、最後に合計を計算することで、すべての組み合わせを求めることができます。

### ステップ1： 各色のカードの枚数を数えよう！

まず、それぞれの色のカードが何枚あるかを数える必要があります。 `count_pairs` 関数の中の1行目がその役割を担っています。

```python
cnt = [A.count(color) for color in (1, 2, 3)]
```

#### コードの解説

* `A` は、カードの色の一覧が入っているリストです。例えば、 `[1, 2, 3, 1, 2]` のように、数字で色が表現されています。
* `(1, 2, 3)` は、それぞれ赤、黄色、青色のカードを表しています。
* `for color in (1, 2, 3)` は、「1, 2, 3 を順番に color に代入して、その度に中の処理を実行する」という意味です。
* `A.count(color)` は、リスト `A` の中に `color` がいくつあるかを数えます。例えば、`A = [1, 2, 3, 1, 2]` で `color = 1` のとき、`A.count(1)` は `2` になります。
* `[ ... for ... in ... ]` は、リスト内包表記と呼ばれるもので、リストを生成するための簡潔な記述方法です。この場合、 `(1, 2, 3)` の各色について `A.count(color)` を計算した結果をリストにして `cnt` に代入します。

#### 実行例

例えば、 `A = [1, 2, 3, 1, 2]` の場合、 `cnt = [2, 2, 1]` となります。これは、赤色のカードが2枚、黄色のカードが2枚、青色のカードが1枚あることを意味します。

### ステップ2： 組み合わせの計算

各色のカードの枚数がわかったら、次は同じ色のカードを2枚選ぶ組み合わせの数を計算します。

```python
return sum(c * (c-1) // 2 for c in cnt)
```

#### コードの解説

* `for c in cnt` は、「`cnt` の要素を順番に `c` に代入して、その度に中の処理を実行する」という意味です。
* `c * (c-1) // 2` は、`c` 枚のカードから2枚を選ぶ組み合わせの数を計算する式です。
    * 例えば、赤色のカードが3枚ある場合 (`c = 3`)、 3枚から2枚を選ぶ組み合わせは 3 * (3-1) // 2 = 3 通りとなります。
    * `//` は、割り算の結果の整数部分のみを求める演算子です。
* `sum(...)` は、`(...)` 内のリストの要素をすべて足し合わせた結果を返します。

#### 実行例

`cnt = [2, 2, 1]` の場合を考えます。

* `c = 2` のとき、 `c * (c-1) // 2 = 1`
* `c = 2` のとき、 `c * (c-1) // 2 = 1`
* `c = 1` のとき、 `c * (c-1) // 2 = 0`

これらの合計を計算すると、 `1 + 1 + 0 = 2` となり、これが最終的な答えとなります。

### ステップ3： プログラムの実行

`main` 関数は、プログラム全体の処理の流れを制御する役割を担っています。

```python
def main():
    _ = input()  # 入力を受け取るが、使用しない
    A = list(map(int, input().split()))  # カードの色情報を受け取る
    print(count_pairs(A))  # 結果を出力
```

#### コードの解説

* `_ = input()` は、入力を受け取ることを示していますが、 `_` は使用しない変数を意味しており、実際には入力値は無視されます。
* `A = list(map(int, input().split()))` は、カードの色情報を受け取る部分です。
    * `input()` でユーザーからの入力を文字列として受け取ります。
    * `split()` で、スペース区切りで文字列を分割し、リストにします。
    * `map(int, ...)` で、分割されたリストの各要素を整数に変換します。
    * 最終的に、変換された整数のリストが `A` に代入されます。
* `print(count_pairs(A))` は、 `count_pairs` 関数を使って組み合わせの数を計算し、その結果を表示します。

#### 実行例

例えば、入力が

```
5
1 2 3 1 2
```

だった場合、

* `_ = input()` で最初の `5` は無視されます。
* `A = list(map(int, input().split()))` で `[1, 2, 3, 1, 2]` が `A` に代入されます。
* `count_pairs(A)` を実行すると `2` が返されます。
* 最後に `2` が画面に出力されます。

### まとめ

このプログラムは、リスト処理、組み合わせの計算、関数定義など、Pythonの基礎的な要素を多く含んでいます。
それぞれのコードがどのような処理を行い、どのように連携しているかを理解することで、Pythonプログラミングの理解を深めることができます。

<br>

### [補足] 「c * (c-1) // 2」について
`sum(c * (c-1) // 2 for c in cnt)` は、リスト `cnt` の各要素 `c` について、`c * (c - 1) // 2` を計算し、その合計を求める式です。  この式は、数学的には **組み合わせ** の概念を用いて理解することができます。

**組み合わせとは？**

異なる n 個のものの中から、順番を考えずに k 個を選ぶ場合の数を **nCk** と表し、「n 個から k 個を選ぶ組み合わせ」と言います。
例えば、5色のボール (赤、青、黄、緑、黒) から2色を選ぶ組み合わせは、以下の 10 通りあります。

* 赤、青
* 赤、黄
* 赤、緑
* 赤、黒
* 青、黄
* 青、緑
* 青、黒
* 黄、緑
* 黄、黒
* 緑、黒

この 10 という数字は、5C2 を計算した結果と同じです。

**組み合わせの計算式**

nCk は以下の式で計算できます。

```
nCk = n! / (k! * (n-k)!)
```

ここで、`!` は階乗を表し、例えば `5! = 5 * 4 * 3 * 2 * 1 = 120` となります。

**コードと組み合わせの関係**

`c * (c - 1) // 2` は、`c` 個のものから 2 個を選ぶ組み合わせの数、つまり `c`C2 を計算しています。
上記の計算式に `n = c`, `k = 2` を代入してみましょう。

```
c * (c - 1) // 2 = c! / (2! * (c - 2)!)
                 = c * (c - 1) * (c - 2) * ... * 2 * 1 / (2 * 1 * (c - 2) * ... * 2 * 1)
                 = c * (c - 1) / 2
```

このように、式変形によってコード中の式と同じ形になることが分かります。

**具体的な例**

`cnt = [2, 2, 1]` の場合を例に考えてみましょう。

* `c = 2` のとき： 赤色のカードが2枚ある状態です。2枚から2枚を選ぶ組み合わせは 1 通りです。  (`2C2 = 1`)
* `c = 2` のとき： 黄色のカードが2枚ある状態です。2枚から2枚を選ぶ組み合わせは 1 通りです。 (`2C2 = 1`)
* `c = 1` のとき： 青色のカードが1枚ある状態です。1枚から2枚を選ぶことはできないため、組み合わせは 0 通りです。 (`1C2 = 0`)

これらの組み合わせの数を合計することで、同じ色のカードを2枚選ぶ組み合わせの総数が 2 通りであることが分かります。

**まとめ**

`sum(c * (c-1) // 2 for c in cnt)` は、リスト `cnt` に格納された各色のカードの枚数をもとに、同じ色のカードを2枚選ぶ組み合わせの総数を計算しています。この計算は、数学的には組み合わせの概念を用いて理解することができます。

<br>
<br>

---
# 020

### コード解説

このコードは、**動的計画法 (Dynamic Programming, DP)** を使って、与えられたカードリストから「5枚選んだときの合計がちょうど1000になる方法の数」を求めるものです。

動的計画法は、大きな問題を小さな問題に分割して解決し、その結果を再利用することで効率よく計算を進める手法です。

```python
def count_combination(A):
    dp = [[0] * 1001 for _ in range(6)]
    dp[0][0] = 1

    for num in A:
        for i in range(4, -1, -1):
            for j in range(1000 - num +1):
                dp[i+1][j+num] += dp[i][j]
    return dp[5][1000]

def main():
    _ = input()
    A = list(map(int, input().split()))
    print(count_combination(A))

if __name__ == "__main__":
    main()
```

---

### コード全体の流れ

1. **入力を受け取る**
   カードのリスト `A` を受け取り、その中から5枚選ぶ組み合わせについて計算を行います。

2. **DPテーブルの初期化**
   `dp` という2次元リストを用いて、「何枚選んだか」「その時の合計がいくらか」の状態を管理します。

3. **各カードを処理**
   カード1枚ずつについて、「そのカードを選ぶ場合」と「選ばない場合」の状態を更新します。

4. **最終結果を返す**
   「5枚選んで合計が1000になる方法の数」を返します。

---

### 各部分の詳細解説

#### 1. **入力を受け取る**
```python
def main():
    _ = input()  # Nは使わないので無視
    A = list(map(int, input().split()))  # カードの数値リストを受け取る
    print(count_combination(A))
```
**事例**:
- 入力:
  ```
  5
  100 150 200 250 300
  ```
- `A` は `[100, 150, 200, 250, 300]` となります。

---

#### 2. **DPテーブルの初期化**
```python
dp = [[0]*1001 for _ in range(6)]  # dp[i][j] を管理
dp[0][0] = 1  # 初期状態：0枚選んで合計が0になる方法は1通り
```
- **DPテーブルの意味**:
  `dp[i][j]` は、「**カードをちょうど `i` 枚選んで、合計が `j` になる方法の数**」を表します。

- **サイズ**:
  - 行数は6 (0〜5枚選ぶ場合を管理)
  - 列数は1001 (合計が0〜1000になる場合を管理)

- **初期状態**:
  - 0枚選んで合計が0になる方法は、何も選ばない1通りだけなので、`dp[0][0] = 1` とします。

---

#### 3. **カードを1枚ずつ処理してDPを更新**
```python
for num in A:  # 各カードについてループ
    for i in range(4, -1, -1):  # 選ぶ枚数を逆順に更新
        for j in range(1000 - num + 1):  # 合計値を更新
            dp[i+1][j+num] += dp[i][j]  # 状態遷移
```

##### **例を用いて説明**
カードのリスト: `[100, 150, 200]` で考えます。

---

1. **カード100を処理**
   - 現在のカードが `100`。
   - **逆順で更新する理由**:
     - `dp[i+1]` を更新する際に、`dp[i]` の情報が上書きされないようにするためです。
   - **遷移の例**:
     - 0枚選んで合計が0 (`dp[0][0] = 1`) だった場合、1枚選んで合計が100 (`dp[1][100]`) に遷移する。
       - `dp[1][100] += dp[0][0]` → `dp[1][100] = 1`

---

2. **カード150を処理**
   - 現在のカードが `150`。
   - 遷移の例:
     - 1枚選んで合計が100 (`dp[1][100] = 1`) だった場合、2枚選んで合計が250 (`dp[2][250]`) に遷移する。
       - `dp[2][250] += dp[1][100]` → `dp[2][250] = 1`

---

3. **カード200を処理**
   - 現在のカードが `200`。
   - 遷移の例:
     - 2枚選んで合計が250 (`dp[2][250] = 1`) だった場合、3枚選んで合計が450 (`dp[3][450]`) に遷移する。
       - `dp[3][450] += dp[2][250]` → `dp[3][450] = 1`

---

#### 4. **結果を返す**
```python
return dp[5][1000]
```
- 「5枚選んで合計が1000になる方法の数」を返します。

---

### 数学的説明
このアルゴリズムは、以下のように考えます：

1. \( dp[i][j] \): 「**現在までに \( i \) 枚選んで合計 \( j \) にする方法の数**」
2. 状態遷移:
   - 現在のカード \( num \) を選ぶ場合、
     \( dp[i+1][j+num] += dp[i][j] \) となります。
   - \( num \) を選ばない場合はそのまま。

この遷移を全てのカードについて行うことで、効率的に答えを求められます。

---

### 入力例を通した処理過程
#### 入力:
```
5
100 150 200 250 300
```

#### 処理:
1. 初期状態:
   ```
   dp[0][0] = 1
   ```

2. カード100を処理:
   ```
   dp[1][100] = 1
   ```

3. カード150を処理:
   ```
   dp[2][250] = 1
   ```

4. カード200を処理:
   ```
   dp[3][450] = 1
   ```

5. カード250を処理:
   ```
   dp[4][700] = 1
   ```

6. カード300を処理:
   ```
   dp[5][1000] = 1
   ```

#### 出力:
```
1
```

---

### この解法のポイント
- **高速**: 計算量は \( O(N $\times$ 1000) \)。
- **初心者でも理解可能**: 状態遷移を1枚ずつカードを加える形で説明しました。


## [補足] ループ処理部分の詳細説明

ここでは、プログラムの核心部分であるトリプルループの動作を詳しく説明します。

```python
for num in A:
    for k in range(4, -1, -1):
        for s in range(1000 - num + 1):
            dp[k + 1][s + num] += dp[k][s]
```

## ループの意味

1. `for num in A:`
   - 各カードの値（`num`）について処理を行います。

2. `for k in range(4, -1, -1):`
   - `k`は現在使用しているカードの枚数を表します。
   - 4から0まで逆順に処理します。これは新しいカードを追加する際、既存の組み合わせに影響を与えないようにするためです。

3. `for s in range(1000 - num + 1):`
   - `s`は現在の合計を表します。
   - 新しいカード`num`を追加しても1000を超えない範囲で処理します。

4. `dp[k + 1][s + num] += dp[k][s]`
   - `k`枚のカードで合計`s`を作る方法の数を、`k+1`枚のカードで合計`s+num`を作る方法の数に加算します。

## 具体例での説明

入力例：`A = [100, 150, 200, 250, 300]`

最初の2枚のカード（100と150）の処理を詳細に見ていきます。

### カード100の処理

```python
num = 100
for k in range(4, -1, -1):
    for s in range(1000 - 100 + 1):  # 0から900まで
        dp[k + 1][s + 100] += dp[k][s]
```

初期状態：`dp[0][0] = 1`、他はすべて0

1. `k = 4`のとき：何も更新されません（`dp[4][s]`がすべて0のため）
2. `k = 3`のとき：何も更新されません
3. `k = 2`のとき：何も更新されません
4. `k = 1`のとき：何も更新されません
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][100] += dp[0][0]`
     結果：`dp[1][100] = 1`（1枚で100を作る方法が1通り）

### カード150の処理

```python
num = 150
for k in range(4, -1, -1):
    for s in range(1000 - 150 + 1):  # 0から850まで
        dp[k + 1][s + 150] += dp[k][s]
```

1. `k = 4`のとき：何も更新されません
2. `k = 3`のとき：何も更新されません
3. `k = 2`のとき：何も更新されません
4. `k = 1`のとき：
   - `s = 100`の場合：`dp[2][250] += dp[1][100]`
     結果：`dp[2][250] = 1`（2枚で250を作る方法が1通り、100+150）
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][150] += dp[0][0]`
     結果：`dp[1][150] = 1`（1枚で150を作る方法が1通り）

### カード200の処理

```python
num = 200
for k in range(4, -1, -1):
    for s in range(1000 - 200 + 1):  # 0から800まで
        dp[k + 1][s + 200] += dp[k][s]
```

処理前の状態：
- `dp[1][100] = 1`
- `dp[1][150] = 1`
- `dp[2][250] = 1`

1. `k = 4`のとき：何も更新されません
2. `k = 3`のとき：何も更新されません
3. `k = 2`のとき：
   - `s = 250`の場合：`dp[3][450] += dp[2][250]`
     結果：`dp[3][450] = 1`（3枚で450を作る方法が1通り、100+150+200）
4. `k = 1`のとき：
   - `s = 100`の場合：`dp[2][300] += dp[1][100]`
     結果：`dp[2][300] = 1`（2枚で300を作る方法が1通り、100+200）
   - `s = 150`の場合：`dp[2][350] += dp[1][150]`
     結果：`dp[2][350] = 1`（2枚で350を作る方法が1通り、150+200）
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][200] += dp[0][0]`
     結果：`dp[1][200] = 1`（1枚で200を作る方法が1通り）

### カード250の処理

```python
num = 250
for k in range(4, -1, -1):
    for s in range(1000 - 250 + 1):  # 0から750まで
        dp[k + 1][s + 250] += dp[k][s]
```

1. `k = 4`のとき：何も更新されません
2. `k = 3`のとき：
   - `s = 450`の場合：`dp[4][700] += dp[3][450]`
     結果：`dp[4][700] = 1`（4枚で700を作る方法が1通り、100+150+200+250）
3. `k = 2`のとき：
   - `s = 300`の場合：`dp[3][550] += dp[2][300]`
     結果：`dp[3][550] = 1`（3枚で550を作る方法が1通り、100+200+250）
   - `s = 350`の場合：`dp[3][600] += dp[2][350]`
     結果：`dp[3][600] = 1`（3枚で600を作る方法が1通り、150+200+250）
4. `k = 1`のとき：
   - `s = 100`の場合：`dp[2][350] += dp[1][100]`
     結果：`dp[2][350] = 2`（2枚で350を作る方法が2通り、150+200と100+250）
   - `s = 150`の場合：`dp[2][400] += dp[1][150]`
     結果：`dp[2][400] = 1`（2枚で400を作る方法が1通り、150+250）
   - `s = 200`の場合：`dp[2][450] += dp[1][200]`
     結果：`dp[2][450] = 1`（2枚で450を作る方法が1通り、200+250）
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][250] += dp[0][0]`
     結果：`dp[1][250] = 1`（1枚で250を作る方法が1通り）

### カード300の処理

```python
num = 300
for k in range(4, -1, -1):
    for s in range(1000 - 300 + 1):  # 0から700まで
        dp[k + 1][s + 300] += dp[k][s]
```

1. `k = 4`のとき：
   - `s = 700`の場合：`dp[5][1000] += dp[4][700]`
     結果：`dp[5][1000] = 1`（5枚で1000を作る方法が1通り、100+150+200+250+300）
2. `k = 3`のとき：
   - `s = 550`の場合：`dp[4][850] += dp[3][550]`
     結果：`dp[4][850] = 1`（4枚で850を作る方法が1通り、100+200+250+300）
   - `s = 600`の場合：`dp[4][900] += dp[3][600]`
     結果：`dp[4][900] = 1`（4枚で900を作る方法が1通り、150+200+250+300）
3. `k = 2`, `k = 1`, `k = 0`のときの処理も同様に行われます...

### 最終結果

すべてのカードの処理が終わった後、`dp[5][1000] = 1` となります。これは、5枚のカードを使って合計1000を作る方法が1通りあることを意味します。

この例では、唯一の組み合わせは 100 + 150 + 200 + 250 + 300 = 1000 となります。

このプロセスを通じて、プログラムは効率的にすべての可能な組み合わせを探索し、条件を満たす組み合わせの数を数えています。各ステップで `dp` 配列を更新することで、以前の計算結果を再利用し、計算量を大幅に削減しています。

<br>
<br>

---
# 021

このコードは、組み合わせ $_nC_r$ を計算するための関数を実装しています。

### `comb(n, r)` 関数の解説

#### 1. `r = min(r, n - r)`
この行は、計算を効率化するための工夫です。組み合わせ $_nC_r$ の式は対称性を持っており、次のように成り立ちます：

$${ {}_nC_{r} = {}_nC_{n - r} }$$

したがって、 $r$ を $\min(r, n - r)$ とすることで、計算する項数を減らすことができます。<br>
たとえば、 $n = 6, r = 4$ の場合、 $ _6C_4 $ = $ _6C_2 $ なので、2つ選ぶ場合の計算だけで済みます。<br>
これにより、より少ない回数で計算できます。

#### 2. `res = 1`
ここで変数 `res` は最終的な結果を保存する変数です。最初に 1 で初期化し、ループで掛け算を繰り返していきます。

#### 3. `for i in range(r):`
このループは、組み合わせの公式に基づいて計算を行います。例えば、\( $_nC_r$\) は次の式で計算できます：
<br>&nbsp;&nbsp;&nbsp;&nbsp;
$_nC_r = \dfrac{n \times (n-1) \times \dots \times (n-r+1)}{r \times (r-1) \times \dots \times 1}$

このループでは、分子部分 \( $n \times (n-1) \times \dots$ \) を `res` に掛け算しながら、同時に分母部分 \( $r \times (r-1) \times \dots$ \) で割り算していきます。<br>
これにより、大きな数の階乗を計算することなく、計算が完了します。

#### 4. `res = res * (n - i) // (i + 1)`
この式は、分子と分母の掛け算・割り算を同時に行っています。
- `n - i` は分子の \( $n, n-1, n-2, \dots$ \) に対応しています。
- `i + 1` は分母の \( $1, 2, 3, \dots$ \) に対応しています。

ループの各ステップで `res` に値を計算していきます。

#### 5. `return res`
最終的に計算された組み合わせの結果を返します。

### `main()` 関数の解説

1. `n, r = map(int, input().split())`:
   ユーザーから入力を受け取り、`n` と `r` に整数として代入します。入力は空白区切りで与えられます。

2. `print(comb(n, r))`:
   `comb(n, r)` 関数を呼び出して結果を計算し、`print()` 関数で結果を出力します。

### `if __name__ == "__main__":`

これは、プログラムが直接実行された場合にのみ `main()` 関数が呼び出されるようにするための構造です。<br>
通常、スクリプトをモジュールとしてインポートされた場合、`main()` 関数は実行されません。

---

### 処理の内容を事例で説明

#### 事例: \( $n = 6, r = 2$ \)

1. **`comb(n=6, r=2)` を呼び出す**
   - 最初に `r = min(2, 6-2) = 2` です。この時、\( $r$ \) は変わらず 2 のままです。
   - `res = 1` で初期化します。

2. **ループの1回目 (i=0)**
   - `res = res * (6 - 0) // (0 + 1) = 1 * 6 // 1 = 6`
   - `res` の値は 6 になります。

3. **ループの2回目 (i=1)**
   - `res = res * (6 - 1) // (1 + 1) = 6 * 5 // 2 = 30 // 2 = 15`
   - `res` の値は 15 になります。

4. **ループ終了**
   - `r = 2` のため、2回のループが終了し、`res` は 15 です。

5. **結果を返す**
   - `comb(6, 2)` の結果は 15 となり、最終的に `print()` でこの値が出力されます。

---

### 出力例
入力:
```
6 2
```

出力:
```
15
```

このコードは、計算を効率化しつつシンプルに組み合わせを求めるためのものです。

<br>
<br>

---
# 022

```python
def count_pairs(A):
    count = {}
    res = 0
    for a in A:
        if 100000 - a in count:
            res += count[100000 - a]

        if a in count:
            count[a] += 1
        else:
            count[a] = 1
    return res

def main():
    N = int(input())
    A = map(int, input().split())
    print(count_pairs(A))

if __name__ == "__main__":
    main()
```

以下は、`count_pairs` 関数とその動作についての詳細な説明です。

### コードの解説

1. **`count_pairs(A)` 関数の目的**:
   - 与えられたカードのリスト `A` から、和が `100000` になるペアの組み合わせの数をカウントする関数です。

2. **変数の初期化**:
   - `count = {}`: カードの値ごとに、これまで出現した回数を記録する辞書です。キーはカードの値、値はそのカードの出現回数です。
   - `res = 0`: 結果として、和が `100000` になるペアの組み合わせの数を保持します。

3. **メインループ**:
   - `for a in A`: リスト `A` 内のカードの値を一つずつ取り出して処理します。

   - **ペアをチェック**:
     - `if 100000 - a in count`: 現在のカード `a` に対して、和が `100000` になるカードが `count` 辞書に既に存在しているか確認します。もし存在すれば、そのカードとペアを組むことができるので、その出現回数分だけ結果 `res` に加算します。

   - **出現回数を更新**:
     - `if a in count`: すでにカード `a` が辞書に存在していれば、その出現回数を1増やします。
     - `else: count[a] = 1`: もしカード `a` が初めて出現した場合、辞書に追加し、その出現回数を1とします。

4. **結果の返却**:
   - ループを通じて見つけたペアの組み合わせの数を `res` として返します。

### 入力と処理の流れの例

**例：**
入力：`N = 6`
カードのリスト `A = [40000, 50000, 20000, 80000, 50000, 30000]`

1. 初期状態：
   - `count = {}` （空の辞書）
   - `res = 0` （ペアの数）

2. 各カードに対する処理：

   - **1枚目 (a = 40000)**:
     - `100000 - 40000 = 60000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1}` として、40000 の出現回数を 1 に設定します。

   - **2枚目 (a = 50000)**:
     - `100000 - 50000 = 50000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1, 50000: 1}` として、50000 の出現回数を 1 に設定します。

   - **3枚目 (a = 20000)**:
     - `100000 - 20000 = 80000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1, 50000: 1, 20000: 1}` として、20000 の出現回数を 1 に設定します。

   - **4枚目 (a = 80000)**:
     - `100000 - 80000 = 20000` が `count` に存在するため、`res` に `count[20000]` の値 1 を加算します。
     - `res = 1`
     - `count = {40000: 1, 50000: 1, 20000: 1, 80000: 1}` として、80000 の出現回数を 1 に設定します。

   - **5枚目 (a = 50000)**:
     - `100000 - 50000 = 50000` が `count` に存在するため、`res` に `count[50000]` の値 1 を加算します。
     - `res = 2`
     - `count = {40000: 1, 50000: 2, 20000: 1, 80000: 1}` として、50000 の出現回数を 2 に設定します。

   - **6枚目 (a = 30000)**:
     - `100000 - 30000 = 70000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1, 50000: 2, 20000: 1, 80000: 1, 30000: 1}` として、30000 の出現回数を 1 に設定します。

  - [参考]
    ```bash
    ------------------------------------------------------------ a : 40000
    100000-a : 60000
    res : 0
    cnt : {40000: 1}
    ------------------------------------------------------------ a : 50000
    100000-a : 50000
    res : 0
    cnt : {40000: 1, 50000: 1}
    ------------------------------------------------------------ a : 20000
    100000-a : 80000
    res : 0
    cnt : {40000: 1, 50000: 1, 20000: 1}
    ------------------------------------------------------------ a : 80000
    100000-a : 20000
    res : 1
    cnt : {40000: 1, 50000: 1, 20000: 1, 80000: 1}
    ------------------------------------------------------------ a : 50000
    100000-a : 50000
    res : 2
    cnt : {40000: 1, 50000: 2, 20000: 1, 80000: 1}
    ------------------------------------------------------------ a : 30000
    100000-a : 70000
    res : 2
    cnt : {40000: 1, 50000: 2, 20000: 1, 80000: 1, 30000: 1}
    ```

3. **最終結果**:
   - `res = 2`（和が `100000` となるペアが 2 組存在）

### 処理内容のまとめ
このプログラムは、リスト `A` を一度だけループすることで、和が `100000` になるペアの数を効率的に計算します。`dict` を使って既に出現したカードの値を管理するため、ペアの検索とカウントを高速に行えます。全体の計算量は **O(N)** で、カードが最大 20 万枚あった場合でも非常に高速に動作します。

<br>
<br>

---
# 026

```python
def calc(n):
    res = 0
    for i in range(1, n+1):
        res += n/i
        print(res)
    return res

def main():
    N = int(input())
    print(calc(N))

if __name__ == "__main__":
    main()
```

例として、N = 5 の場合を考えてみます：

```python
def calc(n):
    res = 0
    for i in range(n, 0, -1):
        res += n/i
    return res
```

N=5 の場合、以下のように計算が進みます：

1. i = 5 のとき（最初のコイン）：
   res += 5/5 = 1
   説明：最初のコインを得る確率は 5/5 = 1（100%）です。期待コストは 1 ドルです。

2. i = 4 のとき（2 番目のコイン）：
   res += 5/4 = 1.25
   説明：2 番目の新しいコインを得る確率は 4/5 です。期待コストは 5/4 = 1.25 ドルです。
   （平均して 1/(4/5) = 5/4 回の試行が必要）

3. i = 3 のとき（3 番目のコイン）：
   res += 5/3 ≈ 1.67
   説明：3 番目の新しいコインを得る確率は 3/5 です。期待コストは 5/3 ≈ 1.67 ドルです。
   （平均して 1/(3/5) = 5/3 回の試行が必要）

4. i = 2 のとき（4 番目のコイン）：
   res += 5/2 = 2.5
   説明：4 番目の新しいコインを得る確率は 2/5 です。期待コストは 5/2 = 2.5 ドルです。
   （平均して 1/(2/5) = 5/2 回の試行が必要）

5. i = 1 のとき（最後のコイン）：
   res += 5/1 = 5
   説明：最後のコインを得る確率は 1/5 です。期待コストは 5/1 = 5 ドルです。
   （平均して 1/(1/5) = 5 回の試行が必要）

最終的な res ≈ 11.42

この説明方法では、各ステップで新しいコインを得る確率が徐々に減少し、それに伴って期待コストが増加していく様子がよりわかりやすくなります。最初は簡単に新しいコインを得られますが、残りのコインが少なくなるにつれて、特定の新しいコインを得るのが難しくなっていきます。

この合計約 11.42 ドルが、5 種類全てのコインを集めるのに必要な総期待コストとなります。実際の試行では運によって変動しますが、長期的に見ればこの平均値に収束します。

<br>
<br>

---
# 027

### マージソートの基本的な考え方:

1. 大きな問題を小さな問題に分割する
2. 小さな問題を解決する
3. 小さな問題の解決結果を組み合わせて、大きな問題の解決につなげる

### 具体的な手順:

1. 配列を半分に分ける
2. 分けた半分をさらに半分に分ける（要素が 1 つになるまで繰り返す）
3. 1 つの要素になったら、それらをペアにしてマージ（結合）しながら並べ替える
4. マージを繰り返して、最終的に全体がソートされた 1 つの配列になる

この解説では、コードの動作を一つひとつ丁寧に説明し、実際の配列を使ってマージソートの処理の流れをステップバイステップで解説していきます。**初心者でも理解できるように**、なるべく具体的な数値例を交えて解説します。

### コードの全体の流れ
- このプログラムは、**マージソート**アルゴリズムを使って配列を昇順に並べ替えるためのものです。入力として与えられた数値のリストを再帰的に分割し、最終的にソート済みのリストとして結合する仕組みです。

### 1. `merge_sort` 関数の解説

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
```
- **役割**: この関数は入力された配列をソートするためのメイン部分です。マージソートは**分割統治法**と呼ばれる手法を使います。配列を小さく分割して、最終的にそれらをソートしながらマージします。
- **処理内容**: 最初に配列の長さをチェックします。もし配列が1個以下（要素が0個または1個）であれば、すでにソート済みなので、そのまま配列を返します。

#### 事例
入力配列 `[658, 299, 47, 507, 122]` では、長さが5なので、分割を続けます。

```python
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
```
- **処理内容**: 配列の中央（`mid`）を計算し、左側と右側に分割します。その後、それぞれの部分に対して再帰的に`merge_sort`を呼び出して、さらに細かく分割します。

#### 事例
配列 `[658, 299, 47, 507, 122]` では、`mid = 5 // 2 = 2` なので、次のように分割されます。
- 左側: `[658, 299]`
- 右側: `[47, 507, 122]`

この分割された配列についても再帰的に同様の処理を行います。

```python
    return merge(left, right)
```
- **処理内容**: 左右それぞれがソートされた後、`merge` 関数でマージして1つのソート済み配列を作ります。

### 2. `merge` 関数の解説

```python
def merge(left, right):
    res = []
    i = j = 0
```
- **役割**: `merge` 関数は、ソートされた2つの配列を一つにまとめる役割を担っています。2つのリスト `left` と `right` の要素を比較しながら、昇順に結合します。
- **処理内容**: `res` は結果としてソートされた配列を格納するリスト、`i` と `j` はそれぞれ `left` と `right` の現在のインデックスです。

```python
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            res.append(left[i])
            i += 1
        else:
            res.append(right[j])
            j += 1
```
- **処理内容**: `left` と `right` の要素を1つずつ比較し、値の小さい方を `res` に追加していきます。そして、比較に使ったインデックスを進めます。
  - `left[i]` と `right[j]` を比較し、**小さい方の値**を結果リストに追加します。

#### 事例
- `left = [299, 658]` と `right = [47, 122, 507]` が入力された場合、以下のように処理が進みます：
  1. `299` と `47` を比較 → `47` を `res` に追加 → `res = [47]`
  2. `299` と `122` を比較 → `122` を追加 → `res = [47, 122]`
  3. `299` と `507` を比較 → `299` を追加 → `res = [47, 122, 299]`
  4. `658` と `507` を比較 → `507` を追加 → `res = [47, 122, 299, 507]`

```python
    res.extend(left[i:])
    res.extend(right[j:])
```
- **処理内容**: `left` または `right` のどちらかのリストが先に全て処理される場合があるので、残った方のリストの要素を全て `res` に追加します。

上記の比較の後、`left` の `658` がまだ残っているので、`res = [47, 122, 299, 507, 658]` となります。

```python
    return res
```
- **処理内容**: 結果としてソートされた配列 `res` を返します。

### 3. `main` 関数の解説

```python
def main():
    _ = int(input())
    A = list(map(int, input().split()))
    print(*merge_sort(A))
```
- **役割**: `main` 関数は、プログラムのエントリーポイントです。まず、最初に入力を受け取り、与えられた配列をソートして結果を出力します。
- **処理内容**:
  - 最初に、配列の長さを読み取ります（`_` は使われないので無視しています）。
  - 次に、`input().split()` を使って入力された配列をリスト `A` に変換します。
  - `merge_sort(A)` で配列をソートし、`print` で結果を表示します。

#### 事例
入力が `5`、`658 299 47 507 122` の場合：
- 配列 `A = [658, 299, 47, 507, 122]` となり、この配列が `merge_sort` に渡されます。
- 結果は `[47, 122, 299, 507, 658]` となり、それが出力されます。

---

### [補足] 別事例
このコードは、マージソートというアルゴリズムを使って配列を昇順に並べ替えるプログラムです。マージソートは、配列を小さな部分に分割し、それらをソートしてからマージ（結合）していくことで、全体をソートする効率的なアルゴリズムです。「分割統治法」と呼ばれる考え方に基づいています。

**具体的な例で見てみましょう。**

入力例として `A = [3, 1, 2, 5, 4]` を使います。

1. **`merge_sort(A)` 関数の処理:**

   - `len(A)` が 1 より大きいので、`mid = len(A) // 2 = 2` となります。
   - 配列 `A` を `[3, 1, 2]` と `[5, 4]` に分割します。
   - それぞれを `merge_sort` で再帰的にソートします。

2. **`merge_sort([3, 1, 2])` の処理:**

   - `mid = 1` となり、`[3]` と `[1, 2]` に分割します。
   - `merge_sort([3])` は `[3]` を返します (長さが1なので)。
   - `merge_sort([1, 2])` は、さらに `[1]` と `[2]` に分割され、最終的に `merge([1], [2])` を実行し、`[1, 2]` を返します。
   - `merge([3], [1, 2])` が実行され、`[1, 2, 3]` を返します。

3. **`merge_sort([5, 4])` の処理:**

   - `mid = 1` となり、`[5]` と `[4]` に分割します。
   - `merge_sort([5])` は `[5]` を返します。
   - `merge_sort([4])` は `[4]` を返します。
   - `merge([5], [4])` が実行され、`[4, 5]` を返します。

4. **`merge([1, 2, 3], [4, 5])` の処理:**

   - `res = []` を初期化します。
   - `i = 0`, `j = 0` とします。
   - `left[i] (1) <= right[j] (4)` なので、`res.append(1)` を実行し、`i = 1` となります。 `res = [1]`
   - `left[i] (2) <= right[j] (4)` なので、`res.append(2)` を実行し、`i = 2` となります。 `res = [1, 2]`
   - `left[i] (3) <= right[j] (4)` なので、`res.append(3)` を実行し、`i = 3` となります。 `res = [1, 2, 3]`
   - `i == len(left)` なので、`res.extend(right[j:])` が実行され、`res = [1, 2, 3, 4, 5]` となります。

5. 最終的に、ソートされた配列 `[1, 2, 3, 4, 5]` が返されます。


**`merge(left, right)` 関数の詳細:**

この関数は、2つのソート済み配列 `left` と `right` を受け取り、それらをマージして1つのソート済み配列を返します。 `i` と `j` はそれぞれ `left` と `right` のインデックスを表し、小さい方から `res` に追加していきます。どちらかの配列の要素がなくなったら、残りの配列の要素を `res` に追加します。


**数学的な説明 (計算量):**

マージソートの計算量は `O(N log N)` です。これは、配列を半分に分割する操作を `log N` 回繰り返し、各分割レベルで `N` 回の比較を行うためです。 `N` が大きくなると、`N log N` は `N^2` よりもはるかに小さくなるため、マージソートは大きなデータセットに対して効率的です。


**まとめ:**

マージソートは、分割統治法を用いた効率的なソートアルゴリズムです。再帰的に配列を分割し、ソートされた部分配列をマージすることで、全体をソートします。計算量は `O(N log N)` で、大きなデータセットでも高速に動作します。


<br>
<br>

---
# 028

```python
def min_cost(N, h):
    dp = [0] * N
    dp[1] = abs(h[1] - h[0])
    for i in range(2, N):
        cost1 = dp[i-1] + abs(h[i] - h[i-1])
        cost2 = dp[i-2] + abs(h[i] - h[i-2])
        dp[i] = min(cost1, cost2)
    return dp[-1]

def main():
    N = int(input())
    h = list(map(int, input().split()))
    print(min_cost(N, h))

if __name__ == "__main__":
    main()
```

---

### **コードの目的**

このコードは、カエルが足場を移動する際に支払うコストの総和の最小値を計算するものです。カエルは足場1から足場Nまで移動し、各足場の高さが与えられています。カエルは足場から足場へジャンプする際にコストを支払います。そのコストはジャンプ元とジャンプ先の足場の高さの差の絶対値です。

---

### **コードの全体像**

1. **入力の受け取り**
   - 足場の数 `N` と各足場の高さのリスト `h` を受け取ります。

2. **初期化**
   - 動的計画法 (DP) を用いるためのリスト `dp` を初期化します。
   - `dp[i]` は足場1から足場`i`まで移動する際の最小コストを表します。

3. **DPリストの更新**
   - 足場2から足場Nまで、各足場に対して以下を行います。
     - 1つ前の足場からジャンプする場合のコストを計算します。
     - 2つ前の足場からジャンプする場合のコストを計算します。
     - 上記2つのコストのうち小さい方を選び、`dp[i]` に記録します。

4. **結果の出力**
   - 最後に `dp[N-1]` を返し、カエルが足場Nに到達する際の最小コストを出力します。

---

### **詳細な解説と事例**

**ここでは、入力例1を使用して、コードの動作を詳しく解説します。**

#### **入力例1**

```
4
10 30 40 20
```

- 足場の数 `N = 4`
- 各足場の高さ `h = [10, 30, 40, 20]`

#### **ステップ1: 初期化**

```python
dp = [0] * N
```

- `dp` リストを足場の数だけの要素を持つリストとして初期化します。
- 初期状態の `dp` は `[0, 0, 0, 0]` です。

```python
dp[1] = abs(h[1]-h[0])
```

- 足場1から足場2へのジャンプコストを計算し、 `dp[1]` に保存します。
- 計算: `abs(30 - 10) = 20`
- `dp` は `[0, 20, 0, 0]` となります。

**ここでの出力:**

```
dp : [0, 20, 0, 0]
```

#### **ステップ2: DPリストの更新**

ループを使って `i` を 2 から `N-1` (ここでは3) まで変化させます。

**---**

**ループ1回目 (`i = 2`)**

- 現在の足場は3 (`h[2] = 40`)

```python
c1 = dp[i-1] + abs(h[i]-h[i-1])
```

- 1つ前の足場からジャンプする場合のコスト `c1` を計算します。
- 計算:
  - `dp[1]` (足場2までの最小コスト) は 20
  - 高さの差: `abs(40 - 30) = 10`
  - `c1 = 20 + 10 = 30`

```python
c2 = dp[i-2] + abs(h[i]-h[i-2])
```

- 2つ前の足場からジャンプする場合のコスト `c2` を計算します。
- 計算:
  - `dp[0]` (足場1までの最小コスト) は 0
  - 高さの差: `abs(40 - 10) = 30`
  - `c2 = 0 + 30 = 30`

```python
dp[i] = min(c1, c2)
```

- `c1` と `c2` の小さい方を選び、 `dp[2]` に保存します。
- `dp[2] = min(30, 30) = 30`

**ここでの出力:**

```
==============================
h[0] : 10
h[1] : 30
h[2] : 40
c1 : 30
c2 : 30
dp : [0, 20, 30, 0]
```

**dpの状態は `[0, 20, 30, 0]` となりました。**

**---**

**ループ2回目 (`i = 3`)**

- 現在の足場は4 (`h[3] = 20`)

```python
c1 = dp[i-1] + abs(h[i]-h[i-1])
```

- 1つ前の足場からジャンプする場合のコスト `c1` を計算します。
- 計算:
  - `dp[2]` (足場3までの最小コスト) は 30
  - 高さの差: `abs(20 - 40) = 20`
  - `c1 = 30 + 20 = 50`

```python
c2 = dp[i-2] + abs(h[i]-h[i-2])
```

- 2つ前の足場からジャンプする場合のコスト `c2` を計算します。
- 計算:
  - `dp[1]` (足場2までの最小コスト) は 20
  - 高さの差: `abs(20 - 30) = 10`
  - `c2 = 20 + 10 = 30`

```python
dp[i] = min(c1, c2)
```

- `c1` と `c2` の小さい方を選び、 `dp[3]` に保存します。
- `dp[3] = min(50, 30) = 30`

**ここでの出力:**

```
==============================
h[1] : 30
h[2] : 40
h[3] : 20
c1 : 50
c2 : 30
dp : [0, 20, 30, 30]
```

**dpの状態は `[0, 20, 30, 30]` となりました。**

**---**

#### **ステップ3: 結果の出力**

```python
return dp[-1]
```

- `dp[-1]` は `dp[3]` （足場4までの最小コスト）を表します。
- 値は `30` です。

**最終的な出力:**

```
30
```

---

### **動的計画法の考え方**

- **状態**: `dp[i]` は足場1から足場`i+1`まで移動する際の最小コスト。
- **初期条件**:
  - `dp[0] = 0` （足場1のコストは0）
  - `dp[1] = abs(h[1] - h[0])` （足場1から足場2へのジャンプコスト）
- **遷移方法**:
  - 足場`i`（`i >= 2`）に到達するための最小コストは、以下の2通りのうち小さい方。
    1. 足場`i`に1つ前の足場からジャンプする場合:
       - コスト = `dp[i-1] + abs(h[i] - h[i-1])`
    2. 足場`i`に2つ前の足場からジャンプする場合:
       - コスト = `dp[i-2] + abs(h[i] - h[i-2])`
- **最適解の構築**:
  - 各ステップで最小のコストを選択し、全体の最小コストを求める。

---

### **追加の事例：入力例2**

**入力例2**

```
2
10 10
```

- 足場の数 `N = 2`
- 各足場の高さ `h = [10, 10]`

**計算手順**

1. **初期化**

   ```python
   dp = [0, 0]
   dp[1] = abs(10 - 10) = 0
   ```

2. **ループ**

   - 足場の数が2なので、ループは実行されません。

3. **結果の出力**

   - `dp[-1] = dp[1] = 0`

**最終的な出力:**

```
0
```

---

### **まとめ**

- **ポイント1**: **動的計画法**を用いて、問題を小さな部分問題に分割し、効率的に解を求めています。

- **ポイント2**: 各足場での最小コストは、 **「1つ前の足場から来る場合」と「2つ前の足場から来る場合」** のコストを比較することで求めます。

- **ポイント3**: この方法により、計算量は O(N) となり、大きな N に対しても高速に計算できます。

---

### **数学的な理解**

- **再帰関係式**

  足場 `i` までの最小コスト `dp[i]` は以下の再帰関係で表されます。

$$
dp[i] = \min\left( dp[i-1] + |h_i - h_{i-1}|,\ dp[i-2] + |h_i - h_{i-2}| \right)
$$

  （ここで、`h_i` は足場 `i` の高さ。）

- **初期条件**

$$
dp[0] = 0 \\
$$

$$
dp[1] = |h_1 - h_0|
$$

- **問題の本質**

  - カエルが足場を移動する際、直前または2つ前の足場からジャンプできます。
  - 各足場での最小コストは、過去の計算結果（`dp[i-1]` と `dp[i-2]`）を用いて効率的に計算できます。

---

### **動的計画法のメリット**

- **計算量の削減**: 一度計算した部分問題の結果を再利用するため、無駄な計算を避けられます。

- **問題への適用**: 最適部分構造と重複部分問題を持つ問題に対して有効です。この問題では、各足場までの最小コストがそれ以前の最小コストに基づいて計算できます。

---

### **最後に**

このコードは、動的計画法の基本的な考え方を示す良い例です。初心者の方は、まず小さな入力例で手計算しながら、`dp` リストがどのように更新されていくかを追ってみると理解が深まると思います。

動的計画法は様々な最適化問題で使われる重要な手法ですので、この機会にぜひマスターしてみてください。

ご不明な点や追加の質問がありましたら、お気軽にお尋ねください。

<br>
<br>

---
# 029

このコードは、N 段の階段を1段または2段ずつ上がるときの、上がり方の数を計算することを目的としています。動的計画法（Dynamic Programming）というアルゴリズムを用いて、効率的に計算を行います。

### コードの詳細解説

#### `min_cost`関数

1. **リスト`dp`の初期化**:
    ```python
    dp = [0] * (N+1)
    ```
    - `dp`は長さ`N+1`のリストで、各インデックス`i`に対して`dp[i]`は`i`段目に到達する方法の数を表します。
    - 例えば、`N=4`の場合、`dp`は `[0, 0, 0, 0, 0]` となります。

2. **初期条件の設定**:
    ```python
    dp[0] = dp[1] = 1
    ```
    - `dp[0]`と`dp[1]`を1に設定します。これは、0段目と1段目に到達する方法がそれぞれ1通りであることを意味します。
    - 例えば、`N=4`の場合、`dp`は `[1, 1, 0, 0, 0]` となります。

3. **動的計画法による計算**:
    ```python
    for i in range(2, N+1):
        dp[i] = dp[i-1] + dp[i-2]
    ```
    - 2段目からN段目までの各段に対して、`dp[i]`を計算します。
    - `dp[i]`は、`dp[i-1]`（1段前から来る方法）と`dp[i-2]`（2段前から来る方法）の合計です。
    - 例えば、`N=4`の場合、以下のように計算されます:
        - `i=2`: `dp[2] = dp[1] + dp[0] = 1 + 1 = 2` → `dp = [1, 1, 2, 0, 0]`
        - `i=3`: `dp[3] = dp[2] + dp[1] = 2 + 1 = 3` → `dp = [1, 1, 2, 3, 0]`
        - `i=4`: `dp[4] = dp[3] + dp[2] = 3 + 2 = 5` → `dp = [1, 1, 2, 3, 5]`

4. **結果の返却**:
    ```python
    return dp[-1]
    ```
    - `dp[-1]`（リストの最後の要素）を返します。これは、N段目に到達する方法の数です。
    - 例えば、`N=4`の場合、`dp[4]`は5なので、5が返されます。

#### `main`関数

1. **標準入力からNを読み込む**:
    ```python
    N = int(input())
    ```
    - ユーザーから入力された値を整数として読み込みます。

2. **`min_cost`関数を呼び出し、結果を出力**:
    ```python
    print(min_cost(N))
    ```
    - `min_cost`関数を呼び出し、その結果を出力します。

#### エントリーポイント

1. **スクリプトのエントリーポイント**:
    ```python
    if __name__ == "__main__":
        main()
    ```
    - このスクリプトが直接実行された場合に`main`関数を呼び出します。

### 処理内容の過程

入力例として、N=4の場合をもう少し詳しく見てみましょう。

1. **初期化**:
    - `dp`リストを初期化します: `dp = [0, 0, 0, 0, 0]`
    - `dp[0]`と`dp[1]`を1に設定します: `dp = [1, 1, 0, 0, 0]`

2. **動的計画法による計算**:
    - `i=2`のとき、`dp[2] = dp[1] + dp[0] = 1 + 1 = 2`: `dp = [1, 1, 2, 0, 0]`
    - `i=3`のとき、`dp[3] = dp[2] + dp[1] = 2 + 1 = 3`: `dp = [1, 1, 2, 3, 0]`
    - `i=4`のとき、`dp[4] = dp[3] + dp[2] = 3 + 2 = 5`: `dp = [1, 1, 2, 3, 5]`

3. **結果の返却**:
    - `dp[-1]`（`dp[4]`）を返します。これは5です。

つまり、N=4の場合、0段目から4段目まで移動する方法は5通りあります。

### なぜこの方法で解けるのか？

動的計画法（DP）の考え方：
1. **部分問題に分解**: 大きな問題（N段目までの方法）を小さな問題（i段目までの方法）に分解
2. **再利用**: 一度計算した結果を保存して再利用
3. **漸化式**: `dp[i] = dp[i-1] + dp[i-2]`
   - i段目には「(i-1)段目から1段上がる」か「(i-2)段目から2段上がる」かの2通りの方法でしか到達できない
   - それぞれの方法数を足し合わせることで、i段目への総到達方法が分かる

<br>
<br>

---
# 030

ナップサック問題の解説を、できるだけ分かりやすく説明していきましょう。



### 1. まずは問題を簡単な例で理解しましょう 🎒

例えば、以下のような品物があるとします：
```
品物1: 重さ3kg, 価値30円
品物2: 重さ4kg, 価値50円
品物3: 重さ5kg, 価値60円
```
ナップサックの容量は8kgです。

### 2. コードの基本構造を理解しよう 📝

```python
def knapsack(N, W, items):
    # dpテーブルを作成（サイズはナップサックの容量+1）
    dp = [0] * (W+1)

    # 各品物について処理
    for w, v in items:
        # ナップサックの容量から逆順に処理
        for i in range(W, w-1, -1):
            # その重さでの最大価値を更新
            dp[i] = max(dp[i], dp[i-w]+v)

    return dp[-1]  # 最終的な最大価値を返す
```

### 3. dpテーブルの仕組み 🎯

dpテーブルは「重さiのときの最大価値」を保存します。
例えば、上記の例で見てみましょう：

初期状態：
```python
dp = [0, 0, 0, 0, 0, 0, 0, 0, 0]  # インデックス0～8
```

### 4. 具体的な処理過程 🔄

#### 品物1（重さ3kg, 価値30円）を処理：
```python
# 重さ8から3まで逆順に処理
dp[8] = max(dp[8], dp[5]+30)  # 0 vs (0+30) → 30
dp[7] = max(dp[7], dp[4]+30)  # 0 vs (0+30) → 30
dp[6] = max(dp[6], dp[3]+30)  # 0 vs (0+30) → 30
dp[5] = max(dp[5], dp[2]+30)  # 0 vs (0+30) → 30
dp[4] = max(dp[4], dp[1]+30)  # 0 vs (0+30) → 30
dp[3] = max(dp[3], dp[0]+30)  # 0 vs (0+30) → 30
```

結果：
```python
dp = [0, 0, 0, 30, 30, 30, 30, 30, 30]
```

#### 品物2（重さ4kg, 価値50円）を処理：
```python
dp[8] = max(30, dp[4]+50)  # 30 vs (30+50) → 80
dp[7] = max(30, dp[3]+50)  # 30 vs (30+50) → 80
dp[6] = max(30, dp[2]+50)  # 30 vs (0+50) → 50
dp[5] = max(30, dp[1]+50)  # 30 vs (0+50) → 50
dp[4] = max(30, dp[0]+50)  # 30 vs (0+50) → 50
```

結果：
```python
dp = [0, 0, 0, 30, 50, 50, 50, 80, 80]
```

#### 品物3（重さ5kg, 価値60円） を処理：

```python
dp[8] = max(dp[8], dp[3]+60)  # 80 vs (30+60) → 90
dp[7] = max(dp[7], dp[2]+60)  # 80 vs (0+60) → 80
dp[6] = max(dp[6], dp[1]+60)  # 50 vs (0+60) → 60
dp[5] = max(dp[5], dp[0]+60)  # 50 vs (0+60) → 60
```

最終的なdp配列：
```python
dp = [0, 0, 0, 30, 50, 60, 60, 80, 90]
```

[memo] debug
```bash
root:/workspaces/AtCoder/AlgorithmAndMath/3rd# python 030.py
3 8
3 30
4 50
5 60
======================== w, v : 3, 30
----------------- i : 8
dp[8]    : 0
dp[5]    : 0
dp[5]+30 : 30
----------------- i : 7
dp[7]    : 0
dp[4]    : 0
dp[4]+30 : 30
----------------- i : 6
dp[6]    : 0
dp[3]    : 0
dp[3]+30 : 30
----------------- i : 5
dp[5]    : 0
dp[2]    : 0
dp[2]+30 : 30
----------------- i : 4
dp[4]    : 0
dp[1]    : 0
dp[1]+30 : 30
----------------- i : 3
dp[3]    : 0
dp[0]    : 0
dp[0]+30 : 30
dp : [0, 0, 0, 30, 30, 30, 30, 30, 30]
======================== w, v : 4, 50
----------------- i : 8
dp[8]    : 30
dp[4]    : 30
dp[4]+50 : 80
----------------- i : 7
dp[7]    : 30
dp[3]    : 30
dp[3]+50 : 80
----------------- i : 6
dp[6]    : 30
dp[2]    : 0
dp[2]+50 : 50
----------------- i : 5
dp[5]    : 30
dp[1]    : 0
dp[1]+50 : 50
----------------- i : 4
dp[4]    : 30
dp[0]    : 0
dp[0]+50 : 50
dp : [0, 0, 0, 30, 50, 50, 50, 80, 80]
======================== w, v : 5, 60
----------------- i : 8
dp[8]    : 80
dp[3]    : 30
dp[3]+60 : 90
----------------- i : 7
dp[7]    : 80
dp[2]    : 0
dp[2]+60 : 60
----------------- i : 6
dp[6]    : 50
dp[1]    : 0
dp[1]+60 : 60
----------------- i : 5
dp[5]    : 50
dp[0]    : 0
dp[0]+60 : 60
dp : [0, 0, 0, 30, 50, 60, 60, 80, 90]
90
```

### 5. なぜ逆順に処理するの？ 🤔

重要なポイント：逆順で処理することで、同じ品物を重複して使用することを防ぎます。

例として、重さ3kg、価値30円の品物を考えてみましょう。
ナップサックの容量は6kgとします。

#### 1️⃣ 順方向（前から）で処理した場合の問題点

```python
dp = [0, 0, 0, 0, 0, 0, 0]  # 0~6kgまでの配列
```

前から処理すると：
```python
# ステップ1: 重さ3kgのところを更新
dp[3] = max(dp[3], dp[0] + 30)
# dp = [0, 0, 0, 30, 0, 0, 0]

# ステップ2: 重さ6kgのところを更新
dp[6] = max(dp[6], dp[3] + 30)  # ← ここで問題発生！
# dp = [0, 0, 0, 30, 0, 0, 60]
```

問題点：
- dp[6]を計算するとき、dp[3]の30円を使っています
- これは「同じ品物」を2回使ってしまっていることになります
- 実際には1つしかない品物を2回使った計算になってしまいます！

#### 2️⃣ 逆順（後ろから）で処理する場合

```python
dp = [0, 0, 0, 0, 0, 0, 0]  # 0~6kgまでの配列
```

後ろから処理すると：
```python
# ステップ1: 重さ6kgのところを更新
dp[6] = max(dp[6], dp[3] + 30)
# dp = [0, 0, 0, 0, 0, 0, 30]

# ステップ2: 重さ3kgのところを更新
dp[3] = max(dp[3], dp[0] + 30)
# dp = [0, 0, 0, 30, 0, 0, 30]
```

良い点：
- 大きい重さから処理することで、前の計算結果を使って誤って2回目の使用をすることがありません
- 各品物を1回だけ使用する正しい計算ができます

#### 💡 まとめ

逆順で処理する理由：
1. 同じ品物を誤って2回使うことを防ぐため
2. 各品物を1回だけ使用する正しい計算をするため
3. 前の計算結果に影響されずに新しい状態を計算できるため

このように、逆順に処理することで、「1つの品物は1回だけ使う」というナップサック問題の基本ルールを守ることができます。

### 6. 数学的な考え方 📐

このアルゴリズムは以下の漸化式で表現できます：
```
dp[i] = max(dp[i], dp[i-w]+v)
```

意味：
- `dp[i]`：重さiまで使える時の最大価値
- `dp[i-w]+v`：新しい品物（重さw, 価値v）を加えた場合の価値

### 7. メモリ効率化のポイント 💡

従来のナップサック問題では2次元配列を使用しますが、このコードは1次元配列で解決しています：
- 従来: `dp[N+1][W+1]` (品物の数×重さ)
- 最適化後: `dp[W+1]` (重さのみ)

これにより：
- メモリ使用量が大幅に削減
- 処理速度も向上

### まとめ 📝

このアルゴリズムの特徴：
1. 各品物は1回だけ使用可能
2. 逆順の処理で重複を防止
3. メモリ効率が良い
4. 動的計画法の基本的な考え方を実現

このコードは、複雑な問題を効率的に解決する素晴らしい例です。動的計画法の考え方を使って、段階的に最適な解を構築していきます。

これでコードの動作が理解できましたでしょうか？もし特定の部分についてさらに詳しく知りたい場合は、お気軽に質問してください！

<br>

### **逆から計算する理由をわかりやすく説明**

#### **ナップサック問題のルール**
1. 各品物は「1回だけ」選べる。
2. 同じ品物を何度も選ぶことはできない。

例えば、以下の品物を考えます：
- 品物1：重さ3、価値30

ナップサックの容量が $W = 8$ のときに、「1回だけ」品物1を選んだ結果を正しく計算するには、重さを**大きい方から順番に**計算する必要があります。

---

### **具体例で説明：順番に計算した場合（小さい方から進む場合）**

もし、軽い方（小さい方）から順番に計算すると、次のような問題が起こります。

1. 初期状態の `dp` 配列：

$$
   dp = [0, 0, 0, 0, 0, 0, 0, 0, 0]
$$

2. $i = 3$ のとき：
   - 品物1を選んだ場合、重さ3のナップサックに入れられるので：

$$
     dp[3] = \max(dp[3], dp[3 - 3] + 30) = \max(0, dp[0] + 30) = 30
$$

   - 更新後：

$$
     dp = [0, 0, 0, 30, 0, 0, 0, 0, 0]
$$

3. $i = 6$ のとき：
   - ここで、もし小さい方から順番に更新すると、すでに更新した `dp[3]` を利用してしまいます。
   - 品物1を「2回選んだ」計算になってしまいます。

$$
     dp[6] = \max(dp[6], dp[6 - 3] + 30) = \max(0, dp[3] + 30) = 30 + 30 = 60
$$

   - でも品物1は1回しか選べないはず！この計算は間違いです。

---

### **正しい計算方法：重い方（大きい方）から進む**

逆順で計算すると、すでに選んだ品物の影響を受けずに「1回だけ選んだ場合」の結果を正しく計算できます。

#### 具体例：逆順で計算する
1. $i = 8$：
   - 品物1を選んだ場合、重さ3の分だけ減るので：

$$
     dp[8] = \max(dp[8], dp[8 - 3] + 30) = \max(0, dp[5] + 30) = 30
$$

2. $i = 7$：
   - 品物1を選んだ場合、重さ3の分だけ減るので：

$$
     dp[7] = \max(dp[7], dp[7 - 3] + 30) = \max(0, dp[4] + 30) = 30
$$

3. $i = 6$：
   - 品物1を選んだ場合、重さ3の分だけ減るので：

$$
     dp[6] = \max(dp[6], dp[6 - 3] + 30) = \max(0, dp[3] + 30) = 30
$$

---

### **なぜ逆順で解決するのかを簡単にまとめると：**
1. **逆順に計算すると、品物を「1回だけ」選んだ場合の影響だけを正しく反映できる。**
2. 順番に進むと、すでに更新された値を使って計算してしまい、品物を「2回以上選んだ」ような結果になってしまう可能性がある。
3. 逆順で進むことで、このような間違いを防ぐことができる。

---

### **たとえ話**
ナップサックに品物を入れる作業を「後ろからチェックする」と考えてみよう。

- ナップサックの容量が8あるとき、「重い部分から先に品物を入れるかどうか」をチェックすれば、同じ品物を2回以上入れるミスを防げる。
- 一方で、軽い部分から順番に進むと、「先に品物を入れた結果」をそのまま次の計算に使ってしまい、同じ品物を2回入れたような結果になることがある。

つまり、「逆順で計算することでミスを防ぐ」と覚えるとわかりやすいです！

<br>
<br>

### [補足] dp[j] = max(dp[j], dp[j-w]+v) の解説

この部分が一番重要な箇所なので、落ち着いて理解していきましょう！

**状況:**

* `dp[j]` は「ナップサックの容量が `j` の時に実現できる価値の最大値」を格納していくためのリストです。
* 今、重さ `w`、価値 `v` の品物を新たに検討しようとしています。

**この処理が意味すること:**

1. `dp[j]` は、この品物を **入れる前** の、容量 `j` で実現できる最大価値を保持しています。
2. `dp[j-w]+v` は、この品物を **入れる** ことを考えた場合の価値です。
    * まず、`j-w` は「新しい品物を **入れる** ために残しておくべき容量」です。
    * `dp[j-w]` は「その残しておいた容量で実現できる最大価値」です。
    * そこに、新しく入れる品物の価値 `v` を足せば、 **新しい品物を入れた場合の価値** が計算できます。

つまり、`dp[j] = max(dp[j], dp[j-w]+v)` は、

* **「新しい品物を入れない場合」と「入れる場合」の価値を比較し、より価値の高い方を選択する**

という処理を意味しています。

**具体例で確認:**

`items = [(3, 30), (4, 50), (5, 60)]` で、ナップサックの容量 `W = 8` の場合を考えます。

1. `(3, 30)` の品物を検討する段階で、`j = 5` の時を考えてみましょう。
    * `dp[5]` は現時点では `0` です (まだ何も入れていない)。
    * `dp[j-w] = dp[2]` も `0` です。
    * `dp[j-w] + v = 0 + 30 = 30` となります。
    * `max(0, 30) = 30` なので、`dp[5]` は `30` に更新されます。

2. 次に `(4, 50)` を検討する段階で、再び `j = 5` の時を考えます。
    * `dp[5]` は `30` です ((3, 30) を入れた場合の価値が残っている)。
    * `dp[j-w] = dp[1]` は `0` です。
    * `dp[j-w] + v = 0 + 50 = 50` となります。
    * `max(30, 50) = 50` なので、`dp[5]` は `50` に更新されます。

このように、各品物、各容量について「入れるか入れないか」の選択を比較し、`dp` リストを更新していくことで、最終的に `dp[W]` には「ナップサックの容量 `W` で実現できる最大価値」が格納されることになります。

**ポイント:**

* `j` のループが `W` から降順になっているのは、同じ品物を複数回使わないようにするためです。
* 各品物について `dp` リスト全体を更新していくことで、あらゆる組み合わせを効率的に探索しています。

この解説で、`dp[j] = max(dp[j], dp[j-w]+v)` の部分が少しでもクリアになれば幸いです！

<br>
<br>

---
# 031

### コード全体の流れ

このプログラムは、太郎君が夏休み中に勉強をして得られる最大の実力値を計算します。太郎君は 2 日連続で勉強しないという制約があるため、各日の実力値を考慮しつつ最大値を求める必要があります。

### コードの説明

まずは、具体例として入力例を考えます。

#### 例:

- 日数 `N = 5`
- 各日の実力値 `A = [2, 5, 3, 3, 1]`

### 関数 `dp(N, A)` の説明

```python
def dp(N, A):
    dp = [0] * (N+1)
    dp[1] = A[0]
    for i in range(2, N+1):
        dp[i] = max(dp[i-1], dp[i-2] + A[i-1])
    return dp[-1]
```

#### ステップ 1: 初期化

1. **`dp = [0] * (N+1)`**:

   - `dp`リストを初期化します。このリストは`N+1`個の要素を持ち、全て 0 で初期化されています。
   - `dp[i]`は、`i`日目までの間に得られる最大の実力値を保持します。

   例えば、`N = 5`の場合、最初に作られるリストは次のようになります:

   ```python
   dp = [0, 0, 0, 0, 0, 0]
   ```

2. **`dp[1] = A[0]`**:

   - 1 日目に勉強した場合の実力値を設定します。`dp[1]`に`A[0]`を代入します。
   - `dp[1] = 2`となります。

   この時点で`dp`リストは次のようになります:

   ```python
   dp = [0, 2, 0, 0, 0, 0]
   ```

#### ステップ 2: 動的計画法による計算

3. **`for i in range(2, N+1):`**:

   - 2 日目から N 日目までの各日について計算します。

4. **`dp[i] = max(dp[i-1], dp[i-2] + A[i-1])`**:

   - `dp[i-1]`は、`i-1`日目までの最大の実力値を意味します。これは、`i`日目に勉強しない場合の実力値です。
   - `dp[i-2] + A[i-1]`は、`i-2`日目までの最大の実力値に`i`日目の実力値を加えたものです。これは、`i`日目に勉強する場合の実力値です。
   - より大きな値を`dp[i]`に保存します。

   実際の計算を見てみましょう。

   - `i = 2` の場合:

     - `dp[2] = max(dp[1], dp[0] + A[1]) = max(2, 0 + 5) = 5`
     - `dp = [0, 2, 5, 0, 0, 0]`

   - `i = 3` の場合:

     - `dp[3] = max(dp[2], dp[1] + A[2]) = max(5, 2 + 3) = 5`
     - `dp = [0, 2, 5, 5, 0, 0]`

   - `i = 4` の場合:

     - `dp[4] = max(dp[3], dp[2] + A[3]) = max(5, 5 + 3) = 8`
     - `dp = [0, 2, 5, 5, 8, 0]`

   - `i = 5` の場合:
     - `dp[5] = max(dp[4], dp[3] + A[4]) = max(8, 5 + 1) = 8`
     - `dp = [0, 2, 5, 5, 8, 8]`

#### ステップ 3: 最終的な実力値の取得

5. **`return dp[-1]`**:
   - `dp[-1]`（つまり`dp[5]`）を返します。これが太郎君が得られる最大の実力値です。
   - この例では、結果は `8` となります。

### 全体の流れをまとめると:

- 入力として`N`日分の実力値リスト`A`を受け取ります。
- `dp()`関数で動的計画法を用いて、太郎君が 2 日連続で勉強しないという制約のもとで、得られる最大の実力値を計算します。
- その結果を出力します。今回の例では、答えは`8`となります。

<br>
<br>

---
# 033

このコードは、2次元平面上にある点 `A` と線分 `BC` 上の最短距離を計算するものです。いくつかのサポート関数を使って、処理を分かりやすく、また再利用可能にしています。それぞれの関数の役割と処理の流れを、例を使って解説します。

## 点と線分の距離：数式を用いた詳細解説とコードの仕組み

このコードは、平面上に存在する点と線分の最短距離を求めるためのものです。以下では、数式を交えながらコードの解説を行います。

**問題設定**

2次元平面上に点Aと線分BCが存在するとします。点Aの座標を $(a_x, a_y)$ 、点Bの座標を $(b_x, b_y)$ 、点Cの座標を $(c_x, c_y)$ とします。

**目標**

点Aと線分BC間の最短距離を求めます。

**1. ベクトル計算の準備**

まず、点A, B, C を使って、以下の4つのベクトルを計算します。

* $\overrightarrow{BA} = (a_x - b_x, a_y - b_y)$
* $\overrightarrow{BC} = (c_x - b_x, c_y - b_y)$
* $\overrightarrow{CA} = (a_x - c_x, a_y - c_y)$
* $\overrightarrow{CB} = (b_x - c_x, b_y - c_y)$

**2. 最短距離になる点を探す**

点Aから線分BCへ垂線を下ろし、その足を点Hとします。この点Hこそが、点Aから線分BCへの最短距離を与える点となります。

**3. 点Hの位置で場合分け**

**ケース1：点Hが線分BCの外側で、点B寄りにある場合**

* この時、点Bと点Aを結ぶ線分が最短距離になります。
* $\overrightarrow{BA}$ と $\overrightarrow{BC}$ の内積が負になる、すなわち $\overrightarrow{BA} \cdot \overrightarrow{BC} < 0$ という条件で判別できます。
* この場合、最短距離は点Aと点Bの距離なので、以下のユークリッド距離の公式を用いて計算できます。
    * $\text{距離} = \sqrt{(a_x - b_x)^2 + (a_y - b_y)^2}$

**ケース2：点Hが線分BCの外側で、点C寄りにある場合**

* この時、点Cと点Aを結ぶ線分が最短距離になります。
*  $\overrightarrow{CA}$ と $\overrightarrow{CB}$ の内積が負になる、すなわち $\overrightarrow{CA} \cdot \overrightarrow{CB} < 0$ という条件で判別できます。
* この場合、最短距離は点Aと点Cの距離なので、以下のユークリッド距離の公式を用いて計算できます。
    * $\text{距離} = \sqrt{(a_x - c_x)^2 + (a_y - c_y)^2}$

**ケース3：点Hが線分BC上にある場合**

* この時、点Hと点Aを結ぶ線分が最短距離になります。
* 上記2つのケース以外の場合に該当します。

**点Hの座標を求める**

点Hは線分BC上の点なので、ベクトル $\overrightarrow{BC}$ を用いて以下のように表せます。

$$
\overrightarrow{OH} = \overrightarrow{OB} + t\overrightarrow{BC} \quad (0 \le t \le 1)
$$

ここで、 $\overrightarrow{OH}$ は原点Oから点Hへのベクトル、 $\overrightarrow{OB}$ は原点Oから点Bへのベクトルを表し、 $t$ は線分BCに対する点Hの位置を表すパラメータです。 $t$ が0のとき点Hは点Bと一致し、 $t$ が1のとき点Hは点Cと一致します。

**t の求め方**

点Hは垂線の足なので、 $\overrightarrow{AH}$ と $\overrightarrow{BC}$ は直交します。つまり、内積が0になります。

$$
\overrightarrow{AH} \cdot \overrightarrow{BC} = 0
$$

$\overrightarrow{AH} = \overrightarrow{OH} - \overrightarrow{OA}$ 、 $\overrightarrow{OH} = \overrightarrow{OB} + t\overrightarrow{BC}$ を代入して展開すると、

$$
(\overrightarrow{OB} + t\overrightarrow{BC} - \overrightarrow{OA}) \cdot \overrightarrow{BC} = 0
$$

$$
t = \frac{(\overrightarrow{OA} - \overrightarrow{OB}) \cdot \overrightarrow{BC}}{\overrightarrow{BC} \cdot \overrightarrow{BC}} =  \frac{\overrightarrow{BA} \cdot \overrightarrow{BC}}{\overrightarrow{BC} \cdot \overrightarrow{BC}}
$$

このようにして、 $t$ を求めることができます。

**点Hの座標の算出**

$t$ が求まれば、点Hの座標 $(h_x, h_y)$ は以下のようになります。

$$
h_x = b_x + t(c_x - b_x)
$$

$$
h_y = b_y + t(c_y - b_y)
$$

**最短距離の計算**

点Hの座標が求まれば、点Aと点Hの距離、すなわち最短距離はユークリッド距離の公式を用いて計算できます。

$$
\text{距離} = \sqrt{(a_x - h_x)^2 + (a_y - h_y)^2}
$$


**コードの解説**

```python
import numpy as np
import math

def vector_subtract(v1, v2):
    return [v1[0] - v2[0], v1[1] - v2[1]]

def distance(p1, p2):
    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)

def shortest_distance(A, B, C):
    BA = vector_subtract(A, B) # ベクトルBA
    BC = vector_subtract(C, B) # ベクトルBC
    CA = vector_subtract(A, C) # ベクトルCA
    CB = vector_subtract(B, C) # ベクトルCB

    if np.dot(BA, BC) < 0: # ケース1: 点Hが点Bの外側
        nearest = B
    elif np.dot(CA, CB) < 0: # ケース2: 点Hが点Cの外側
        nearest = C
    else: # ケース3: 点Hが線分BC上
        t = np.dot(BA, BC) / np.dot(BC, BC) # tの計算
        nearest = [B[0] + t * BC[0], B[1] + t * BC[1]] # 点Hの座標

    return distance(A, nearest) # 最短距離の計算
```

### 各関数の解説

1. **`vector_subtract(v1, v2)`**
   - これは、2つのベクトル（2次元座標のリスト）の減算を行う関数です。例えば、ベクトル `v1 = [x1, y1]` からベクトル `v2 = [x2, y2]` を引くと、`[x1 - x2, y1 - y2]` を返します。
   - ベクトルの減算は、点と点の相対的な位置（方向や長さ）を求めるために使います。

2. **`distance(p1, p2)`**
   - この関数は、2点間のユークリッド距離を計算します。距離公式は次の通りです： <br>
     $\text{distance} = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$
   - これにより、2点の座標間の直線距離を計算できます。

3. **`shortest_distance(A, B, C)`**
   - この関数は、点 `A` から線分 `BC` への最短距離を計算します。処理の流れは以下の通りです。
   - まず、点 `A`、`B`、`C` を基準にベクトル `BA`（BからAへのベクトル）、`BC`（BからCへのベクトル）、`CA`（CからAへのベクトル）などを計算します。
   - 内積 (`np.dot`) を使って、点 `A` が線分 `BC` の範囲内にあるかどうかを判定します。これにより、最短距離がどう決まるかが決定されます。

4. **`main()`**
   - 標準入力から、点 `A`、`B`、`C` の座標を受け取り、それらをリストとして格納し、最短距離を計算する `shortest_distance` 関数に渡して結果を出力します。


### 具体的な事例での処理内容の説明

#### 例1:
```
入力:
A = [0, 5]
B = [1, 1]
C = [3, 0]
```

1. **ベクトルの計算**
   - ベクトル `BA` を計算します。`B = [1, 1]` から `A = [0, 5]` を引くと、
     ```
     BA = [0 - 1, 5 - 1] = [-1, 4]
     ```
   - 同様に、ベクトル `BC` を計算します。
     ```
     BC = [3 - 1, 0 - 1] = [2, -1]
     ```
   - このようにして、`BA` と `BC` が計算されました。

2. **内積計算**
   - ベクトル `BA` と `BC` の内積を計算します。内積とは、ベクトルの「方向」を比較する指標で、次のように計算されます。
     ```
     np.dot(BA, BC) = (-1 * 2) + (4 * -1) = -2 - 4 = -6
     ```
   - 内積が負であるため、点 `A` は線分 `BC` の範囲外、点 `B` 側にあることが分かります。

3. **最短距離の計算**
   - この場合、内積が負であるため、点 `A` から点 `B` への距離が最短になります。
   - 距離を計算するために、関数 `distance(A, B)` を使います。
     ```
     distance(A, B) = sqrt((0 - 1)^2 + (5 - 1)^2) = sqrt(1 + 16) = sqrt(17) ≈ 4.123105625618
     ```
   - このようにして、`A` と `B` の距離が最短距離として返されます。

---

### もう一つの例:
```
入力:
A = [-40, -30]
B = [-50, -10]
C = [-20, -20]
```

1. **ベクトルの計算**
   - `BA` と `BC` を計算します。
     ```
     BA = [-40 - (-50), -30 - (-10)] = [10, -20]
     BC = [-20 - (-50), -20 - (-10)] = [30, -10]
     ```

2. **内積計算**
   - `np.dot(BA, BC)` を計算します。
     ```
     np.dot(BA, BC) = (10 * 30) + (-20 * -10) = 300 + 200 = 500
     ```
   - 内積が正なので、次に進みます。
   - `BC` の長さの2乗は、
     ```
     np.dot(BC, BC) = 30^2 + (-10)^2 = 900 + 100 = 1000
     ```

3. **射影点の計算**
   - `t` を計算します。
     ```
     t = np.dot(BA, BC) / np.dot(BC, BC) = 500 / 1000 = 0.5
     ```
   - これにより、射影点 `nearest` を計算します。
     ```
     nearest = [-50 + 0.5 * 30, -10 + 0.5 * (-10)] = [-50 + 15, -10 - 5] = [-35, -15]
     ```

4. **最短距離の計算**
   - 射影点 `nearest = [-35, -15]` と点 `A = [-40, -30]` との距離を計算します。
     ```
     distance(A, nearest) = sqrt((-40 - (-35))^2 + (-30 - (-15))^2) = sqrt((-5)^2 + (-15)^2) = sqrt(25 + 225) = sqrt(250) ≈ 15.811388300842
     ```

このようにして、`A` から線分 `BC` までの最短距離が計算されます。

---

### まとめ

- **内積の役割**: 点 `A` が線分 `BC` 上のどの位置にあるかを判定するために内積を使用しています。内積が負なら点 `A` は `B` 側にあり、正なら線分 `BC` 上に射影されるか、`C` 側にあります。
- **射影点の計算**: 射影点が線分 `BC` 上にある場合、その点までの距離が最短となります。射影点は `t` を使って計算します。
- **距離計算**: 距離の計算にはユークリッド距離公式を使っており、A と最も近い点（B、C、または射影点）との距離が最短距離として計算されます。

<br>
<br>

---
# 034

### コードの解説

このコードでは、2次元平面上の複数の点の中で、最も近い2つの点の間の距離を計算しています。主な手順として、以下の3つの関数とロジックが含まれています。

1. **`distance(p1, p2)` 関数**：
   - 2つの点 `p1` と `p2` の間のユークリッド距離を計算する関数です。
   - ユークリッド距離は次の式に基づいています：
    <br>&nbsp;&nbsp;&nbsp;&nbsp;
     $d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$
   - `p1[0]` と `p2[0]` がそれぞれ x 座標、`p1[1]` と `p2[1]` がそれぞれ y 座標です。

2. **`find_min_distance(points)` 関数**：
   - 与えられた点のリスト `points` の中で、最も近い2点の距離を求める関数です。
   - まず、非常に大きな初期値 `float('Inf')` を最小距離として設定します。次に、全ての点のペアを二重ループで調べ、距離を計算します。計算した距離が現在の最小距離よりも小さい場合は、その距離を最小距離として更新します。

3. **`main()` 関数**：
   - プログラムのメイン部分です。
   - 最初に、標準入力から点の数 `N` を読み込み、その後、`N` 個の点の座標を受け取ります。受け取った点のリスト `points` を `find_min_distance` 関数に渡して、最も近い2点の距離を計算し、その結果を表示します。

### 処理の流れ

1. **入力の受け取り**:
   - 点の数 `N` を受け取ります。次に、`N` 個の点の座標を標準入力から受け取って、それをリストに格納します。

2. **最小距離の計算**:
   - 点のリストの中から、全ての点のペアを組み合わせて、それぞれの距離を計算します。計算された距離が最小距離よりも小さい場合は、その距離を更新します。

3. **結果の出力**:
   - 最も近い2点の距離を出力します。

### 具体的な事例を使った処理の過程

例えば、次のような入力があったとします：

```
4
0 1
2 0
2 3
3 1
```

1. **`main()` 関数の実行**：
   - 点の数 `N = 4` と点の座標 `[(0, 1), (2, 0), (2, 3), (3, 1)]` を受け取ります。

2. **`find_min_distance(points)` 関数の実行**：
   - `min_distance` を初期化します (`float('Inf')`)。
   - すべての点のペアの距離を計算します：

   | 点のペア               | 距離計算 (ユークリッド距離)                                  | 距離                     |
   |----------------------|------------------------------------------------------------|--------------------------|
   | (0, 1) と (2, 0)     | \( $\sqrt{(2-0)^2 + (0-1)^2} = \sqrt{4 + 1} = \sqrt{5}$ \)   | 約 2.236                  |
   | (0, 1) と (2, 3)     | \( $\sqrt{(2-0)^2 + (3-1)^2} = \sqrt{4 + 4} = \sqrt{8}$ \)   | 約 2.828                  |
   | (0, 1) と (3, 1)     | \( $\sqrt{(3-0)^2 + (1-1)^2} = \sqrt{9 + 0} = \sqrt{9}$ \)   | 3                        |
   | (2, 0) と (2, 3)     | \( $\sqrt{(2-2)^2 + (3-0)^2} = \sqrt{0 + 9} = \sqrt{9}$ \)   | 3                        |
   | (2, 0) と (3, 1)     | \( $\sqrt{(3-2)^2 + (1-0)^2} = \sqrt{1 + 1} = \sqrt{2}$ \)   | 約 1.414                  |
   | (2, 3) と (3, 1)     | \( $\sqrt{(3-2)^2 + (1-3)^2} = \sqrt{1 + 4} = \sqrt{5}$ \)   | 約 2.236                  |

   - 最も近い2点は `(2, 0)` と `(3, 1)` で、距離は約 1.414 です。

3. **結果の出力**：
   - 最小距離である `1.414213562373` が出力されます。

### まとめ
このプログラムは、2次元平面上の複数の点から最も近い2つの点の距離を求めます。`find_min_distance()` 関数で全ての点のペアの距離を計算し、最小距離を見つけます。事例を用いて処理の流れを説明すると、プログラムがどのように点のペアごとに距離を計算して、最も近い点の距離を更新していくかが理解しやすくなります。

<br>
<br>

---
# 035

[参考] 2つの円の位置関係<br>
https://manabitimes.jp/math/745

このコードは、2 つの円の位置関係を判定するプログラムです。具体的には、与えられた 2 つの円の半径と中心座標から、以下の 5 つの位置関係のいずれかに分類し、その番号を出力します。

1. 一方の円が他方の円を完全に含み、2 つの円は接していない
2. 一方の円が他方の円を完全に含み、2 つの円は接している
3. 2 つの円が互いに交差する
4. 2 つの円の内部に共通部分は存在しないが、2 つの円は接している
5. 2 つの円の内部に共通部分は存在せず、2 つの円は接していない


プログラムの特徴と動作について詳細に説明します。

### コードの構成と解説

1. **モジュールのインポート**
   ```python
   import math
   ```
   - `math`モジュールをインポートしています。これは、数学的な関数を使うためです。ここでは、特にユークリッド距離を計算するための平方根関数 `math.sqrt` を使用しています。

2. **関数 `check_circle_position`**
   ```python
   def check_circle_position(r1, r2, d):
       if d < abs(r1 - r2):
           return 1
       elif d == abs(r1 - r2):
           return 2
       elif abs(r1 - r2) < d < r1 + r2:
           return 3
       elif d == r1 + r2:
           return 4
       elif d > r1 + r2:
           return 5
       else:
           return None
   ```
   - **引数**: 2つの円の半径 `r1` と `r2`、および円の中心間の距離 `d` を受け取ります。
   - **判定処理**:
     - `d < abs(r1 - r2)`: <br>&nbsp;&nbsp;&nbsp;
     一方の円が他方を完全に含んでいる状態で接していない場合。この場合、1を返します。
     - `d == abs(r1 - r2)`:<br>&nbsp;&nbsp;&nbsp;
     一方の円が他方を完全に含み、ちょうど接している場合。この場合、2を返します。
     - `abs(r1 - r2) < d < r1 + r2`: <br>&nbsp;&nbsp;&nbsp;
     2つの円が交差している場合。この場合、3を返します。
     - `d == r1 + r2`: <br>&nbsp;&nbsp;&nbsp;
     2つの円が外側でちょうど接している場合。この場合、4を返します。
     - `d > r1 + r2`: <br>&nbsp;&nbsp;&nbsp;
     2つの円が全く交差せず、離れている場合。この場合、5を返します。
   - **返り値**: 位置関係を示す番号を返します。

3. **関数 `main`**
   ```python
   def main():
       x1, y1, r1 = map(int, input().split())
       x2, y2, r2 = map(int, input().split())
       d = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
       print(check_circle_position(r1, r2, d))
   ```
   - **入力の取得**:
     - 2つの円の中心座標 `(x1, y1)` と `(x2, y2)`、および半径 `r1` と `r2` を標準入力から取得します。
     - `map(int, input().split())` を使ってスペース区切りの整数として入力を取得します。
   - **距離の計算**:
     - `d = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)` は2つの円の中心間の距離をユークリッド距離として計算します。

$$
d = \sqrt{(x1 - x2)^2 + (y1 - y2)^2}
$$

   - **位置関係の判定**:
     - `check_circle_position` 関数を呼び出して、返された位置関係の番号を出力します。

### 処理過程の具体例

#### 事例1:
入力:
```
4 1 2
1 5 3
```
- **ステップ1**: 円1の中心座標は `(4, 1)`、半径は `2`。円2の中心座標は `(1, 5)`、半径は `3`。
- **ステップ2**: 中心間の距離 `d` を計算します。

$$
d = \sqrt{(4 - 1)^2 + (1 - 5)^2} = \sqrt{9 + 16} = \sqrt{25} = 5
$$

- **ステップ3**: 判定の流れ
  - 半径の差: `|r1 - r2| = |2 - 3| = 1`
  - 半径の和: `r1 + r2 = 2 + 3 = 5`
  - 距離 `d = 5` は半径の和と等しいので、4番目の状態、つまり「円が外接している」と判断されます。
  出力: `4`

#### 事例2:
入力:
```
1 1 6
3 3 2
```
- **ステップ1**: 円1の中心座標は `(1, 1)`、半径は `6`。円2の中心座標は `(3, 3)`、半径は `2`。
- **ステップ2**: 中心間の距離 `d` を計算します。

$$
d = \sqrt{(1 - 3)^2 + (1 - 3)^2} = \sqrt{4 + 4} = \sqrt{8} \approx 2.83
$$

- **ステップ3**: 判定の流れ
  - 半径の差: `|r1 - r2| = |6 - 2| = 4`
  - 半径の和: `r1 + r2 = 6 + 2 = 8`
  - 距離 `d ≈ 2.83` は半径の差 `4` より小さいため、1番目の状態、つまり「一方の円が他方を完全に含み、接していない」と判断されます。
  出力: `1`

### まとめ:
このコードは、2つの円の位置関係を計算して判定するシンプルなアルゴリズムです。中心間の距離をまず計算し、条件に基づいてその関係を判定していきます。数学的な概念（円の位置関係や座標間の距離）に基づいているので、初心者でも数式を理解しながらステップバイステップで追っていける内容になっています。

<br>
<br>

---
# 036

このコードでは、アナログ時計の時針と分針の端点の距離を三角関数を使って計算しています。これから、コードの全体的な流れ、使われている数式、そして具体的な事例を用いて解説します。

## 1. 基本アイデア

アナログ時計の時針と分針はそれぞれ異なる角速度で回ります。H時M分の時、時針と分針が作る角度を計算し、その角度を基にして2本の針の固定されていない端点間の距離を求めます。

三角形の3辺の長さと角度に関する関係を示す**余弦定理**を使って、距離を計算しています。

### 余弦定理とは
余弦定理は、任意の三角形の2辺とそれらの間の角度を用いて、残りの辺の長さを計算する方法です。

公式は次の通りです： $c^2 = a^2 + b^2 - 2ab \cdot \cos(\theta)$

ここで：
- $a$ と $b$ は、時針と分針の長さに相当します。
- $\theta$ は、時針と分針が作る角度です。
- $c$ は、2つの針の固定されていない端点間の距離（求めたい値）です。

### 解説コード

### `calc_distance(A, B, H, M)` 関数
1. **角度の計算**
   - `angle_H`: 時針の角度を計算します。時針は12時間で1周 (360度) します。したがって、H時の時針の角度は $360 \times \dfrac{H}{12}$ となります。また、M分が経過している場合は、時針が次の時間に少し進んでいるため、分針の進行を考慮して追加の角度を計算します。これが $30 \times \dfrac{M}{60}$ です。
   - `angle_M`: 分針の角度を計算します。分針は1時間で1周 (360度) するため、M分の角度は $360 \times \dfrac{M}{60}$ となります。

2. **時針と分針の角度差**
   - `angle_diff`: 時針と分針が作る角度の絶対値を計算します。もし、この角度差が180度を超える場合、時計回りでなく逆回り（短いほうの角度）を使うため、360 - angle_diff にして最短の角度差に修正します。

3. **角度をラジアンに変換**
   - `math.radians(angle_diff)`: 三角関数を使うためには、角度をラジアン（radians）に変換します。これはPythonの `math` モジュールで行います。

4. **余弦定理で距離を計算**
   - 余弦定理を使って、針の端点間の距離を計算します。<br>
   公式は <br>$\text{distance} = \sqrt{A^2 + B^2 - 2AB \cdot \cos(\theta)}$ です。<br>
   `math.cos(angle_rad)` で角度の余弦を求めています。

### `main()` 関数
- 標準入力から `A, B, H, M` の4つの値を受け取ります。
- `calc_distance` 関数を使って計算し、その結果を表示します。

## 2. 具体例を使った解説

### 入力例
```
3 4 9 0
```
- A = 3 cm (時針の長さ)
- B = 4 cm (分針の長さ)
- H = 9 時
- M = 0 分

#### ステップ 1: 時針の角度を計算する
時針は9時なので、基準角度は $360 \times \dfrac{9}{12} = 270^\circ$ です。分は0なので、時針は9時の場所にいます。したがって、`angle_H = 270`。

#### ステップ 2: 分針の角度を計算する
分針は0分なので、分針は12時の位置にあり、angle_M = $0^\circ$ です。

#### ステップ 3: 角度差を計算する
時針と分針の角度差は $|270 - 0| = 270^\circ$ ですが、この角度は180度を超えているので、逆方向を取るために $360 - 270 = 90^\circ$ に修正します。

#### ステップ 4: 距離の計算
余弦定理を適用します。角度 $90^\circ$ をラジアンに変換すると、 $\theta = \dfrac{\pi}{2}$ です。<br>
余弦の値は $\cos(90^\circ) = 0$ なので、余弦定理の式は次のようになります：<br>
$c^2 = 3^2 + 4^2 - 2 \times 3 \times 4 \times 0 = 9 + 16 = 25$ <br>
したがって、距離 $c = \sqrt{25} = 5$ です。

### 出力
```
5.0
```

## 3. まとめ

- **余弦定理**を使って、時針と分針の端点間の距離を計算しました。
- **角度の計算**では、時針と分針の進行角度を個別に計算し、それらの角度差を求めて短いほうの角度を使いました。
- **余弦定理の適用**により、時計の2本の針が形成する三角形から距離を求めています。

これにより、任意の時刻での時針と分針の端点間の距離を正確に計算できます。

<br>
<br>

---
# 037

このコードは、2つの線分が交差または重なっているかを判定するためのものです。理解しやすいように、コードをステップごとに、また具体的な例を挙げながら説明します。

---

### 基本の流れと概念

1. **ベクトルの外積**を使って、2つの線分が交差しているかどうかを判断します。
2. **平行かつ同一直線上**にある場合は、2つの線分が重なっているかどうかを確認します。

---

### 例とともにコードを解説

#### 例

- **線分AB**: A(1, 1) と B(5, 5)
- **線分CD**: C(3, 3) と D(6, 6)

この例では、2つの線分は同一直線上にあるため、**重なっているかどうかの確認が必要**です。

#### コード詳細

---

### 1. `cross_product`関数：ベクトルの外積

```python
def cross_product(x1, y1, x2, y2):
    return x1 * y2 - x2 * y1
```

**外積の考え方**
2つのベクトルの「外積」を使うと、ベクトルがどの方向に向いているかが分かります。例えば、2つのベクトルの外積が0であれば、これらは**平行**、もしくは**同一直線上**にあることを示します。

- **計算方法**: ベクトル (x1, y1) と (x2, y2) の外積は、`x1 * y2 - x2 * y1` です。
- **例**: ベクトル AB = (4, 4) とベクトル AC = (2, 2) の外積は `4 * 2 - 4 * 2 = 0` なので平行。

---

### 2. `vector`関数：2点間のベクトルを計算

```python
def vector(a, b):
    return b[0] - a[0], b[1] - a[1]
```

**役割**: 2つの点の座標 (a, b) を引き算してベクトルを計算します。

- **例**: 点 A(1, 1) と点 B(5, 5) の間のベクトルは (4, 4) です。

---

### 3. `are_segments_overlapping`関数：線分の重なり判定

```python
def are_segments_overlapping(A, B, C, D):
    overlap_x = max(A[0], C[0]) <= min(B[0], D[0])
    overlap_y = max(A[1], C[1]) <= min(B[1], D[1])
    return overlap_x and overlap_y
```

**役割**: 同一直線上にある場合、2つの線分がx軸およびy軸方向で**重なっているか**を判定します。

- **例**: A(1, 1), B(5, 5), C(3, 3), D(6, 6) の場合、
  - x座標の範囲は [1, 5] と [3, 6] なので重なりあり。
  - y座標の範囲も同じく重なりあり。

---

### 4. `main`関数：判定のメイン部分

```python
def main():
    A = read_point()
    B = read_point()
    C = read_point()
    D = read_point()
```

#### ベクトルと外積の計算

```python
    AB = vector(A, B)
    AC = vector(A, C)
    AD = vector(A, D)
    CD = vector(C, D)
    CA = vector(C, A)
    CB = vector(C, B)

    cp_ABAC = cross_product(*AB, *AC)
    cp_ABAD = cross_product(*AB, *AD)
    cp_CDCA = cross_product(*CD, *CA)
    cp_CDCB = cross_product(*CD, *CB)
```

1. **AB, AC, AD** などのベクトルを計算。
2. 外積 `cp_ABAC`、`cp_ABAD`、`cp_CDCA`、`cp_CDCB` を計算します。

これで、線分が**平行**か**交差**しているかの判定ができるようになります。

---

#### 線分の端点の大小関係の調整

```python
    if A > B:
        A, B = B, A
    if C > D:
        C, D = D, C
```

端点の順番を入れ替え、各線分の始点が常に小さくなるようにしています。これで、重なり判定が正確になります。

---

#### 交差・重なり判定

```python
    if cp_ABAC == 0 and cp_ABAD == 0 and cp_CDCA == 0 and cp_CDCB == 0:
        if are_segments_overlapping(A, B, C, D):
            print('Yes')
        else:
            print('No')
    else:
        if cp_ABAC * cp_ABAD <= 0 and cp_CDCA * cp_CDCB <= 0:
            print('Yes')
        else:
            print('No')
```

1. **平行判定** (`cp_ABAC == 0` などが0の場合):
    - 平行な場合は `are_segments_overlapping` 関数で重なりの有無を確認し、重なっていれば `Yes` を返します。
2. **交差判定** (外積の積が負か0の場合):
    - 交差していれば `Yes`、していなければ `No`。

---

### 最後に

このコードは、外積を使って線分が交差しているか判定し、平行な場合はx軸・y軸の範囲が重なっているかで判定します。このアプローチにより、2つの線分が**交差または重なっている場合のみ** `Yes` を返す設計になっています。

---

### [補足] `are_segments_overlapping`関数の目的

この関数の目的は、2つの線分が重なっているかどうかを判定することです。具体的には、2つの線分の端点がそれぞれの範囲内に収まるかどうかをチェックします。

#### 関数の定義

```python
def are_segments_overlapping(A, B, C, D):
    """2つの線分が重なっているかどうかを判定する

    Args:
        A, B: 1つ目の線分の端点の座標
        C, D: 2つ目の線分の端点の座標

    Returns:
        bool: 重なっている場合True、そうでない場合False
    """
```

- **引数**:
  - `A`: 1つ目の線分の端点
  - `B`: 1つ目の線分の端点
  - `C`: 2つ目の線分の端点
  - `D`: 2つ目の線分の端点

- **戻り値**:
  - 重なっている場合は `True`、そうでない場合は `False` を返します。

---

### 重なり判定のための範囲の計算

#### コードの説明

```python
    overlap_x = max(A[0], C[0]) <= min(B[0], D[0])
    overlap_y = max(A[1], C[1]) <= min(B[1], D[1])
```

ここでのポイントは、`max` と `min` を使って線分の範囲を決定するところです。

1. **x座標の重なり判定**:
    - `max(A[0], C[0])`: 1つ目の線分の左端 (`A[0]`) と、2つ目の線分の左端 (`C[0]`) のうち、大きい方を取ります。これは、両方の線分が重なるためには、少なくとも片方の始点が大きいことを確認するためです。
    - `min(B[0], D[0])`: 1つ目の線分の右端 (`B[0]`) と、2つ目の線分の右端 (`D[0]`) のうち、小さい方を取ります。これは、どちらかの線分の終点が、もう片方の線分の始点よりも右にある場合は重ならないためです。
    - これにより、`max(A[0], C[0]) <= min(B[0], D[0])` が成り立てば、x軸に沿って重なっていることがわかります。

2. **y座標の重なり判定**:
    - 同様に、y座標についても `max` と `min` を使用します。
    - `max(A[1], C[1])`: 1つ目の線分の下端と、2つ目の線分の下端のうちの大きい方を取ります。
    - `min(B[1], D[1])`: 1つ目の線分の上端と、2つ目の線分の上端のうちの小さい方を取ります。
    - ここでも、`max(A[1], C[1]) <= min(B[1], D[1])` が成り立てば、y軸に沿っても重なっていることがわかります。

---

### 重なり判定の結果を返す

```python
    return overlap_x and overlap_y
```

- ここで、x座標の重なりがあり、かつy座標の重なりがある場合のみ `True` を返します。つまり、両方の条件が満たされて初めて線分が重なっていると言えます。

### 例で考えてみよう

#### 例1: 重なりがある場合

- **線分AB**: A(1, 1), B(4, 4)
- **線分CD**: C(2, 2), D(3, 3)

- x座標:
  - `max(1, 2) = 2`  （Aの始点とCの始点のうち大きい方）
  - `min(4, 3) = 3`  （Bの終点とDの終点のうち小さい方）
  - `2 <= 3` → **重なりあり**

- y座標:
  - `max(1, 2) = 2`
  - `min(4, 3) = 3`
  - `2 <= 3` → **重なりあり**

両方で重なりがあるので、`are_segments_overlapping` は `True` を返します。

---

#### 例2: 重なりがない場合

- **線分AB**: A(1, 1), B(2, 2)
- **線分CD**: C(3, 3), D(4, 4)

- x座標:
  - `max(1, 3) = 3`
  - `min(2, 4) = 2`
  - `3 <= 2` → **重なりなし**

この場合、x座標の重なりがないので、関数は `False` を返します。

---

### まとめ

`are_segments_overlapping` 関数は、2つの線分が重なっているかどうかを判断するために、各線分の端点を使ってその範囲を求めます。`max` と `min` の使い方を通じて、両方の線分がどのように交差しているのかを確認し、結果を返します。これにより、非常に効率的に重なりを判定できるのです。


<br>
<br>

---
# 038

このコードは、遊園地の来場者数を特定の日数の範囲で計算する問題を解いています。各日ごとの来場者数をもとに、累積和を使って効率よく範囲の合計を求めるという流れです。


### 関数の説明

#### 1. `calc_cumulative_sum(N, A)`:
```python
def calc_cumulative_sum(N, A):
    calmulative_sum = [0] * (N+1)
    for i in range(N):
        calmulative_sum[i+1] = calmulative_sum[i] + A[i]
    return calmulative_sum
```
- **目的**: `A` というリストに含まれる日ごとの来場者数から累積和を計算します。
- **引数**:
  - `N`: 日数の合計。リスト `A` の長さに対応しています。
  - `A`: 各日の来場者数が格納されたリストです。
- **処理内容**:
  - 長さ `N+1` の `calmulative_sum` というリストを作成します。`calmulative_sum[i]` は、1日目から `i` 日目までの来場者数の合計です。`calmulative_sum[0]` は0で初期化されます。
  - `A` の各要素を順番に累積し、`calmulative_sum` に値を蓄積します。
- **戻り値**: 累積和を格納したリスト `calmulative_sum` を返します。

#### 2. `answer(calmulative_sum, LR)`:
```python
def answer(calmulative_sum, LR):
    for L, R in LR:
        print(calmulative_sum[R] - calmulative_sum[L-1])
```
- **目的**: クエリ（質問）ごとに、指定された範囲 `[L, R]` の来場者数の合計を計算し、出力します。
- **引数**:
  - `calmulative_sum`: 1日目から各日までの累積和が格納されたリスト。
  - `LR`: 各クエリ（質問）が格納されたリスト。各要素は `(L, R)` というタプルで、`L` 日目から `R` 日目までの合計を求める範囲です。
- **処理内容**:
  - 各 `L, R` について、`calmulative_sum[R] - calmulative_sum[L-1]` で範囲の合計来場者数を計算し、それを出力します。

#### 3. `main()`:
```python
def main():
    N, Q = map(int, input().split())
    A = list(map(int, input().split()))
    LR = [tuple(map(int, input().split())) for _ in range(Q)]
    calmulative_sum = calc_cumulative_sum(N, A)
    answer(calmulative_sum, LR)
```

- **目的**: 入力を受け取り、クエリごとに答えを求めます。
- **処理内容**:
  - `N` と `Q` を入力から読み取り、`A` に来場者数リストを格納します。
  - 各クエリ（質問）を `LR` というリストに格納し、`calc_cumulative_sum()` を使って累積和を計算します。
  - `answer()` を呼び出し、クエリに答えます。

### 具体例での説明

#### 入力例
```
10 5
8 6 9 1 2 1 10 100 1000 10000
2 3
1 4
3 9
6 8
1 10
```

#### ステップ 1: 累積和の計算
入力として、来場者数リスト `A = [8, 6, 9, 1, 2, 1, 10, 100, 1000, 10000]` を受け取ります。

`calc_cumulative_sum(N, A)` では、累積和を次のように計算します。

| `i`  | `A[i]` | `calmulative_sum[i+1]` (1日目からi日目までの合計) |
|------|--------|--------------------------------------------------|
| 0    | 8      | 8                                                |
| 1    | 6      | 14                                               |
| 2    | 9      | 23                                               |
| 3    | 1      | 24                                               |
| 4    | 2      | 26                                               |
| 5    | 1      | 27                                               |
| 6    | 10     | 37                                               |
| 7    | 100    | 137                                              |
| 8    | 1000   | 1137                                              |
| 9    | 10000  | 11137                                             |

最終的に、`calmulative_sum` は次のようになります：
```
calmulative_sum = [0, 8, 14, 23, 24, 26, 27, 37, 137, 1137, 11137]
```

#### ステップ 2: クエリの処理
クエリは5つあります。`answer()` 関数で順に処理します。

1. **クエリ (2, 3)**:
   - 範囲 2日目から3日目の合計を求めます。
   - 計算: `calmulative_sum[3] - calmulative_sum[1] = 23 - 8 = 15`
   - 結果: 15

2. **クエリ (1, 4)**:
   - 範囲 1日目から4日目の合計を求めます。
   - 計算: `calmulative_sum[4] - calmulative_sum[0] = 24 - 0 = 24`
   - 結果: 24

3. **クエリ (3, 9)**:
   - 範囲 3日目から9日目の合計を求めます。
   - 計算: `calmulative_sum[9] - calmulative_sum[2] = 1137 - 14 = 1123`
   - 結果: 1123

4. **クエリ (6, 8)**:
   - 範囲 6日目から8日目の合計を求めます。
   - 計算: `calmulative_sum[8] - calmulative_sum[5] = 137 - 26 = 111`
   - 結果: 111

5. **クエリ (1, 10)**:
   - 範囲 1日目から10日目の合計を求めます。
   - 計算: `calmulative_sum[10] - calmulative_sum[0] = 11137 - 0 = 11137`
   - 結果: 11137

#### 最終出力
```
15
24
1123
111
11137
```

### ポイント
1. **累積和の利点**: 逐一、範囲の合計を計算するのは時間がかかりますが、累積和を使うことで効率よく計算できます。`S[R] - S[L-1]` という形で、事前に計算した和を再利用するため、クエリごとの処理が高速です。
2. **リストの1-indexing**: `calmulative_sum` のリストは0番目を使わず、1番目からN番目を扱うように設計しています。これにより、日数とリストのインデックスが一致し、理解しやすくなっています。

<br>
<br>

---
# 039

## 雪合戦の準備は万端？ALGO国の積雪予想をPythonで解読！

ALGO国では、雪合戦大会が間近に迫っています！しかし、国土全体に均一に雪が降るとは限りません。そこで、気象予報士が出してくれた積雪予想を元に、各区画の積雪量を比較し、雪合戦に最適な場所を見つけ出しましょう！

### 🍰 ステップ１：問題を分かりやすく整理しよう！

ALGO国は西から東に一直線に並んだ **N個** の区画に分かれています。これから **Q日間** 雪が降り続け、日ごとに積雪量が変化します。

例えば、5つの区画があり、3日間の積雪予想が以下のようになっているとします。

| 日 | 区間 | 積雪増加量 |
|---|---|---|
| 1日目 | 区画1-2 | 3cm |
| 2日目 | 区画2-5 | 4cm |
| 3日目 | 区画2-4 | 1cm |

最終的に、各区画の積雪量がどのように変化するか、プログラムを使って計算してみましょう！

### 💻 ステップ２：プログラムの中身を詳しく見てみよう！

#### 2.1 `calc_cumulative_sum`関数：日々の積雪変化を記録しよう！

```python
def calc_cumulative_sum(N, items):
    cumulative_sum = [0] * (N+1)
    for L, R, X in items:
        cumulative_sum[L-1] += X
        cumulative_sum[R] -= X
        print(cumulative_sum)  # 動作確認用
    return cumulative_sum
```

この関数は、日々の積雪量の増減を記録し、最終的な積雪量を計算するための準備をします。

- `N` は区画の数、 `items` は各日ごとの積雪情報(`L`, `R`, `X`)のリストです。
- `cumulative_sum` は、各区画における積雪量の**変化** を記録するリストです。最初は全て `0` で初期化されます。
- `for L, R, X in items:` のループで、日々の積雪情報を一つずつ処理していきます。
    - `cumulative_sum[L-1] += X`: 区間 `[L, R]` の開始地点 `L` の区画から、積雪量 `X` が増加するので、`cumulative_sum[L-1]` に `X` を加算します。
    - `cumulative_sum[R] -= X`: 区間 `[L, R]` の終了地点 `R` の**次の区画**から、積雪量 `X` の増加はなくなるので、`cumulative_sum[R]` から `X` を減算します。

#### 例：3日間の積雪変化を `cumulative_sum` に記録する

| 日 | 区間 | 積雪増加量 | `cumulative_sum` の変化 | `cumulative_sum` |
|---|---|---|---|---|
| 初期状態 |  |  |  | `[0, 0, 0, 0, 0, 0]` |
| 1日目 | 区画1-2 | 3cm | `cumulative_sum[0] += 3`, `cumulative_sum[2] -= 3` | `[3, 0, -3, 0, 0, 0]` |
| 2日目 | 区画2-5 | 4cm | `cumulative_sum[1] += 4`, `cumulative_sum[5] -= 4` | `[3, 4, -3, 0, 0, -4]` |
| 3日目 | 区画2-4 | 1cm | `cumulative_sum[1] += 1`, `cumulative_sum[4] -= 1` | `[3, 5, -3, 0, -1, -4]` |

このように、`cumulative_sum` には、各区画における最終的な積雪量を計算するための情報が記録されます。

#### 2.2 `output`関数：積雪量の大小を記号で表そう！

```python
def output(N, cumulative_sum):
    res = []
    for i in range(1, N):
        if cumulative_sum[i] > 0:
            res.append('<')
        elif cumulative_sum[i] == 0:
            res.append('=')
        else:
            res.append('>')
    return res
```

この関数は、`calc_cumulative_sum`関数で計算した結果をもとに、隣接する区画の積雪量の大小関係を、"<"、"="、">" の記号で表現します。

- `N` は区画の数、`cumulative_sum` は `calc_cumulative_sum` 関数から受け取ったリストです。
- `for i in range(1, N):` のループで、区画 `i` と区画 `i+1` の積雪量を比較します。
- `cumulative_sum` に記録されているのは、各区画における積雪量の**変化** であることに注意が必要です。
    - `cumulative_sum[i] > 0` の場合、区画 `i+1` の積雪量は区画 `i` より **少ない** ことを意味するので、 `<` を `res` に追加します。
    - `cumulative_sum[i] == 0` の場合、区画 `i+1` の積雪量は区画 `i` と **等しい** ことを意味するので、 `=` を `res` に追加します。
    - `cumulative_sum[i] < 0` の場合、区画 `i+1` の積雪量は区画 `i` より **多い** ことを意味するので、 `>` を `res` に追加します。

#### 例：`cumulative_sum` から積雪量の大小関係を記号で表す

先ほどの例では、`cumulative_sum` は最終的に `[3, 5, -3, 0, -1, -4]` となりました。これを `output` 関数に渡すと、以下のように処理されます。

| i | `cumulative_sum[i]` | 区画 i と i+1 の関係 | `res` |
|---|---|---|---|
| 1 | 5 | 区画2 の方が区画1より積雪量が多い | `<` |
| 2 | -3 | 区画3 の方が区画2より積雪量が少ない | `>` |
| 3 | 0 | 区画4 の積雪量は区画3 と等しい | `=` |
| 4 | -1 | 区画5 の方が区画4より積雪量が多い | `>` |

最終的に、`res` は `['<', '>', '=', '>']` となり、これを結合した `<>=>` が出力されます。

### 🎉 ステップ３：雪合戦に最適な場所を見つけよう！

プログラムを実行すると、最終的な各区画の積雪量の大小関係が分かりやすく表示されます。
この情報をもとに、雪合戦に最適な場所、つまり積雪量の多い場所を選んで、熱戦を繰り広げましょう！

<br>
<br>

---
# 040

## コードの解説

このコードは、ALGO鉄道の駅間距離と太郎君の訪問駅リストから、総移動距離を計算するプログラムです。

### 関数 `calc_total_distance(A, M, B)`
```python
def calc_total_distance(A, M, B):
    dist = 0
    for i in range(M-1):
        start, end = B[i]-1, B[i+1]-1
        if start < end:
            dist += sum(A[start:end])
        else:
            dist += sum(A[end:start])
    return dist
```


この関数は、駅間距離リスト`A`、訪問駅数`M`、訪問駅リスト`B`を受け取り、総移動距離を計算して返します。

1. **初期化:** `dist = 0` で、総移動距離を初期化します。

2. **訪問駅間のループ:** `for i in range(M-1):` で、訪問駅間の移動を計算するためにループします。

    - `start, end = B[i]-1, B[i+1]-1`:  訪問駅リスト`B`から、現在(`i`)と次の(`i+1`)駅のインデックスを取得します。リストのインデックスは0から始まるため、駅番号から1を引いています。

    - **移動方向の判定:** `if start < end:` で、西から東へ向かう移動かどうかを判定します。

        - **西から東への移動:** `dist += sum(A[start:end])`: `A[start:end]` で、`start`駅（含まれる）から`end`駅（含まれない）までの駅間距離リストを取得し、その合計を`dist`に加算します。

        - **東から西への移動:** `dist += sum(A[end:start])`: 東から西への移動の場合は、`end`駅（含まれる）から`start`駅（含まれない）までの駅間距離リストを取得し、その合計を`dist`に加算します。

3. **総移動距離の返却:** すべての訪問駅間の移動距離を計算したら、`return dist`で総移動距離を返します。

### 関数 `main()`

```python
def main():
    N = int(input())
    A = list(map(int, input().split()))
    M = int(input())
    B = [int(input()) for _ in range(M)]
    print(calc_total_distance(A, M, B))
```


この関数は、プログラムのメイン処理を行います。

1. **入力の受け取り:**
   - `N = int(input())`: 駅の数`N`を入力します。
   - `A = list(map(int, input().split()))`: 駅間距離リスト`A`を入力します。
   - `M = int(input())`: 訪問駅数`M`を入力します。
   - `B = [int(input()) for _ in range(M)]`: 訪問駅リスト`B`を入力します。

2. **総移動距離の計算と出力:** `print(calc_total_distance(A, M, B))` で、`calc_total_distance`関数を呼び出して総移動距離を計算し、結果を出力します。


### `if __name__ == "__main__":`

この部分は、このPythonファイルが直接実行された場合にのみ、`main()`関数が実行されるようにするための記述です。

## 事例を使った処理過程の説明

入力例1を例に、処理過程を説明します。

**入力例1**
```
4
8 6 9
6
2
1
3
2
3
4
```

1. **入力の受け取り:**
   - `N = 4`
   - `A = [8, 6, 9]`
   - `M = 6`
   - `B = [2, 1, 3, 2, 3, 4]`

2. **`calc_total_distance`関数の実行:**

   - `dist = 0` で初期化

   - **1回目のループ (i=0):**
     - `start = 1`, `end = 0` (B[0]=2, B[1]=1)
     - `start > end` なので、東から西への移動
     - `dist += sum(A[0:1]) = 8` (駅1から駅2の距離)

   - **2回目のループ (i=1):**
     - `start = 0`, `end = 2` (B[1]=1, B[2]=3)
     - `start < end` なので、西から東への移動
     - `dist += sum(A[0:2]) = 14` (駅1から駅3の距離)

   - **3回目のループ (i=2):**
     - `start = 2`, `end = 1` (B[2]=3, B[3]=2)
     - `start > end` なので、東から西への移動
     - `dist += sum(A[1:2]) = 6` (駅3から駅2の距離)

   - **4回目のループ (i=3):**
     - `start = 1`, `end = 2` (B[3]=2, B[4]=3)
     - `start < end` なので、西から東への移動
     - `dist += sum(A[1:2]) = 6` (駅2から駅3の距離)

   - **5回目のループ (i=4):**
     - `start = 2`, `end = 3` (B[4]=3, B[5]=4)
     - `start < end` なので、西から東への移動
     - `dist += sum(A[2:3]) = 9` (駅3から駅4の距離)

   - 最終的に `dist = 43` となり、これが総移動距離として出力されます。

    [ref] log
    ```
    ===================== i : 0
    start : 1
    end   : 0
    sum(A[0:1]) : 8
    distance    : 8
    ===================== i : 1
    start : 0
    end   : 2
    sum(A[0:2]) : 14
    distance    : 22
    ===================== i : 2
    start : 2
    end   : 1
    sum(A[1:2]) : 6
    distance    : 28
    ===================== i : 3
    start : 1
    end   : 2
    sum(A[1:2]) : 6
    distance    : 34
    ===================== i : 4
    start : 2
    end   : 3
    sum(A[2:3]) : 9
    distance    : 43
    ```

このように、このプログラムは訪問駅リストに基づいて駅間の移動をシミュレートし、総移動距離を計算します。

<br>
<br>

---
# 041

このコードは、imos法と呼ばれるアルゴリズムを使って、各時刻にコンビニにいる従業員数を効率的に計算しています。imos法は、累積和を利用して区間への加算を高速に行うテクニックです。

```python
def count_employees(T, LR):
    cnt = [0] * (T+1)
    for L, R in LR:
        cnt[L] += 1
        cnt[R] -= 1
    return cnt

def output(T, cnt):
    res = 0
    for i in range(T):
        res += cnt[i]
        print(res)

def main():
    T = int(input())
    N = int(input())
    LR = [list(map(int, input().split())) for _ in range(N)]
    cnt = count_employees(T, LR)
    output(T, cnt)

if __name__ == "__main__":
    main()
```

**例を用いた解説**

T = 10, N = 3 で、従業員の出退勤が以下のようになっているとします。

* 従業員1: 1時出勤、4時退勤
* 従業員2: 2時出勤、3時退勤
* 従業員3: 0時出勤、5時退勤


**1. `count_employees(T, LR)` 関数**

この関数は、各時刻における従業員数の変化量を計算します。

* `cnt = [0] * (T+1)`:  時刻 0 から T までの従業員数の変化量を格納するリスト `cnt` を初期化します。最初は全て0です。`T+1` としているのは、時刻 T に退勤する従業員を扱うためです。

* `for L, R in LR:`: 各従業員のデータについてループを回します。

    * `cnt[L] += 1`: 出勤時刻 `L` における従業員数の変化量に +1 を加えます。出勤すると従業員数が1人増えるためです。
    * `cnt[R] -= 1`: 退勤時刻 `R` における従業員数の変化量に -1 を加えます。退勤すると従業員数が1人減るためです。

上記の例では、`cnt` は以下のようになります。

```
初期状態: cnt = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

従業員1: cnt = [0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 0]  (1時 +1, 4時 -1)
従業員2: cnt = [0, 1, 1, -1, -1, 0, 0, 0, 0, 0, 0]  (2時 +1, 3時 -1)
従業員3: cnt = [1, 1, 1, -1, -1, -1, 0, 0, 0, 0, 0]  (0時 +1, 5時 -1)
```

**2. `output(T, cnt)` 関数**

この関数は、`cnt` を利用して各時刻の従業員数を計算し、出力します。

* `res = 0`: 時刻 0 での従業員数を初期化します。

* `for i in range(T):`: 時刻 0 から T-1 までループを回します。

    * `res += cnt[i]`:  `cnt[i]` (時刻 i での従業員数の変化量) を `res` に加算します。これで、時刻 i での従業員数が計算できます。
    * `print(res)`: 時刻 i での従業員数 `res` を出力します。

上記の例では、以下のように計算されます。

```
時刻0: res = 0 + 1 = 1  出力: 1
時刻1: res = 1 + 1 = 2  出力: 2
時刻2: res = 2 + 1 = 3  出力: 3
時刻3: res = 3 - 1 = 2  出力: 2
時刻4: res = 2 - 1 = 1  出力: 1
時刻5: res = 1 - 1 = 0  出力: 0
時刻6: res = 0 + 0 = 0  出力: 0
時刻7: res = 0 + 0 = 0  出力: 0
時刻8: res = 0 + 0 = 0  出力: 0
時刻9: res = 0 + 0 = 0  出力: 0
```


**数学的な説明 (imos法)**

imos法は、区間への加算操作を累積和を使って効率的に行うアルゴリズムです。

区間 [L, R) に値 x を加算したい場合、`cnt[L] += x`、`cnt[R] -= x` とします。

その後、`cnt` の累積和を計算することで、各時刻における値を求めることができます。

累積和 `S[i]` は `S[i] = cnt[0] + cnt[1] + ... + cnt[i]` で計算されます。

`S[i]` は、時刻 i までの全ての変化量の合計を表します。つまり、時刻 i での従業員数となります。

**なぜこの方法が高速なのか？**

N 人の従業員がいる場合、単純な方法では各時刻ごとに N 人の従業員のデータをチェックする必要があります。そのため、計算量は O(NT) になります。

一方、imos法では、従業員ごとに2回の操作 (出勤時と退勤時) しか行いません。そのため、計算量は O(N + T) となり、大幅に高速化されます。



この解説が、コードの理解に役立つことを願っています。

<br>
<br>

---
# 042

このコードの目的は、与えられた正整数 `N` までのすべての整数 `K` に対して、`K × f(K)` の総和を効率的に求めることです。この問題の背景には、**整数の約数**に関する数学的な性質があり、それを活用して高速に計算を行っています。

コードを詳しく解説しながら、例を使って処理の流れをわかりやすく説明します。

---

## 基本的な考え方

まず、問題の焦点は「正の整数 `K` に対して `K × f(K)` の総和を計算する」ことです。`f(K)` は、`K` の正の約数の個数です。

### 例1: `N = 4` の場合

`f(1) = 1` (1の約数は1)
`f(2) = 2` (2の約数は1, 2)
`f(3) = 2` (3の約数は1, 3)
`f(4) = 3` (4の約数は1, 2, 4)

したがって、求めたい総和は次のようになります:

$1 \times 1 + 2 \times 2 + 3 \times 2 + 4 \times 3 = 23$

しかし、`N` が非常に大きい場合（例えば `N = 10^7` など）、このような直接的な計算では遅すぎるので、約数に関する数学的な性質を利用して高速に計算します。

---

## コードの詳細な解説

### 1. 和の公式 (`f(x)`)
```python
def f(x):
    return x * (x + 1) // 2
```

`f(x)` は、**1から `x` までの整数の総和**を計算する関数です。この関数は、次の数学的な公式に基づいています：

$1 + 2 + 3 + \cdots + x = \dfrac{x \times (x + 1)}{2}$ \]

例えば：

- `f(3)` の場合：`1 + 2 + 3 = 6` となり、これは公式に当てはめると次のように計算されます：

$$f(3) = \dfrac{3 \times (3 + 1)}{2} = \frac{3 \times 4}{2} = 6$$

- `f(5)` の場合：`1 + 2 + 3 + 4 + 5 = 15` となります。同様に：

$$f(5) = \dfrac{5 \times (5 + 1)}{2} = \frac{5 \times 6}{2} = 15$$

---

### 2. 約数の和を効率的に計算する (`sum_of_divisors`)
```python
def sum_of_divisors(N):
    res = 0
    for i in range(1, int(N**0.5)+1):
        res += i * i + 2 * i * (f(N//i) - f(i))
    return res
```

この関数では、`1` から `N` までの整数 `K` について、`K × f(K)` の総和を計算しています。以下では、この関数がどのように高速に計算しているかを見ていきます。

#### i のループ範囲

ループの範囲は `i` を `1` から `√N` までに制限しています。なぜかというと、ある数 `K` の約数は対になって現れるからです。例えば、`36` の約数を考えると、次のような対があります：

- 1と36
- 2と18
- 3と12
- 6と6

約数の小さい方を順に見ていけば、大きい方も同時に見つけられるため、`√N` まで調べるだけで済みます。

#### `res += i * i`

これは、`i` が自分自身の倍数である（つまり、`i * i` が約数となる）場合の特別な処理です。完全平方数の時に必要です。例えば、`i = 2` であれば、`2 * 2 = 4` で、`4` 自身が `2` の倍数です。

#### `2 * i * (f(N//i) - f(i))`

この部分は、`i` の倍数を効率的に処理しています。`N // i` は `i` の倍数の最大値です。たとえば `N = 100` の場合、`i = 2` だと `100 // 2 = 50` なので、`2` の倍数は `2, 4, 6, ..., 50` となります。

`f(N // i)` で、`i` の倍数の総和を計算し、`f(i)` を引くことで、`i` 自身を除いた倍数に対応する和を取得しています。

#### 例：`N = 10` の場合

`N = 10` の場合を例に処理を追ってみましょう。

1. `i = 1`
   - `f(N // i) = f(10) = 1 + 2 + ... + 10 = 55`
   - `f(i) = f(1) = 1`
   - 計算する式は `1 * 1 + 2 * 1 * (55 - 1) = 1 + 108 = 109`

2. `i = 2`
   - `f(N // i) = f(5) = 1 + 2 + 3 + 4 + 5 = 15`
   - `f(i) = f(2) = 1 + 2 = 3`
   - 計算する式は `2 * 2 + 2 * 2 * (15 - 3) = 4 + 48 = 52`

3. `i = 3`
   - `f(N // i) = f(3) = 1 + 2 + 3 = 6`
   - `f(i) = f(3) = 6`
   - 計算する式は `3 * 3 + 2 * 3 * (6 - 6) = 9 + 0 = 9`

最終的な結果として、`res = 109 + 52 + 9 = 170` となります。

---

### 計算量の詳細
このコードは、`N` の平方根までの範囲でループを回しています（`O(√N)`）。ループ内の各操作は一定時間（`O(1)`）で実行されるため、全体としての計算量は **`O(√N)`** です。これにより、`N` が非常に大きくても効率的に計算できます。

---

## まとめ

このコードは、数の約数に関する性質を巧妙に利用して、計算量を `O(√N)` に抑えることで高速に結果を求めています。特に大きな `N` に対しても効率的に動作します。

<br>

## [補足] `i * i + 2 * i * (f(N//i) - f(i))` という式の意味

`i * i + 2 * i * (f(N//i) - f(i))` という式の意味について、より詳細に説明します。

この式は、**整数 `N` に対して、その約数 `i` を効率的に扱う**ための工夫が含まれています。ここでは、この式が何を意味しているのかを、具体的な事例を用いて説明していきます。

---

### 背景：整数の約数と和の計算

まず、この問題では、`1` から `N` までのすべての整数 `K` に対して、`K × f(K)` の総和を求めています。ここで、`f(K)` は、`K` の正の約数の個数を表します。

直接的に `K` ごとに計算していくと非常に時間がかかりますが、整数の約数に関する数学的性質を使うことで、効率化が可能です。

#### ポイント

`K` の約数 `i` を見つけるとき、`i` とその倍数 `i * k` も同時に扱います。これによって、全体を効率的に計算できます。

---

### 式の分解と理解

式全体 `i * i + 2 * i * (f(N//i) - f(i))` は、**2つの部分**から成り立っています。それぞれを分解して見ていきましょう。

#### 1. `i * i` の部分

この部分は、`i` 自身が `N` の約数である場合に対応しています。つまり、`i` が `N` の約数のとき、その約数に対して `i × i` を加える必要があります。

- 例：`N = 36` の場合、`i = 6` のとき、`6 × 6 = 36` であるため、この値を加算します。

#### 2. `2 * i * (f(N // i) - f(i))` の部分

この部分は、`i` の倍数に対応しています。`N // i` は `i` の倍数のうち、`N` 以下の最大の倍数を表します。

例えば、`N = 36` で `i = 6` のとき、`N // i = 36 // 6 = 6` になります。`6` の倍数は `6, 12, 18, 24, 30, 36` です。

##### `f(N // i)` とは？

`f(N // i)` は、`1` から `N // i` までの整数の総和を表します。つまり、`i` の倍数を含む総和です。

##### `f(i)` とは？

`f(i)` は、`1` から `i` までの整数の総和を表します。`i` の倍数の中で最小の値である `i` 自身を含むため、それを差し引きます。

##### なぜ `2 * i` ？

ここで `2 * i` が使われるのは、`i` の倍数である数値すべてに対して、この操作を行う必要があるためです。倍数全体に対して、`i` を掛けた分を2倍にして計算します。

---

### 具体的な事例での理解

例えば、`N = 36` で `i = 6` の場合を考えてみましょう。

1. `i * i = 6 * 6 = 36`

   - これは、`6` 自身が約数であることに対応して加算しています。

2. `f(N // i) = f(36 // 6) = f(6) = 1 + 2 + 3 + 4 + 5 + 6 = 21`

3. `f(i) = f(6) = 1 + 2 + 3 + 4 + 5 + 6 = 21`

   - `i` 自身を含む部分を引くため、この場合、`f(N // i) - f(i) = 21 - 21 = 0` になります。

この場合、式の結果は次のようになります：

$$i * i + 2 * i * (f(N // i) - f(i)) = 6 * 6 + 2 * 6 * (21 - 21) = 36 + 0 = 36$$

これが `N = 36` で `i = 6` の場合の計算結果です。

---

### 別の例: `N = 36` で `i = 2`

次に、`i = 2` の場合を見てみましょう。

1. `i * i = 2 * 2 = 4`

2. `f(N // i) = f(36 // 2) = f(18) = 1 + 2 + 3 + ... + 18 = 171`

3. `f(i) = f(2) = 1 + 2 = 3`

この場合、`f(N // i) - f(i) = 171 - 3 = 168` です。

したがって、式は次のように計算されます：

$i * i + 2 * i * (f(N // i) - f(i)) = 2 * 2 + 2 * 2 * 168 = 4 + 672 = 676$

このようにして、`N = 36` に対して `i = 2` の倍数に関連する計算結果が得られます。

---

### 結論

`i * i + 2 * i * (f(N//i) - f(i))` という式は、`i` の倍数に関連するすべての数値を効率的に計算するための式です。`i` 自身が約数である部分と、その倍数に対する計算を同時に処理しています。

このアプローチは、`N` が大きい場合でも効率的に計算できる方法であり、各 `i` に対して必要な計算を最小限に抑えるために工夫されています。


<br>
<br>

---
# 043

### 部活ネットワーク！全員と繋がれるか！？ Pythonコードで徹底解説！

今度は、部活のメンバーを例に、「ある人からメッセージを伝言していくと全員に届くか」を判定するプログラムを解説します！

### 部活メンバーの関係をグラフで表す！

例えば、部員が5人 (Aさん～Eさん)いて、以下の様な関係だったとします。

- Aさん - Bさん, Cさん
- Bさん - Aさん, Dさん
- Cさん - Aさん
- Dさん - Bさん
- Eさん - (無し)

Eさんは、誰も知らない状態です。これを図にすると、こんな感じ！

```
     A
   /   \
  B     C
 /
D

E
```

この図の、
- Aさん、Bさん...を「頂点」
- メンバー同士の関係を「辺」
と呼びます。

### コード解説：伝言ゲームで全員に届け！

**1. 関係リストを作る！( `is_connected` 関数 )**

```python
def is_connected(N, edges):
    graph = [[] for _ in range(N)]  # 空の関係リストを人数分用意
    for a, b in edges:
        graph[a-1].append(b-1)  # aさんと関係がある人を登録
        graph[b-1].append(a-1)  # bさんと関係がある人を登録
    return dfs(graph, N)
```

- `N`: 部員の人数 (今回の例では5人)
- `edges`: メンバー同士の関係リスト (例: `[(1, 2), (1, 3), (2, 4)]`)

まず、 `graph = [[] for _ in range(N)]` で、全員分の空の関係リストを作ります。
 `[ [], [], [], [], [] ]` みたいなイメージですね！

次に、`for a, b in edges:` で、関係 `edges` を一つずつ取り出して、

- `graph[a-1].append(b-1)`: aさんと関係がある人をリストに追加
- `graph[b-1].append(a-1)`: bさんと関係がある人をリストに追加

していきます。
(Pythonでは番号は0から数えるので、`a-1` や `b-1` としています)

今回の例だと、最終的に `graph` は以下のようになります。

```python
graph = [
    [1, 2],  # Aさんと関係がある人: Bさん, Cさん
    [0, 3],  # Bさんと関係がある人: Aさん, Dさん
    [0],    # Cさんと関係がある人: Aさん
    [1],    # Dさんと関係がある人: Bさん
    []     # Eさんと関係がある人: 誰もいない！
]
```

**2. 伝言ゲームスタート！全員に届け！( `dfs` 関数 )**

```python
def dfs(graph, N):
    visited = [False] *  N  # 伝言済みリスト (最初は全員False)
    stack = [0]             # 今から伝言する人リスト (最初はAさん)
    while stack:            # 伝言する人リストが空になるまで続ける
        v = stack.pop()     # 伝言する人リストから一人取り出す
        if not visited[v]:   # もし、その人にまだ伝言していなかったら
            visited[v] = True # 伝言済みにする
            for nv in graph[v]:  # その人と関係がある人リストから一人ずつ取り出して
                stack.append(nv) # 伝言する人リストに追加する
    return all(visited)  # 全員に伝言できたならTrue、そうでなければFalseを返す
```

- `visited`: 伝言済みリスト。最初は全員 `False` で、伝言できたら `True` にしていきます。
- `stack`:  これから伝言する人を順番に入れておくリスト。

**処理の流れ:**

1. 最初はAさん( `0` )を `stack` に入れてスタート！
2. `stack` から一人取り出して (最初はAさん)、その人と関係がある人のリストを `graph` から確認
3. まだ伝言していない人がいたら、伝言済みにし、`stack` に追加します。
4. これを `stack` が空になるまで繰り返します。

**今回の例の場合:**

1. `stack = [0]` (Aさんからスタート)
2. Aさんから伝言開始 (`v=0`)。`visited[0] = True`
   - Aさんと関係があるのはBさんとCさん(`graph[0] = [1, 2]`)
   - Bさん、Cさんはまだ伝言済みではないので、`stack` に追加 -> `stack = [1, 2]`
3. `stack` から Bさんを取り出す(`v=1`)。`visited[1] = True`
   - Bさんと関係があるのはAさんとDさん(`graph[1] = [0, 3]`)
   - Aさんは既に伝言済み(`visited[0] == True`)
   - Dさんはまだ伝言済みではないので、`stack` に追加 -> `stack = [2, 3]`
4. `stack` から Cさんを取り出す(`v=2`)。`visited[2] = True`
   - Cさんと関係があるのはAさんだけ(`graph[2] = [0]`)
   - Aさんは既に伝言済み(`visited[0] == True`)
5. `stack` から Dさんを取り出す(`v=3`)。`visited[3] = True`
   - Dさんと関係があるのはBさんだけ(`graph[3] = [1]`)
   - Bさんは既に伝言済み(`visited[1] == True`)
6. `stack` が空になったので終了。`visited` を確認 -> `[True, True, True, True, False]`
7. Eさんには伝言できていないので、`all(visited)` は **`False`** を返す

[ref] log
```
*********************************** a, b : 1, 2
[[1], [0], [], [], []]
*********************************** a, b : 1, 3
[[1, 2], [0], [0], [], []]
*********************************** a, b : 2, 4
[[1, 2], [0, 3], [0], [1], []]
=============================================== v : 0
stack : []
visited[0] : False
visited : [True, False, False, False, False]
graph[0] : [1, 2]
stack : [1, 2]
=============================================== v : 2
stack : [1]
visited[2] : False
visited : [True, False, True, False, False]
graph[2] : [0]
stack : [1, 0]
=============================================== v : 0
stack : [1]
visited[0] : True
stack : [1]
=============================================== v : 1
stack : []
visited[1] : False
visited : [True, True, True, False, False]
graph[1] : [0, 3]
stack : [0, 3]
=============================================== v : 3
stack : [0]
visited[3] : False
visited : [True, True, True, True, False]
graph[3] : [1]
stack : [0, 1]
=============================================== v : 1
stack : [0]
visited[1] : True
stack : [0]
=============================================== v : 0
stack : []
visited[0] : True
stack : []
```

**3. 結果発表！( `main` 関数 )**

```python
def main():
    N, M = map(int, input().split()) # 人数と関係の数を入力
    edges = [tuple(map(int, input().split())) for _ in range(M)] # 関係を入力
    if is_connected(N, edges):
        print("The graph is connected.")  # 全員に伝言できたら
    else:
        print("The graph is not connected.") # 伝言できない人がいたら
```

- `N, M`:  部員の人数と、関係の数を入力
- `edges`:  M個の関係を `(1, 2)` のように入力

`is_connected(N, edges)` で全員に伝言できるか判定し、結果に応じてメッセージを出力します。

今回の例では、Eさんに伝言できなかったため、"The graph is not connected." となります。

## まとめ

このように、このコードでは部活メンバーの関係をグラフ構造で表現し、深さ優先探索 (DFS) を用いて全員に伝言が伝わるかを判定しています。

部活の例以外にも、友達関係やコンピュータネットワークなど、様々な場面に応用できます。ぜひ、色々試してみてください！

<br>
<br>

---
# 044

このコードは、与えられた無向グラフで頂点 1 から他のすべての頂点に到達するために必要な最小の辺の数を求めるためのものです。到達できない頂点については `-1` を出力します。ここでは、コードの各部分がどのように動作するのか、初心者でも理解しやすいように、事例を交えながら丁寧に解説します。

## 1. 全体の流れ

コードは、以下のステップで動作します：
1. グラフを入力から構築する。
2. 幅優先探索（BFS）を使用して、頂点1から各頂点までの最小の移動回数（辺の数）を計算する。
3. 結果を順番に出力する。

それでは、各部分を具体的に見ていきましょう。

---

## 2. `build_graph` 関数

### 目的：
グラフの隣接リストを作成します。これは、各頂点がどの頂点とつながっているかをリスト形式で記録するものです。

### 解説：

```python
def build_graph(N, edges):
    graph = [[] for _ in range(N+1)]
    for a, b in edges:
        graph[a].append(b)
        graph[b].append(a)
    return graph
```

- **入力**：
  - `N`: 頂点の数
  - `edges`: 辺のリスト（例: `[(1, 3), (2, 3)]`）

- **出力**：
  - 隣接リスト形式のグラフを返します。例えば、`N=3` で `edges=[(1, 3), (2, 3)]` の場合、次のようなグラフが作られます：

```python
graph = [
    [],    # 頂点0 (無視)
    [3],   # 頂点1 -> 頂点3と接続
    [3],   # 頂点2 -> 頂点3と接続
    [1, 2] # 頂点3 -> 頂点1と2に接続
]
```

- **例**：
  - 頂点 `1` と `3` がつながっているので、`graph[1]` に `3` が入ります。
  - 同様に、`graph[3]` に `1` が追加されます（無向グラフなので双方向です）。
  - これをすべての辺に対して繰り返すことで、グラフが完成します。

---

## 3. `bfs` 関数（幅優先探索）

### 目的：
頂点 `1` から他の頂点までの最短距離（最小の辺数）を計算します。幅優先探索（BFS）を用いて、各頂点までの距離を順に探索していきます。

### 解説：

```python
def bfs(N, graph):
    dist = [-1] * (N+1)
    dist[1] = 0
    queue = deque([1])

    while queue:
        v = queue.popleft()
        for nv in graph[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                queue.append(nv)
    return dist[1:]
```

- **入力**：
  - `N`: 頂点数
  - `graph`: 隣接リスト形式のグラフ

- **内部変数**：
  - `dist`: 各頂点までの最短距離を格納するリスト。`dist[i]` には頂点1から頂点 `i` までの距離が入ります。初期値は全て `-1` で、これはまだ訪問していないことを意味します。
  - `queue`: 探索待ちの頂点を保持するキュー。最初は頂点1（出発点）から探索を開始します。

### 処理の流れ：

1. **初期化**：
   - `dist[1] = 0` で、頂点1から頂点1への距離は 0 です。
   - キューに最初の頂点 `1` を入れます（`queue = deque([1])`）。

2. **幅優先探索**：
   - キューから頂点を1つ取り出し（`popleft()`）、その頂点に隣接する未訪問の頂点をすべて探索します。
   - 新しい頂点に到達したら、その頂点までの距離を計算して（1つ前の頂点までの距離 `+1`）、その頂点をキューに追加します。

3. **探索の終了**：
   - キューが空になった時点で、頂点1から各頂点への最短距離が `dist` リストに保存されている状態になります。
   - 最後に、`dist[1:]` を返します（頂点0は無視）。

### 例：
 例えば、`N=3`、`edges=[(1, 3), (2, 3)]` の場合：

1. 最初に、`dist = [-1, 0, -1, -1]` と初期化されます。キューには `1` が入ります（`queue = deque([1])`）。
2. 頂点 `1` から探索を開始し、頂点 `3` に隣接しているので、`dist[3] = 1` とし、キューに `3` を追加します。
3. 次に、頂点 `3` から隣接する頂点 `2` を探索し、`dist[2] = 2` となります。

結果として、`dist = [-1, 0, 2, 1]` が得られます。出力する際は `dist[1:]` なので、`[0, 2, 1]` が返されます。

---

## 4. `main` 関数

### 目的：
標準入力からデータを読み込み、上記の関数を使って最終的な結果を出力します。

### 解説：

```python
def main():
    N, M = map(int, input().split())
    edges = [tuple(map(int, input().split())) for _ in range(M)]
    graph = build_graph(N, edges)
    dist = bfs(N, graph)
    print(*dist, sep='\n')
```

1. **入力の取得**：
   - `N` は頂点の数、`M` は辺の数です。
   - `edges` には `M` 本の辺の情報がタプルとしてリストに格納されます（例えば、`edges=[(1, 3), (2, 3)]`）。

2. **関数の呼び出し**：
   - `build_graph(N, edges)` でグラフを作成し、`bfs(N, graph)` で頂点1から他の頂点への最短距離を計算します。

3. **結果の出力**：
   - `dist` に格納された結果を1行ずつ出力します。

---

## 5. 例を用いた全体の流れ

例えば、次の入力が与えられたとします：

```
3 2
1 3
2 3
```

1. **グラフの構築**:
   - グラフは次のようになります：
   ```
   graph = [[], [3], [3], [1, 2]]
   ```

2. **BFSの結果**：
   - 頂点1から他の頂点への距離は次のようになります：
   ```
   dist = [-1, 0, 2, 1]
   ```

3. **出力**：
   - `dist[1:] = [0, 2, 1]` が出力されます。

<br>
<br>

## [別の説明]みんな大好き！グラフ探索ゲーム！：友達の家に遊びに行く編

このコードは、君のお家の周りで「友達の家に遊びに行くゲーム」をするためのプログラムなんだ！

**ゲームのルール説明**

1. 君の街には、君の家を含めて家がいくつかあって、それぞれの家は番号で呼ばれているよ！
2. 家と家は道で繋がれているけど、すべての家が繋がっているとは限らないんだ。
3. 君は、自分の家からスタートして、友達の家に遊びに行きたいんだけど、できるだけ短い道のりで遊びに行きたいよね！

このプログラムは、君の家からそれぞれの友達の家に遊びに行くための、**最短の道のり（必要な道の数）** を教えてくれるんだ！

### プログラムの中身を見てみよう！

#### 1. `build_graph(N, edges)` 関数：街の地図を作る！

この関数は、ゲームをするための「街の地図」を作る役割をしているよ！

* **入力**
    - `N` : 街にある家の数（君の家の番号は1番だよ！）
    - `edges` : 道の情報。例えば `[(1, 2), (2, 3)]` だったら、「1番の家と2番の家」、「2番の家と3番の家」がそれぞれ道で繋がっていることを表しているよ。

* **出力**
    - `graph`: 街の地図。どの家がどの家と繋がっているかを示しているよ。

**例：**

もし、君の家を含めて家が4軒あって、道が `[(1, 2), (2, 3), (1, 4)]` のように繋がっていたとすると、 `build_graph(4, [(1, 2), (2, 3), (1, 4)])` は、以下のような「街の地図」を作るよ。

```
graph = [
    [],                 # 0番目の家は使わないので空っぽ！
    [2, 4],             # 1番の家は、2番の家と4番の家と繋がっている
    [1, 3],             # 2番の家は、1番の家と3番の家と繋がっている
    [2],                # 3番の家は、2番の家と繋がっている
    [1]                 # 4番の家は、1番の家と繋がっている
]
```

#### 2. `bfs(N, graph)` 関数：最短ルートを探検だ！

この関数は、作った「街の地図」を使って、君の家からそれぞれの友達の家まで、最短で何本の道を通れば良いか計算してくれるよ！

* **入力**
    - `N`: 街にある家の数
    - `graph`: `build_graph` 関数で作った「街の地図」

* **出力**
    - `dist[1:]`: 君の家(1番)から各家までの最短距離が入ったリスト

**例：**

上の例と同じように、家が4軒あって、`graph` が
```python
graph = [
    [],
    [2, 4],
    [1, 3],
    [2],
    [1]
]
```
だったとする。

`bfs(4, graph)` を実行すると、以下のように計算が進んでいくよ！

1. まず、君の家からスタート！ `dist = [0, -1, -1, -1]` となる。`dist[i]` は君の家から `i` 番目の家までの距離を表していて、まだ訪れていない家は `-1` となっているよ。
2. 君の家(1番)から直接行ける家(2番と4番)を調べる。2番の家と4番の家は、君の家から1本道を通れば行けるので、 `dist = [0, 1, -1, 1]` となる。
3. 次に、2番の家から直接行ける家(3番)を調べる。3番の家は、君の家から2本道を通れば行けるので、 `dist = [0, 1, 2, 1]` となる。
4. これですべての家までの最短距離がわかったね！ `bfs` 関数は、 `[1, 2, 1]` を返す。

#### 3. `main()` 関数：ゲームスタート！

この関数は、ゲームを開始して、結果を表示する役割を持っているよ。

1. `N`, `M` の入力を受け取る。
2. `edges` を受け取り、`build_graph` 関数を使って「街の地図」を作る。
3. `bfs` 関数を使って、君の家から各家までの最短距離を計算する。
4. 計算結果を表示する。

**例：**

もし、入力が
```
4 3
1 2
2 3
1 4
```
だった場合、

1. `N = 4`, `M = 3`, `edges = [(1, 2), (2, 3), (1, 4)]` となる。
2. `build_graph(4, [(1, 2), (2, 3), (1, 4)])` を実行し、`graph` が作成される。
3. `bfs(4, graph)` を実行し、 `dist = [1, 2, 1]` が返される。
4. 最後に、 `1 2 1` と表示される。

これで、君の家からそれぞれの友達の家に遊びに行くための、最短の道のりがわかったね！

このプログラムを使えば、どんなに複雑な街の地図でも、迷わずに友達の家に遊びに行けるね！

<br>

## [補足] キューとスタックの違い
`queue` を使う理由は、**幅優先探索 (BFS)** を実現するためです。BFS は最短経路問題を解く際に非常に重要なアルゴリズムです。これを効率的に実行するためには、**キュー**を使って各ノードを訪れる必要があります。

一方、`stack` を使うと探索の順序が変わり、**深さ優先探索 (DFS)** に変わってしまいます。DFS では、ノードの訪問順が違うため、BFS のように正しい最短距離が計算されなくなります。

### 1. 幅優先探索 (BFS) とキュー
- **キュー (queue)** は**先入れ先出し (FIFO)** のデータ構造です。つまり、最初に追加された要素が最初に取り出されます。
- BFS では、最初に訪れたノードの隣接ノードを順番に訪れ、それから次の隣接ノードへと探索を広げていきます。
- これにより、探索が**層状**に進み、最短距離を確実に求めることができます。

### 2. 深さ優先探索 (DFS) とスタック
- **スタック (stack)** は**後入れ先出し (LIFO)** のデータ構造です。つまり、最後に追加された要素が最初に取り出されます。
- DFS では、あるノードの隣接ノードを可能な限り探索してから、次に移るので、探索が**深く進む**ことになります。
- これにより、BFS のように層状に探索が進まないため、最短距離を正確に求めることができません。

---

## 実際に比較してみる

### BFS の例（`queue` 使用）

```python
from collections import deque

def bfs_example():
    graph = {
        1: [2, 3],
        2: [4],
        3: [4],
        4: []
    }
    dist = [-1] * 5
    dist[1] = 0
    queue = deque([1])

    while queue:
        v = queue.popleft()
        for nv in graph[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                queue.append(nv)

    print(dist[1:])

bfs_example()
```

### 出力

```
[0, 1, 1, 2]
```

ここでは、ノード `1` から始めて、`2` と `3` は 1 つのステップで訪問でき、`4` は 2 つのステップで到達することが分かります。これは最短距離を正確に計算していることを示しています。

---

### DFS の例（`stack` 使用）

```python
def dfs_example():
    graph = {
        1: [2, 3],
        2: [4],
        3: [4],
        4: []
    }
    dist = [-1] * 5
    dist[1] = 0
    stack = [1]

    while stack:
        v = stack.pop()
        for nv in graph[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                stack.append(nv)

    print(dist[1:])

dfs_example()
```

### 出力

```
[0, 1, 1, 2]
```

見た目では同じ結果が出ていますが、これはたまたま単純なグラフの構造だったからです。DFS は「深く」進むため、複雑なグラフでは正しい最短距離が得られない可能性があります。

---

## 複雑なグラフでの違い

### 例: `1 -> 2 -> 4` と `1 -> 3 -> 4` の場合

- グラフに以下のような複数のルートがあるとします：

```python
graph = {
    1: [2, 3],
    2: [4],
    3: [4],
    4: []
}
```

この場合、`1` から `4` への最短距離は 2 ですが、DFS は必ずしも最短ルートを見つけるわけではありません。

---

### DFS での問題

DFS はスタックを使って「深く」進むため、あるルートを最後まで辿ることになります。つまり、`1 -> 2 -> 4` というルートをたどりきってから、他のルート（`1 -> 3 -> 4`）を探索します。

結果として、最短距離ではなく、最初に見つけたルートで到達した距離を記録してしまう可能性があります。

---

## 結論

- **BFS (キュー使用)**：最短距離を正確に計算したい場合に適しています。キューを使うことで、隣接ノードを層ごとに順番に訪れるため、全てのノードに対して最短距離を求めることができます。
- **DFS (スタック使用)**：グラフの全てのノードを深く探索する際に適していますが、最短距離を求める問題には適していません。

そのため、このコードでは **BFS** を用いるべきであり、`queue` を使う方が適切です。

<br>
<br>

### なぜ今回の問題でスタック（DFS）ではダメなのか？

今回の問題で **スタック（DFS）** ではなく **キュー（BFS）** を使うべき理由は、**最短距離を求める問題** だからです。幅優先探索（BFS）では最短距離が確実に計算できるのに対して、深さ優先探索（DFS）ではそうならないことがあるためです。

- **問題の要件**：
    - 頂点 1 から各頂点 \( k \) までの最短距離（たどる辺の最小本数）を計算しなければならない。
    - DFS は「深く」進む性質があるため、ある経路を見つけた時点で他の経路を無視してしまうことがあり、必ずしも最短経路を見つけるわけではありません。

- **BFS の特徴**：
    - BFS は「幅優先探索」なので、あるノードから隣接するノード全てを一層ずつ（つまり距離が短い順に）探索します。そのため、BFS を使うと、ノード 1 から他のノードへの最短距離を正確に求めることができます。

- **DFS の特徴**：
    - DFS は「深さ優先探索」なので、ある経路を深く探索し終えるまで他の経路を無視します。その結果、最初に見つけた経路が必ずしも最短距離であるとは限りません。
    - そのため、今回のように最短距離を求める場合、DFS では適切ではないのです。

### キュー（BFS）とスタック（DFS）での違いを示す例

次に、キュー（BFS）を使った場合とスタック（DFS）を使った場合で、出力結果が異なる例を見てみます。

---

#### 例 1: キュー（BFS）を使った場合

例えば次のグラフが与えられたとします：

```
1 -- 2 -- 4
 \        /
  3 -----
```

- 頂点 1 から頂点 4 までの最短距離は「1→3→4」（2 本の辺）です。

このグラフを使って、キュー（BFS）を使った場合の結果を見てみましょう。

```python
from collections import deque

def bfs_example():
    graph = {1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3]}
    dist = [-1] * 5
    dist[1] = 0
    queue = deque([1])

    while queue:
        v = queue.popleft()
        for nv in graph[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                queue.append(nv)

    print(dist[1:])

bfs_example()
```

### 出力

```
[0, 1, 1, 2]
```

- 頂点 1 から頂点 2 へは距離 1、頂点 3 へも距離 1、頂点 4 へは「1→3→4」で 2 本の辺を通って行けるので、距離は 2 です。

---

#### 例 2: スタック（DFS）を使った場合

次に、同じグラフに対してスタック（DFS）を使った場合の結果を見てみます。

```python
def dfs_example():
    graph = {1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3]}
    dist = [-1] * 5
    dist[1] = 0
    stack = [1]

    while stack:
        v = stack.pop()
        for nv in graph[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                stack.append(nv)

    print(dist[1:])

dfs_example()
```

### 出力

```
[0, 1, 2, 3]
```

- この結果では、頂点 1 から頂点 4 への最短距離は 2 ではなく、距離 3 となってしまいました。これは、スタックを使ったために、「1→2→4」の経路を先に探索したためです。

---

### 出力結果が異なる理由

- **BFS の場合**：頂点 1 から順に、隣接する頂点をすべて同じ層として探索し、距離が短い順に探索が行われます。そのため、最短距離が確実に求められます。
- **DFS の場合**：スタックを使うと、ある経路を深く探索してしまうため、最短経路ではなく、最初に見つけた経路が記録されてしまいます。DFS はすべてのノードを探索しますが、最短距離ではない探索結果が得られる可能性があります。

---

### まとめ

今回の問題では「最短距離」を求めるため、**キューを使って BFS を行う必要があります**。スタックを使った DFS では、最短経路を正確に見つけることができないため、BFS が正しい方法です。

DFS を使うと、「深く」探索するため、最短距離ではない経路を優先してしまい、正しい答えが得られない場合があるのです。

<br>
<br>

---
# 045

このコードは、**無向グラフ**が与えられたとき、特定の条件を満たす頂点の数をカウントするものです。コードの理解を深めるため、事例を使いながら初心者向けに丁寧に説明していきます。

### 問題の背景
グラフは**頂点**（ノード）と**辺**（エッジ）で構成されています。頂点は番号が振られていて、辺は2つの頂点をつなぐ線のようなものです。この問題では、特定の条件を満たす頂点を探す必要があります。

条件は、「自分より小さい番号の隣接頂点がちょうど1つ存在する頂点」を探すことです。

### コードの処理手順
まず、関数`count_valid_vertices()` と `main()` がどのように動くか説明します。

---

### `count_valid_vertices(N, edges)` の解説

この関数では、次のステップで条件を満たす頂点をカウントします。

1. **`count` リストの初期化**
   ```python
   count = [0] * (N + 1)
   ```
   ここでは、`count` というリストを作っています。このリストは `N+1` 個の要素を持ち、それぞれが 0 で初期化されています。各インデックスは対応する頂点を表し、隣接する自分より小さい頂点の数を数えます。

   例えば、頂点が 5 つ（N=5）の場合、リストは次のようになります。
   ```python
   count = [0, 0, 0, 0, 0, 0]
   ```
   インデックス 1〜5 がそれぞれの頂点を表し、`count[i]` は頂点 `i` に接続されている「自分より小さい番号の頂点」の数を示します。

2. **各辺の情報を処理**
   次に、グラフのすべての辺を調べます。`edges` は頂点のペアのリストで、それぞれのペアが辺を表します。`a, b` がその2つの頂点です。
   ```python
   for a, b in edges:
       if a > b:
           count[a] += 1
       else:
           count[b] += 1
   ```
   - **`a > b` の場合**: `a` の方が大きいため、`a` のカウントを増やします。
   - **`a ≤ b` の場合**: `b` の方が大きいため、`b` のカウントを増やします。

   これによって、各頂点に接続されている「自分より小さい番号の頂点」がカウントされます。

   #### 事例1
   例えば、次のような入力が与えられたとします。
   ```
   N = 5
   M = 5
   edges = [(1, 2), (1, 3), (3, 2), (5, 2), (4, 2)]
   ```
   この場合、各頂点の処理は以下のようになります。

   - `(1, 2)` では、`1` の方が小さいので、`2` にカウントを追加。`count[2] += 1`
   - `(1, 3)` では、`1` の方が小さいので、`3` にカウントを追加。`count[3] += 1`
   - `(3, 2)` では、`2` の方が小さいので、`3` にカウントを追加。`count[3] += 1`
   - `(5, 2)` では、`2` の方が小さいので、`5` にカウントを追加。`count[5] += 1`
   - `(4, 2)` では、`2` の方が小さいので、`4` にカウントを追加。`count[4] += 1`

   これにより、最終的な `count` リストは次のようになります。
   ```python
   count = [0, 0, 1, 2, 1, 1]
   ```

3. **条件を満たす頂点のカウント**
   最後に、カウントが「ちょうど1」である頂点の数を調べます。
   ```python
   return count.count(1)
   ```
   `count.count(1)` は、`count` リストの中で「1」の値を持つ要素の数を数えます。この例では、`count[2], count[4], count[5]` の3つが1なので、結果は `3` となります。

---

### `main()` の解説

`main()` 関数では、標準入力からデータを読み込み、処理を行います。

1. **入力の読み込み**
   ```python
   N, M = map(int, input().split())
   ```
   ここでは、`N` は頂点の数、`M` は辺の数です。

   例えば、入力が次のように与えられた場合：
   ```
   5 5
   1 2
   1 3
   3 2
   5 2
   4 2
   ```
   これは、頂点が5個あり、5本の辺が存在することを意味します。

2. **辺の読み込み**
   ```python
   edges = [tuple(map(int, input().split())) for _ in range(M)]
   ```
   この部分では、`M` 本の辺の情報をすべてリストとして読み込みます。各辺はタプル `(a, b)` の形で表され、`edges` に格納されます。

   事例1の例では、次のようなリストが得られます。
   ```python
   edges = [(1, 2), (1, 3), (3, 2), (5, 2), (4, 2)]
   ```

3. **頂点のカウント結果を出力**
   ```python
   print(count_valid_vertices(N, edges))
   ```
   `count_valid_vertices(N, edges)` を呼び出して結果を得て、それを標準出力に表示します。この事例の場合、結果は `3` です。

---

### 結論

このコードは、与えられたグラフにおいて「自分より小さい番号の隣接頂点がちょうど1つ存在する」頂点の数を効率的にカウントしています。処理過程を事例を使って説明しましたが、シンプルな構造であり、グラフの問題に慣れていない初心者でも理解しやすい実装となっています。

- **事例1**の処理では、頂点 2、4、5 が条件を満たす頂点としてカウントされ、その数が3と出力されました。

<br>
<br>

---
# 046

このコードは、幅優先探索（BFS）を使って、迷路内のスタート地点からゴール地点までの最短距離を求めるプログラムです。迷路は空きマス（`.`）と壁マス（`#`）で表されており、上下左右に移動できます。具体的な流れを、初心者向けに解説します。

### コード全体の流れ
1. **入力の受け取り**: 迷路の大きさ、スタート地点、ゴール地点、そして迷路の構造が入力される。
2. **幅優先探索（BFS）の実行**: 幅優先探索を用いて、スタート地点からゴール地点までの最小手数（最短距離）を計算します。
3. **結果の出力**: ゴール地点までの最短手数を出力します。

#### それぞれの部分について詳しく説明します。

---

### 1. `bfs` 関数
**幅優先探索（Breadth-First Search, BFS）** は、スタート地点から近いマスから順番に探索を行い、最短距離を求める方法です。

#### コードの説明

```python
from collections import deque
```
- **`deque`** は、両端から高速にデータを取り出せるデータ構造です。BFSで使うキュー（先入れ先出し）として利用します。

#### `bfs(maze, start, goal)` 関数の引数
- **`maze`**: 迷路の2次元リスト（`.``#`で構成された盤面）。
- **`start`**: スタート地点の座標（`(sy, sx)`）。
- **`goal`**: ゴール地点の座標（`(gy, gx)`）。

```python
directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
```
- **`directions`**: 移動できる4方向（右、左、下、上）を表しています。これを使って、現在のマスから上下左右に移動します。

```python
R, C = len(maze), len(maze[0])
```
- **`R`**: 迷路の行数。
- **`C`**: 迷路の列数。

```python
dist = [[-1] * C for _ in range(R)]
```
- **`dist`**: 各マスのスタート地点からの距離を記録する2次元リスト。初期値は `-1` で、まだ訪れていないことを示しています。

```python
queue = deque([start])
dist[start[0]][start[1]] = 0
```
- **`queue`**: 探索対象のマスを格納するキュー。スタート地点から探索を開始するので、キューにスタート地点を入れます。
- **`dist[start[0]][start[1]] = 0`**: スタート地点の距離は `0` として初期化します。

#### 探索のループ
```python
while queue:
    y, x = queue.popleft()
    if (y, x) == goal:
        return dist[y][x]
```
- **`while queue:`**: キューに探索対象のマスがある限り、ループを回します。
- **`queue.popleft()`**: キューの先頭のマスを取り出します（これが現在の探索マスです）。
- **`if (y, x) == goal:`**: 現在のマスがゴール地点なら、その時点での距離を返します。

#### 隣接するマスの探索
```python
for dx, dy in directions:
    ny, nx = y + dy, x + dx
    if maze[ny][nx] != '#' and dist[ny][nx] == -1:
        queue.append((ny, nx))
        dist[ny][nx] = dist[y][x] + 1
```
- **`for dx, dy in directions:`**: 現在のマス（`(y, x)`）の上下左右のマス（`(ny, nx)`）を計算します。
- **`maze[ny][nx] != '#'`**: 隣のマスが壁でないか確認します。
- **`dist[ny][nx] == -1`**: そのマスが未訪問か確認します。未訪問の場合のみ、キューに追加します。
- **`dist[ny][nx] = dist[y][x] + 1`**: 隣接マスの距離を、現在のマスの距離 +1 として更新します。

#### 探索が終了しない場合
```python
return -1
```
もしゴール地点にたどり着けなかった場合、`-1` を返します（ただし、この問題では必ずゴールに到達可能なことが保証されています）。

---

### 2. `main` 関数
標準入力からデータを受け取り、`bfs` 関数を呼び出して結果を表示する部分です。

```python
R, C = map(int, input().split())
```
- **`R`**: 迷路の行数。
- **`C`**: 迷路の列数。

```python
sy, sx = map(int, input().split())
gy, gx = map(int, input().split())
```
- **`sy, sx`**: スタート地点の行・列。
- **`gy, gx`**: ゴール地点の行・列。

```python
maze = [list(input()) for _ in range(R)]
```
- **`maze`**: 迷路の各行を入力として受け取り、それをリストに変換して2次元リストに格納します。

```python
start = (sy-1, sx-1)
goal = (gy-1, gx-1)
```
- 入力座標は1始まりのため、プログラムでは0始まりに変換しています。

```python
print(bfs(maze, start, goal))
```
- BFSを実行し、その結果（最短手数）を出力します。

---

### 例を使った流れの解説

#### 入力例1
```
7 8
2 2
4 5
########
#......#
#.######
#..#...#
#..##..#
##.....#
########
```

1. **迷路の構造**: スタート地点は `(2, 2)` で、ゴール地点は `(4, 5)` にあります。スタートからゴールまでの最短経路を幅優先探索で求めます。
2. **初期状態**: BFSは、スタート地点 `(2, 2)` から距離 `0` で開始します。
3. **次の探索マス**: `(2, 3)`、`(3, 2)` に進み、順番に探索していきます。
4. **ゴール到達**: ゴール地点 `(4, 5)` に到達したとき、その地点の距離は `11` です。

<br>
<br>

---
# 047

## [参考] 2 部グラフ

https://www.momoyama-usagi.com/entry/math-risan09#i-8

はい、このコードを詳細に解説いたします。初心者の方にも理解しやすいように、段階的に説明していきます。

## 1. 全体の構造

このプログラムは主に 3 つの部分から構成されています：

1. `is_bipartite_graph` 関数：グラフが二部グラフかどうかを判定する主要な関数
2. `bfs` 関数：幅優先探索（BFS）を行う関数（`is_bipartite_graph`の中で定義）
3. `main` 関数：入力を受け取り、結果を出力する関数

## 2. グラフの表現

```python
graph = [[] for _ in range(N+1)]
for A, B in edges:
    graph[A].append(B)
    graph[B].append(A)
```

ここでは、グラフを隣接リストとして表現しています。

- `graph`は長さ`N+1`のリストで、各要素は空のリストです。
- インデックス 0 は使用せず、1 から N までの頂点番号に対応させています。
- 各辺`(A, B)`に対して、A のリストに B を、B のリストに A を追加しています。

例えば、N=4 で辺が(1,2), (2,3), (3,4)の場合：

```python
graph = [[], [2], [1,3], [2,4], [3]]
```

## 3. 色の管理

```python
color = [0] * len(graph)
```

各頂点の色を管理するリストです。

- 0: 未訪問
- 1: 色 1（例：赤）
- -1: 色 2（例：青）

## 4. 幅優先探索（BFS）

```python
def bfs(start):
    queue = deque([start])
    color[start] = 1
    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if color[neighbor] == 0:
                color[neighbor] = -color[node]
                queue.append(neighbor)
            elif color[neighbor] == color[node]:
                return False
    return True
```

この関数が二部グラフの判定の核心部分です。

1. 開始頂点を色 1 で塗り、キューに追加します。
2. キューから頂点を取り出し、その隣接頂点を調べます。
3. 隣接頂点が未訪問なら、現在の頂点と反対の色で塗り、キューに追加します。
4. 隣接頂点が既に同じ色で塗られていたら、二部グラフではないので False を返します。
5. すべての頂点を処理できたら、True を返します。

## 5. 全体の探索

```python
for i in range(1, N+1):
    if color[i] == 0:
        if not bfs(i):
            return 'No'
return 'Yes'
```

グラフが複数の連結成分に分かれている可能性があるため、すべての頂点をチェックします。

## 6. 具体例

N=4, 辺=(1,2), (2,3), (3,4)の場合：

1. 頂点 1 から開始：
   - 1 を赤(1)で塗る
   - 2 を青(-1)で塗る
2. 頂点 2 の隣接点をチェック：
   - 3 を赤(1)で塗る
3. 頂点 3 の隣接点をチェック：
   - 4 を青(-1)で塗る

結果：すべての隣接頂点が異なる色になるので、これは二部グラフです。

一方、N=3, 辺=(1,2), (2,3), (3,1)の場合：

1. 頂点 1 から開始：
   - 1 を赤(1)で塗る
   - 2 を青(-1)で塗る
2. 頂点 2 の隣接点をチェック：
   - 3 を赤(1)で塗る
3. 頂点 3 の隣接点をチェック：
   - 1 が既に赤で塗られているため、矛盾が発生

結果：これは二部グラフではありません。

このように、このプログラムは効率的にグラフを探索し、二部グラフかどうかを判定します。

## [参考] グラフの視覚化

### N=4, 辺=(1,2), (2,3), (3,4)の場合：

このグラフは直線状のパスグラフになります。

```
1 --- 2 --- 3 --- 4
```

このグラフは二部グラフです。頂点を以下のように 2 つのグループに分けることができます：

- グループ 1: 1, 3
- グループ 2: 2, 4

### N=3, 辺=(1,2), (2,3), (3,1)の場合：

このグラフは 3 つの頂点が互いに接続された三角形（サイクル）になります。

```
    1
   / \
  /   \
 3 --- 2
```

このグラフは二部グラフではありません。3 つの頂点が互いに接続されているため、2 つのグループに分けることができません。

これらの例は、二部グラフの性質を理解するのに役立ちます：

1. パスグラフ（N=4 の例）は常に二部グラフです。隣接する頂点を交互に異なるグループに割り当てることができます。

2. 奇数の長さを持つサイクル（N=3 の例）は二部グラフではありません。すべての頂点が互いに接続されているため、2 つのグループに分けることができません。

これらの視覚的な表現は、グラフの構造と二部グラフの概念を理解するのに役立ちます。

<br>
<br>

## [別説明] 二部グラフ判定プログラムを解説！

このプログラムは、グラフが**二部グラフ**かどうかを判定します。二部グラフとは、頂点を2つのグループに分けて、同じグループ内の頂点同士が辺で繋がっていないグラフのことです。

### 具体的な例で考えてみよう！

例えば、友達同士の関係をグラフで表すとします。

* **人:** 太郎、次郎、花子、陽子 の4人
* **関係:** 太郎と花子は友達、次郎と陽子は友達

この関係を図にすると、以下のようになります。

```
  太郎 ----- 花子
  |          |
  |          |
  次郎 ----- 陽子
```

このグラフは二部グラフです。なぜなら、

1. **グループA:** 太郎、陽子
2. **グループB:** 次郎、花子

と分けると、同じグループ内の人同士は友達関係にないからです。

### プログラムの中身を詳しく見ていきましょう！

#### 1. データ構造の準備 ( `graph`, `color` )

```python
    graph = [[] for _ in range(N+1)]
    for a, b in edges:
        graph[a].append(b)
        graph[b].append(a)

    color = [0] * len(graph)
```

* `graph`: 各頂点から、どの頂点に繋がっているかを表すリストです。
    - 例えば、 `graph[1] = [2, 3]` は、頂点1が頂点2と頂点3に繋がっていることを意味します。
* `color`: 各頂点をどちらのグループに属させるかを表すリストです。
    - 最初は全て `0` で初期化されています。
    - 後で、`1` もしくは `-1` を使ってグループ分けを行います。

#### 2. 幅優先探索で二部グラフ判定 ( `bfs` 関数)

```python
    def bfs(start):
        queue = deque([start])
        color[start] = 1
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if color[neighbor] == 0:
                    color[neighbor] = -color[node]
                    queue.append(neighbor)
                elif color[neighbor] == color[node]:
                    return False
        return True
```

* `bfs(start)`: `start` 頂点から探索を開始し、二部グラフかどうかを判定します。
    - `queue`: これから調べる頂点を格納するキューです。
    - `color[start] = 1`: まず、開始頂点の色を `1` に設定します。
    - `while queue:`: キューが空になるまで、以下の処理を繰り返します。
        - `node = queue.popleft()`: キューから頂点を一つ取り出します。
        - `for neighbor in graph[node]:`: 取り出した頂点に隣接する頂点を順番に調べます。
            - `if color[neighbor] == 0:`: まだ色が決まっていない頂点の場合
                - `color[neighbor] = -color[node]`: 取り出した頂点と反対の色に設定します。
                - `queue.append(neighbor)`: キューに追加し、後で調べます。
            - `elif color[neighbor] == color[node]:`: 既に同じ色の頂点と繋がっている場合
                - 二部グラフではないので `False` を返します。
    - 全ての頂点を調べ終わったら `True` を返します。

#### 3. 全ての頂点に対して二部グラフ判定 ( メインループ )

```python
    for i in range(1, N+1):
        if color[i] == 0:
            if not bfs(i):
                return 'No'
    return 'Yes'
```

* `for i in range(1, N+1):`: 全ての頂点に対して、以下の処理を行います。
    - `if color[i] == 0:`: まだ色が決まっていない頂点の場合
        - `if not bfs(i):`: `bfs` 関数を呼び出して二部グラフ判定を行い、`False` が返ってきたら `'No'` を出力します。
* 全ての頂点に対して `bfs` 関数が `True` を返したら `'Yes'` を出力します。

### まとめ

このプログラムは、幅優先探索を使ってグラフの頂点を2つのグループに分け、二部グラフかどうかを判定します。 `bfs` 関数で、隣接する頂点を異なる色で塗りながら探索していくことで、二部グラフかどうかの判定を実現しています。


<br>
<br>

---
# 048

このコードは、「与えられた整数 \( K \) の倍数のうち、10進数表記の各桁の和が最小となる数」を求めるアルゴリズムです。ここでは `BFS（幅優先探索）` という手法を使い、効率的に探索します。

```python
from collections import deque

def min_digit_sum(K):
    # 各余りに対する最小の桁の和を保存する
    visited = [-1] * K
    queue = deque([(1 % K, 1)])  # (現在の余り, 桁の和)
    visited[1 % K] = 1

    while queue:
        remainder, digit_sum = queue.popleft()

        # 余りが 0 の場合、答えが見つかった
        if remainder == 0:
            return digit_sum

        # 次の状態を生成する（10 倍と 1 を足す操作）
        # この操作で次の余りを計算
        # 状態1: 10 * current + 0
        new_remainder = (remainder * 10) % K
        if visited[new_remainder] == -1:
            visited[new_remainder] = digit_sum
            queue.append((new_remainder, digit_sum))

        # 状態2: 10 * current + 1
        new_remainder = (remainder * 10 + 1) % K
        if visited[new_remainder] == -1:
            visited[new_remainder] = digit_sum + 1
            queue.append((new_remainder, digit_sum + 1))

def main():
    K = int(input())
    print(min_digit_sum(K))

if __name__ == "__main__":
    main()
```

### 基本的な考え方

**問題の目標**：
- 整数 \( K \) の倍数で、10進数表記の桁の和が最も小さいものを見つけます。

例を使って、どのように数を組み合わせれば10進数での桁の和が小さくなるかを考えてみます。

例えば、\( K = 6 \) の場合、最小の桁の和を持つ 6 の倍数を探すと、(6 $\times$ 2 = 12) がその数です。この場合、`1 + 2 = 3` となり、桁の和が 3 になります。

**幅優先探索 (BFS)** を使う理由：
- 小さい桁の和を求めたいので、「桁の和が少ないものから順に」数を構築していきます。
- これを `BFS` で実現します。BFS は「一番早く見つけた解が最適」である性質を持つため、これにより効率的に「最小の桁の和」が見つかります。

---

### コードの詳細解説

では、コードの各部分を順に解説します。

```python
from collections import deque

def min_digit_sum(K):
    # 各余りに対する最小の桁の和を保存する
    visited = [-1] * K
```

#### 1. 訪れた余りを管理する配列 `visited` の役割

ここで `visited` という配列を用意しています。これは長さが `K` の配列で、`visited[i]` に「余りが `i` のときの最小の桁の和」を保存します。すべて `-1` に初期化されているので、まだ訪れていない余りは `-1` になります。

```python
    queue = deque([(1 % K, 1)])  # (現在の余り, 桁の和)
    visited[1 % K] = 1
```

#### 2. 初期状態の設定

- 最初に `1` をキュー（探索待ちのリスト）に追加します。この時の情報は `(余り 1 % K, 桁の和 1)` です。
- また、余り `1` に対する桁の和を `visited` に記録します。

#### 具体例：\( K = 6 \) の場合

- `1 % 6 = 1` なので、最初の状態は `(1, 1)` です。これは「今 `1` という数を持っていて、その桁の和は `1`」を意味します。

```python
    while queue:
        remainder, digit_sum = queue.popleft()
```

#### 3. キューを使った探索

ここからは、キューを使って幅優先探索を行います。`queue.popleft()` で、キューの先頭から現在の状態 `(remainder, digit_sum)` を取り出します。

```python
        # 余りが 0 の場合、答えが見つかった
        if remainder == 0:
            return digit_sum
```

- `remainder` が `0` になったら、それは \( K \) の倍数であり、かつ桁の和が最小のものです。その時点で答えが見つかったので、`digit_sum` を返します。

#### 4. 新しい状態の生成

現在の状態から次の状態を生成します。「10倍する」「10倍して1を足す」という2つの操作を行い、それぞれ次の状態をキューに追加します。

```python
        # 次の状態を生成する（10 倍と 1 を足す操作）
        # 状態1: 10 * current + 0
        new_remainder = (remainder * 10) % K
        if visited[new_remainder] == -1:
            visited[new_remainder] = digit_sum
            queue.append((new_remainder, digit_sum))
```

- **状態1**：「今の数を10倍」して次の余りを計算します。例えば、現在の数が `1` で余りが `1` の場合、`1 * 10 = 10` となり、`10 % K` を計算して新しい余りを得ます。

#### 具体例

現在の数が `1` で余りが `1` の場合：
- `10倍`すると `10` になります。
- `10 % 6 = 4` なので、余りが `4` の状態 `(4, 1)` が新しく生成されます。

```python
        # 状態2: 10 * current + 1
        new_remainder = (remainder * 10 + 1) % K
        if visited[new_remainder] == -1:
            visited[new_remainder] = digit_sum + 1
            queue.append((new_remainder, digit_sum + 1))
```

- **状態2**：「今の数を10倍して、さらに1を足す」操作です。これにより、次の余りと桁の和を計算します。

#### 具体例

現在の数が `1` で余りが `1` の場合：
- `10倍して1を足す`と `11` になります。
- `11 % 6 = 5` なので、余りが `5` の状態 `(5, 2)` が生成されます（ここで桁の和は `2` に増加）。


### [処理内容詳細] K=6の場合

最初に、以下の準備を行います。

1. `visited` 配列を長さ `K` で初期化し、すべて `-1` を代入します。
   - `visited` 配列は、すでに訪れた余りについて記録し、その時点の桁の和を保存します。
   - `visited[1 % K] = 1` として、最初の状態 `(余り1, 桁の和1)` を記録します。

```python
visited = [-1, -1, -1, -1, -1, -1]
visited[1 % 6] = 1
```

`visited` は以下のようになります。
```
visited = [-1, 1, -1, -1, -1, -1]
```

2. キューに `(1 % K, 1)` を入れて初期化します。
   - ここでは `deque([(1 % K, 1)])` です。

```python
queue = deque([(1, 1)])
```

### キューを使った幅優先探索の流れ

以下では、キューから状態を取り出しながら、新しい数を作って次の余りを計算し、目的の `remainder == 0` に到達するまで探索します。

---

#### 1回目のループ

1. キューから `(1, 1)` を取り出します。
   - 現在の `remainder = 1`（余り）で、`digit_sum = 1`（桁の和）です。

2. 余りが `0` でないので次に進みます。

3. **次の状態1**：10倍する操作
   - 現在の余り `1` を10倍します。`1 * 10 = 10` です。
   - これを `K=6` で割ると `10 % 6 = 4` です。
   - 余り `4` はまだ訪れていないので、`visited[4]` に `1` を記録し、キューに `(4, 1)` を追加します。

        ```python
        visited = [-1, 1, -1, -1, 1, -1]
        queue = deque([(4, 1)])
        ```

4. **次の状態2**：10倍して1を足す操作
   - 現在の余り `1` を10倍して1を足します。`1 * 10 + 1 = 11` です。
   - これを `K=6` で割ると `11 % 6 = 5` です。
   - 余り `5` はまだ訪れていないので、`visited[5]` に `2`（桁の和が増える）を記録し、キューに `(5, 2)` を追加します。

        ```python
        visited = [-1, 1, -1, -1, 1, 2]
        queue = deque([(4, 1), (5, 2)])
        ```

---

#### 2回目のループ

1. キューから `(4, 1)` を取り出します。
   - 現在の `remainder = 4`（余り）で、`digit_sum = 1`（桁の和）です。

2. 余りが `0` でないので次に進みます。

3. **次の状態1**：10倍する操作
   - 現在の余り `4` を10倍します。`4 * 10 = 40` です。
   - これを `K=6` で割ると `40 % 6 = 4` です。
   - 余り `4` はすでに訪れているので、ここでは何もしません。

4. **次の状態2**：10倍して1を足す操作
   - 現在の余り `4` を10倍して1を足します。`4 * 10 + 1 = 41` です。
   - これを `K=6` で割ると `41 % 6 = 5` です。
   - 余り `5` はすでに訪れているので、ここでも何もしません。

        ```python
        # 状態は変わらない
        visited = [-1, 1, -1, -1, 1, 2]
        queue = deque([(5, 2)])
        ```

---

#### 3回目のループ

1. キューから `(5, 2)` を取り出します。
   - 現在の `remainder = 5`（余り）で、`digit_sum = 2`（桁の和）です。

2. 余りが `0` でないので次に進みます。

3. **次の状態1**：10倍する操作
   - 現在の余り `5` を10倍します。`5 * 10 = 50` です。
   - これを `K=6` で割ると `50 % 6 = 2` です。
   - 余り `2` はまだ訪れていないので、`visited[2]` に `2` を記録し、キューに `(2, 2)` を追加します。

        ```python
        visited = [-1, 1, 2, -1, 1, 2]
        queue = deque([(2, 2)])
        ```

4. **次の状態2**：10倍して1を足す操作
   - 現在の余り `5` を10倍して1を足します。`5 * 10 + 1 = 51` です。
   - これを `K=6` で割ると `51 % 6 = 3` です。
   - 余り `3` はまだ訪れていないので、`visited[3]` に `3` を記録し、キューに `(3, 3)` を追加します。

        ```python
        visited = [-1, 1, 2, 3, 1, 2]
        queue = deque([(2, 2), (3, 3)])
        ```

---

#### 4回目のループ

1. キューから `(2, 2)` を取り出します。
   - 現在の `remainder = 2`（余り）で、`digit_sum = 2`（桁の和）です。

2. 余りが `0` でないので次に進みます。

3. **次の状態1**：10倍する操作
   - 現在の余り `2` を10倍します。`2 * 10 = 20` です。
   - これを `K=6` で割ると `20 % 6 = 2` です。
   - 余り `2` はすでに訪れているので、ここでは何もしません。

4. **次の状態2**：10倍して1を足す操作
   - 現在の余り `2` を10倍して1を足します。`2 * 10 + 1 = 21` です。
   - これを `K=6` で割ると `21 % 6 = 3` です。
   - 余り `3` はすでに訪れているので、ここでも何もしません。

---

この後も探索を続け、最終的に `remainder == 0` になる状態が見つかれば、そこでループを終了し、答えを出力します。

### まとめ

このコードは、10進数の数を組み合わせて最小の桁の和を見つけるために幅優先探索（BFS）を利用したものです。初心者でも扱いやすいBFSの性質（最短経路や最小値探索）を活用し、効率的に解を導出するアルゴリズムになっています。

<br>
<br>

[参考] アルゴリズムについて
この問題でのアルゴリズムを理解するため、具体例を使って、幅優先探索（BFS）の流れを分かりやすく説明します。

### 例: \( K = 6 \) の場合

**目標**：
\( K = 6 \) の倍数の中で、各桁の和が最小の数を見つけることです。

**アプローチ**：
この問題では、数を一桁ずつ追加していき、各桁の和が最小になるようなKの倍数を探す方法を使います。具体的には「幅優先探索」を行い、余りの状態（`remainder`）ごとに最小の桁の和（`digit_sum`）を管理していきます。

### アルゴリズムの流れ

初めに、1という数を候補として開始し、10倍したり1を足したりして、次の数を作っていきます。各数をKで割った「余り」を使って状態を管理します。

1. **初期状態**
   - `1 % 6 = 1` なので、最初に (余り 1, 桁の和 1) の状態をキューに追加します。
   - キュー: `[(1, 1)]`
   - `visited` 配列は、訪れた余りを記録する配列で、`visited[1] = 1` と設定します。

2. **探索を開始**
   - キューから状態 `(1, 1)` を取り出します。余りが 1 で、桁の和は 1 です。

3. **新しい状態の生成**
   - 余り 1 から次の2つの操作を行います:
     1. **10 倍して 0 を追加**：`(1 * 10) % 6 = 4`、桁の和は変わらず 1
        - 新しい状態 `(4, 1)` をキューに追加し、`visited[4] = 1` とします。
     2. **10 倍して 1 を追加**：`(1 * 10 + 1) % 6 = 5`、桁の和は 1 増えて 2
        - 新しい状態 `(5, 2)` をキューに追加し、`visited[5] = 2` とします。

   - 現在のキュー: `[(4, 1), (5, 2)]`

4. **次の探索**
   - 次にキューから状態 `(4, 1)` を取り出します。余りが 4 で、桁の和は 1 です。

5. **さらに新しい状態を生成**
   - 余り 4 から次の2つの操作を行います:
     1. **10 倍して 0 を追加**：`(4 * 10) % 6 = 4`、桁の和は変わらず 1
        - 余りが 4 の状態はすでに訪れているので、無視します。
     2. **10 倍して 1 を追加**：`(4 * 10 + 1) % 6 = 3`、桁の和は 1 増えて 2
        - 新しい状態 `(3, 2)` をキューに追加し、`visited[3] = 2` とします。

   - 現在のキュー: `[(5, 2), (3, 2)]`

6. **次の探索**
   - キューから状態 `(5, 2)` を取り出します。余りが 5 で、桁の和は 2 です。

7. **新しい状態の生成**
   - 余り 5 から次の2つの操作を行います:
     1. **10 倍して 0 を追加**：`(5 * 10) % 6 = 2`、桁の和は変わらず 2
        - 新しい状態 `(2, 2)` をキューに追加し、`visited[2] = 2` とします。
     2. **10 倍して 1 を追加**：`(5 * 10 + 1) % 6 = 1`、桁の和は 1 増えて 3
        - 余りが 1 の状態はすでに訪れているので、無視します。

   - 現在のキュー: `[(3, 2), (2, 2)]`

8. **目標の状態に到達**
   - 次にキューから状態 `(3, 2)` を取り出しますが、この時点ではまだ余りは 0 ではありません。
   - 次の状態で、キューから状態 `(2, 2)` を取り出し、探索を続けていくと、最終的に余りが 0 になる状態が見つかります。

このように、幅優先探索で余りと桁の和を組み合わせて探索し、最も早く余りが 0 となる桁の和が求める解答です。

<br>
<br>

## [補足1] 解を算出できる理由 (1増やす操作と10倍する操作)

この方法で解を算出できる理由は、**1増やす操作**と**10倍する操作**の組み合わせが、与えられた `K` の倍数のうち最小の桁和を持つ数を効率的に探すための鍵となるからです。それぞれの操作の意味を具体的に理解することで、なぜこの方法が機能するのかが分かります。

### 1. 解の探索空間

#### 倍数の性質
`K` の倍数を探す問題なので、次のような倍数を考える必要があります。

- `K`, `2K`, `3K`, `4K` … という形で `K` の倍数が次々と現れます。

倍数の中で、最も桁和が小さいものを探すことが求められているので、無駄な操作をせずに `K` の倍数を効率よく探索する方法が必要です。

### 2. 操作の解釈

#### 操作1：**1増やす操作**

`1増やす操作` は、現在の数字に `1` を足した数を考える操作です。たとえば、今 `3` という数があった場合、`3 + 1 = 4` に進みます。そして、その数を `K` で割った余りを計算します。この操作により、現在の数を少しずつ増やしていくことができます。

この操作を使う理由は、**桁の和を変えることなく、数値を少しずつ変えて倍数を探せる**ためです。

- 例えば、`6` の倍数を探している場合、`12 = 6 × 2` は解の一つです。この場合、`12` の桁の和は `1 + 2 = 3` です。ここで、もし倍数に到達する前に少し数値を加えたい場合、この操作が使えます。

#### 操作2：**10倍する操作**

`10倍する操作` は、現在の数字に `10` を掛ける操作です。たとえば、今 `3` という数があった場合、`3 × 10 = 30` に進みます。そして、その数を `K` で割った余りを計算します。この操作は桁を追加することに相当します。桁が増えることで新しい桁が加わり、より大きな倍数を探すことができます。

この操作を使う理由は、**桁の数を増やして新しい数を素早く作れる**ためです。

- 例えば、`41` の倍数を探している場合、`11111 = 41 × 271` は解の一つです。この数は `1` を連続で10倍しながら作ったものです。

#### なぜこの2つの操作が効率的なのか？

**1増やす操作**は、数を少しずつ増やしていくことで、桁和をなるべく小さく保ちながら倍数を探す手助けをします。一方、**10倍する操作**は、数を大きく動かすことで桁が増え、新しい数を生み出します。この2つの操作を組み合わせることで、数を効率的に増やしつつ、必要な倍数にたどり着けます。

### 3. なぜこのアプローチで解けるのか？

このアプローチは、「各桁の和が最小」になる条件を満たすために、**幅優先探索（BFS）** という手法を使っています。BFSは、最短の道筋を探すための探索アルゴリズムです。このアルゴリズムにおいては、同じ余りになる数字が何度も出てくることはありません。なので、最短の移動（最小の桁の和）を見つけることができるのです。

たとえば `K = 6` の場合、次のような移動が考えられます。

- `1` の状態からスタートします。
- `1` に `1` を足すと `2` になります（余り `2`）。
- `1` を 10倍すると `10` になり、`10 % 6 = 4`（余り `4`）です。
- このように探索を続けていくと、`12` に到達します。この数は `K` の倍数で、かつ桁和が最小になります（`1 + 2 = 3`）。

**BFS** によって最短のパスが見つかり、その結果、**最小の桁の和**を持つ倍数が見つかるという仕組みです。

### 4. 実際の処理過程を例で説明

#### 例1: `K = 6`

1. **初期状態**: キューには `1` が入っていて、桁和は `1` です。
2. **操作1**: `1` に `1` を足して `2`（余り `2`）になる。
3. **操作2**: `1` を `10` 倍して `10`（余り `4`）になる。
4. その後、探索が進み、`12 = 6 × 2` という倍数に到達します。このときの桁和は `1 + 2 = 3` です。

#### 例2: `K = 41`

1. **初期状態**: キューには `1` が入っていて、桁和は `1` です。
2. **操作1**: `1` に `1` を足して `2`（余り `2`）になる。
3. **操作2**: `1` を `10` 倍して `10`（余り `10`）になる。
4. 探索が進み、最終的に `11111 = 41 × 271` という倍数に到達します。このときの桁和は `1 + 1 + 1 + 1 + 1 = 5` です。

### 5. なぜ桁の和が最小化されるのか？

桁の和を小さくするためには、無駄な大きな数を避ける必要があります。このアプローチでは、探索範囲をできるだけ狭く保ち、桁が少なく済むように調整しています。`1` を加える操作は、桁の数にほとんど影響を与えずに数を増やせますし、10倍する操作は新しい桁を作るのに適しています。

この2つの操作を使うことで、効率よく数を作り出し、その中から最も桁和が小さい倍数を見つけることができます。

### まとめ

- **1増やす操作**は、桁の和をなるべく小さく保ちながら、徐々に数を増やして倍数を探すために使われます。
- **10倍する操作**は、新しい桁を作り、より大きな数を作るために使われます。
- **幅優先探索（BFS）**を使うことで、最短の桁の和を持つ倍数を効率よく探すことができ、結果として最小の桁和を見つけることが可能になります。

これらの操作を組み合わせることで、問題を解決できる理由が説明できます。

<br>
<br>

## [補足2] BFSによる有効性

「単純に `K` の倍数を順に計算していく方法」と今回のBFSによるアプローチとの違いについて、説明が不足していました。それでは、**どのように効率が違うのか**、そして**なぜこの方法が有効なのか**を丁寧に説明します。

### 1. 単純な倍数列の方法とは？

まず、単純に `K` の倍数を順に計算していく方法を考えます。

たとえば、`K = 6` の場合に `K` の倍数を1つずつ計算していくと以下のようになります。

- `6 × 1 = 6` （桁和 `6`）
- `6 × 2 = 12` （桁和 `1 + 2 = 3`）
- `6 × 3 = 18` （桁和 `1 + 8 = 9`）
- `6 × 4 = 24` （桁和 `2 + 4 = 6`）

このように、順に倍数を確認していく方法では、一つ一つの倍数を計算して、その桁の和を確認していく必要があります。この方法はシンプルですが、問題があります。

#### 問題点:
1. **非効率的**: 単純に倍数を計算して桁の和を確認していく方法では、どこで最小の桁和が現れるかがわからないため、全ての倍数を無駄に調べる可能性があります。場合によっては、非常に大きな数を計算することになり、時間がかかります。

2. **探索が遅い**: 毎回桁の和を計算する必要があるので、途中で無駄に大きな数の桁和を計算する手間が生じ、効率が悪いです。

### 2. BFSを使った方法の違い

一方、今回のBFS（幅優先探索）を使った方法は、効率的に探索を行い、最短の桁和を見つけます。

BFSを使うことで、**桁和が増えるのを最小限に抑えつつ、効率よく倍数を探索できる**理由を、以下のポイントに分けて説明します。

#### (1) 幅優先探索の利点

BFSは、「少しずつ数値を広げていきながら、最も効率的な（最小の）答えを見つける」アルゴリズムです。具体的には、現在の数に `1` を足したり、10倍する操作を行いながら、どんどん先の数を計算していきますが、常に最短の経路（最小の桁和）を探しています。

これにより、無駄な大きな数を計算することなく、早い段階で答えにたどり着けます。

#### (2) キューを使うことで探索範囲を制限

BFSでは、**キュー**というデータ構造を使って、探索する順番を管理しています。このキューの使い方により、まだ探索していない数だけを効率的に処理し、桁和が大きくならないように順番に処理します。

たとえば、`K = 6` の場合、最初に `1` の桁和からスタートし、次に `1` を足したり10倍することで、より大きな倍数を作っていきます。

#### (3) 無駄を省くためのメモ化

BFSでは、各数に対応する桁和を一度記録しておき、すでに計算済みの数は再び計算しないようにしています。これにより、無駄な計算を省き、効率的に最小の桁和を見つけます。

### 3. 単純な倍数探索との効率の比較

ここで、単純な倍数探索とBFSの方法を比較します。

#### 単純な倍数探索の場合:
- 倍数を1つずつ計算し、そのたびに桁和を調べる。たとえば、`K = 6` なら `6`, `12`, `18`, `24`, ... と順に確認。
- 大きな倍数になるほど、桁数も増えるので、桁和の計算が複雑になり、途中で桁和が大きくなる可能性が高い。
- たとえば、`K = 41` の場合、`41, 82, 123, 164, 205...` など順に調べていく必要があり、非常に非効率。

#### BFSを使った探索の場合:
- 初期値（`1` の桁和）から、少しずつ数を増やしていくことで、効率よく倍数を探す。
- 途中で大きな倍数に無駄にたどり着くことなく、最小の桁和を持つ倍数を見つけられる。
- たとえば、`K = 41` の場合、すぐに `11111` という最小の桁和を持つ倍数に到達することができる。

### 4. 効率の差：具体的な計算例

#### 例1: `K = 6`

- **単純な倍数探索**:
  1. `6 × 1 = 6`（桁和 `6`）
  2. `6 × 2 = 12`（桁和 `1 + 2 = 3`）
  3. `6 × 3 = 18`（桁和 `1 + 8 = 9`）
  4. `6 × 4 = 24`（桁和 `2 + 4 = 6`）…

  このように、桁和が無駄に増えてしまうため、効率が悪くなります。

- **BFSによる探索**:
  1. 初期値 `1`（桁和 `1`）
  2. `1` を10倍して `10`（`10 % 6 = 4`）
  3. `1` に `1` を足して `2`（`12 % 6 = 0`）→最小の桁和 `3` に到達

#### 例2: `K = 41`

- **単純な倍数探索**:
  1. `41 × 1 = 41`（桁和 `4 + 1 = 5`）
  2. `41 × 2 = 82`（桁和 `8 + 2 = 10`）
  3. `41 × 3 = 123`（桁和 `1 + 2 + 3 = 6`）…

  と無駄に大きな数を調べる必要があり、最小の桁和にすぐ到達できません。

- **BFSによる探索**:
  1. 初期値 `1`（桁和 `1`）
  2. `1` を10倍して `10`（`10 % 41 = 10`）
  3. 探索が進み、最小の桁和 `11111 = 41 × 271`（桁和 `1 + 1 + 1 + 1 + 1 = 5`）に到達

### 5. まとめ

- **単純な倍数探索**は、全ての倍数を一つずつ計算し、桁の和を調べるため、非常に効率が悪い。
- **BFSを使った探索**は、数を小さく保ちながら、効率的に最小の桁和を持つ倍数に到達することができる。
- 無駄な大きな倍数を計算せず、効率よく解を求められるため、非常に効果的。

BFSは、探索範囲を賢く制御しながら最短で桁和が最小の倍数にたどり着けるため、効率的に解を見つけられるという点が最大の利点です。

<br>
<br>

## [補足3] 計算量の違い

### 1. 単純な倍数探索の計算量

単純に `K` の倍数を順に計算していく方法では、倍数をひたすら計算し、それぞれの倍数の桁和を計算します。

#### 計算ステップ
1. `K` の倍数 `K, 2K, 3K, ..., nK` を順に計算。
2. 各倍数の桁和を計算して、最小の桁和を探す。

この方法では、桁和が最小になる倍数に到達するまで、最悪の場合に `O(K)` 回の倍数計算が必要です。そして、それぞれの倍数の桁和を計算するためには、その数の桁数に比例した計算が必要です。桁数は `log(nK)`（倍数の数の大きさに依存）で決まるため、最悪の場合は `O(log nK)` の時間がかかります。

つまり、全体の計算量は以下のようになります：

- **倍数の計算量**: 倍数を順に調べるために `O(K)` 回のループが必要。
- **桁和の計算量**: 各倍数について桁の和を計算するには `O(log nK)` 回の桁和計算が必要。

したがって、全体の時間計算量は **`O(K * log nK)`** となります。`K` の値が大きくなると、この計算が非常に遅くなり、特に `K` が大きい場合には無駄な計算が多くなります。

---

### 2. BFSを使った探索の計算量

一方、BFSを用いた探索の計算量について見ていきます。

#### 計算ステップ
1. 現在の数（`pos`）から、`u = (pos + 1) % K` と `v = 10 * pos % K` の2つの遷移をBFSで探索。
2. すでに訪れたことのある位置（`dist[pos]` で管理）には二度と遷移しないため、探索回数を減らす。

#### 計算量の分析

- **探索範囲のサイズ**: BFSでは、`K` の倍数全体を探索するわけではなく、`K` の余り `0, 1, 2, ..., K-1` のみを探索します。よって、訪れる頂点の数は最大でも `K` 個です。
- **各頂点の処理コスト**: 各頂点において、`1` を足す操作と、`10倍する` 操作の2つの遷移しかありません。つまり、各頂点で行う操作は定数時間 (`O(1)`) です。

したがって、BFSによる探索の全体の計算量は、**`O(K)`** となります。これは、`K` 個の余りに対して定数時間の処理を行うためです。

---

### 3. 計算量の比較

- **単純な倍数探索**: `O(K * log nK)`
  → `K` の値が大きくなるにつれ、計算が非効率になります。特に大きな数になると、倍数が巨大になり、その桁数の計算が非常に大きくなるため、無駄な計算が増えます。

- **BFSを使った探索**: `O(K)`
  → BFSでは、`K` に関連する余りだけを探索するので、探索する範囲が小さく、効率的です。`K` の大きさに依存せず、遷移操作はすべて定数時間で行われるため、非常に速くなります。

#### 具体例

例えば、`K = 79992` の場合を考えてみましょう。

- **単純な倍数探索**では、倍数を順に計算すると、最初の方の倍数はすぐに見つかりますが、必要な最小桁和に到達するまで非常に多くの倍数を計算し続けることになります。各倍数の桁数も次第に増えていき、その桁和を計算するコストも増えます。

- **BFS** では、余りに注目して探索を行うため、`79992` の倍数そのものではなく、`79992` に対する余りの中で効率的に最小の桁和を持つ倍数にたどり着くことができます。この方法は倍数の大きさに関わらず、`K` の余りに対する探索に限定されるので、無駄が少なく高速です。

---

### 4. 結論

- **単純な倍数探索**では、全ての倍数を順に計算していくため、無駄な倍数の計算や桁和の計算が増え、特に `K` が大きくなると非効率です。
- **BFSを使った探索**は、`K` の倍数の余りに注目して効率的に探索を行うため、無駄が少なく、計算量が `O(K)` に抑えられます。倍数そのものではなく、余りの集合に対して操作を行うので、倍数が大きくなっても処理は一定時間で行われます。

このため、BFSによる方法が桁和を求めるために非常に効率的であり、大きな `K` の値に対しても高速に解を得ることができるのです。

<br>
<br>


---
# 049

# フィボナッチ数列の効率的な計算方法：行列累乗法の解説

## はじめに

フィボナッチ数列は、次のように定義される数列です：

F(0) = 0, F(1) = 1
F(n) = F(n-1) + F(n-2) （nが2以上の場合）

例えば、最初の10項は次のようになります：
0, 1, 1, 2, 3, 5, 8, 13, 21, 34

この数列の項を素早く計算するために、行列累乗法という高度な手法を使います。

## コードの詳細解説

### 1. 行列の掛け算（`matrix_multiply`関数）

```python
def matrix_multiply(a, b, mod):
    return [
        [(a[0][0]*b[0][0] + a[0][1]*b[1][0]) % mod, (a[0][0]*b[0][1] + a[0][1]*b[1][1]) % mod],
        [(a[1][0]*b[0][0] + a[1][1]*b[1][0]) % mod, (a[1][0]*b[0][1] + a[1][1]*b[1][1]) % mod]
    ]
```

この関数は2x2の行列同士の掛け算を行います。

例えば：
```
a = [[1, 2],   b = [[5, 6],
     [3, 4]]        [7, 8]]
```
という2つの行列があった場合、

結果の[0][0]要素は：(1*5 + 2*7) % mod<br>
結果の[0][1]要素は：(1*6 + 2*8) % mod<br>
結果の[1][0]要素は：(3*5 + 4*7) % mod<br>
結果の[1][1]要素は：(3*6 + 4*8) % mod<br>

となります。

`% mod`は、数が大きくなりすぎないようにするための工夫です。

### 2. 行列のべき乗（`matrix_power`関数）

```python
def matrix_power(matrix, n, mod):
    result = [[1, 0], [0, 1]]
    while n > 0:
        if n % 2 == 1:
            result = matrix_multiply(result, matrix, mod)
        matrix = matrix_multiply(matrix, matrix, mod)
        n //= 2
    return result
```

この関数は、行列のn乗を効率的に計算します。普通に n 回掛け算すると時間がかかりすぎるので、賢い方法を使います。

例えば、matrix^8 を計算する場合：
1. 8 = 2^3 なので、(matrix^2)^2^2 と考えます。
2. matrix を2回掛けて、その結果をさらに2回掛けて、最後にもう一度2回掛ける

これにより、8回の掛け算を3回で済ませることができます。

nが13の場合（2進数で1101）：
1. matrix^1 を計算
2. それを2乗して matrix^2 を計算
3. さらに2乗して matrix^4 を計算
4. matrix^1 * matrix^4 * matrix^8 を計算

これで、13回の掛け算を5回で済ませられます。

### 3. フィボナッチ数の計算（`fibonacci_mod`関数）

```python
def fibonacci_mod(n):
    if n <= 1:
        return n
    MOD = 10**9 + 7
    matrix = [[1, 1], [1, 0]]
    result = matrix_power(matrix, n - 1, MOD)
    return result[0][0]
```

ここでは、フィボナッチ数列と行列の関係を利用します：

[[F(n+1), F(n)],   =  [[1, 1], ^ n
 [F(n),   F(n-1)]]     [1, 0]]

つまり、[[1, 1], [1, 0]] という行列のn乗の[0][0]要素が、F(n+1)になるのです。

例えば、n=5の場合：
1. [[1, 1], [1, 0]]^4 を計算（なぜ4かというと、0から数えて5番目を求めるため）
2. 結果の[0][0]要素がF(5)、つまり5番目のフィボナッチ数になります

### 4. メイン関数

```python
def main():
    N = int(input())
    print(fibonacci_mod(N))

if __name__ == "__main__":
    main()
```

この部分は、ユーザーから入力を受け取り、計算結果を表示します。

例えば、ユーザーが「10」と入力すると：
1. `fibonacci_mod(10)`が呼ばれます
2. 内部で`matrix_power([[1, 1], [1, 0]], 9, MOD)`が計算されます
3. その結果の[0][0]要素、つまり55が返されます
4. 最後に55が画面に表示されます

## まとめ

このプログラムは、行列の性質を巧みに利用して、フィボナッチ数列の項を高速に計算しています。普通の方法だとN回の計算が必要ですが、この方法だと約log(N)回の計算で済むため、特に大きな数を扱う場合に非常に効果的です。

<br>
<br>

# [補足] 上記 2. 行列のべき乗（`matrix_power`関数）
## 行列の累乗計算：効率的なアルゴリズムの解説

## はじめに

行列のn乗を計算する際、単純に n 回掛け算を行うのは非効率的です。そこで、「繰り返し二乗法」という効率的な方法を使います。この方法を理解するために、まず数値の例で考え、その後でコードがどのように動作するかを見ていきましょう。

## 数値例での説明

### 例1: 8乗の計算

8 = 2^3 = 2 * 2 * 2 なので、次のように計算できます：

1. まず2乗を計算: A^2
2. その結果をさらに2乗: (A^2)^2 = A^4
3. さらにその結果を2乗: ((A^2)^2)^2 = A^8

このように、3回の2乗計算で8乗が求められます。

### 例2: 13乗の計算

13を2進数で表すと1101です。これは次のように分解できます：
13 = 8 + 4 + 0 + 1 = 2^3 + 2^2 + 2^0

したがって、A^13 は次のように計算できます：
A^13 = A^8 * A^4 * A^1

計算手順：
1. A^1 を計算 (これは A そのもの)
2. A^2 を計算 (A * A)
3. A^4 を計算 ((A^2) * (A^2))
4. A^8 を計算 ((A^4) * (A^4))
5. 最後に A^13 = A^8 * A^4 * A^1 を計算

## コードでの実装

では、これがコードでどのように実装されているか見てみましょう：

```python
def matrix_power(matrix, n, mod):
    result = [[1, 0], [0, 1]]  # 単位行列で初期化
    while n > 0:
        if n % 2 == 1:
            result = matrix_multiply(result, matrix, mod)
        matrix = matrix_multiply(matrix, matrix, mod)
        n //= 2
    return result
```

このコードの動作を、n = 13 の場合で詳しく見ていきます：

1. 初期状態:
   - `result` = 単位行列 [[1, 0], [0, 1]]
   - `matrix` = 元の行列 A
   - n = 13 (2進数で1101)

2. 1回目のループ:
   - n = 13 (奇数)なので、`result = result * matrix`（A^1を掛ける）
   - `matrix = matrix * matrix`（A^2を計算）
   - n = 6

3. 2回目のループ:
   - n = 6 (偶数)なので、resultは変更なし
   - `matrix = matrix * matrix`（A^4を計算）
   - n = 3

4. 3回目のループ:
   - n = 3 (奇数)なので、`result = result * matrix`（A^4を掛ける）
   - `matrix = matrix * matrix`（A^8を計算）
   - n = 1

5. 4回目のループ:
   - n = 1 (奇数)なので、`result = result * matrix`（A^8を掛ける）
   - `matrix = matrix * matrix`（A^16を計算するが、使用しない）
   - n = 0

6. ループ終了

最終的に、`result`は A^1 * A^4 * A^8 = A^13 となります。

## まとめ

このアルゴリズムは、行列の累乗を効率的に計算します。n の2進表現を利用することで、必要最小限の掛け算だけを行い、計算量を大幅に削減しています。

13乗の場合、素朴な方法では13回の掛け算が必要ですが、この方法では実質5回（A^2, A^4, A^8の計算と、resultへの掛け算2回）で済みます。nが大きくなるほど、この効率の差は顕著になります。

この効率的な方法により、非常に大きな数のフィボナッチ数でも高速に計算することができるのです。

<br>
<br>

---
# 050

このコードは、非常に大きな数「aのb乗」を効率よく計算し、それを \(10^9 + 7\) で割った余りを求めるアルゴリズムを実装しています。以下、コードの各部分を初心者が理解できるように、事例を使いながら丁寧に解説していきます。

### 1. 問題の背景
通常、`a^b`（aのb乗）を計算すると、数が非常に大きくなります。例えば、`5^23` は 11920928955078125 という大きな数になります。このような大きな数をそのまま扱うと、コンピュータでの計算が非常に遅くなったり、メモリ不足が生じたりします。

そこで、数を \(10^9 + 7\) という大きな素数で割った余りを計算することで、数値を小さく保ちながら計算します。これにより、効率的に計算が行えます。

### 2. `mod_pow(a, b)` 関数の解説

この関数は「a の b 乗を \(10^9 + 7\) で割った余り」を効率的に計算します。一般に、指数が大きい場合（例えば、b が 10^9 のような値）、普通に計算すると非常に時間がかかります。そこで、「**二分累乗法**」というテクニックを使います。

では、コードの処理を詳しく見ていきましょう。

#### ステップ1: 初期設定
```python
MOD = 10**9 + 7
res = 1
```
- `MOD` は \(10^9 + 7\) のことです。これを使って割った余りを計算します。
- `res` には計算結果を保存します。最初は 1 を代入しておきます。

#### ステップ2: ループ処理（b が 0 になるまで）
```python
while b > 0:
```
`b` が 0 になるまでループを続けます。この間に、`a` を次々と二乗していき、必要に応じて `res` に結果を反映していきます。

#### ステップ3: `b` が奇数の場合の処理
```python
if b % 2 == 1:
    res = (res * a) % MOD
```
- `b % 2 == 1` は「`b` が奇数かどうか」を確認する条件です。もし `b` が奇数なら、その時点の `a` を `res` に掛けて、結果を MOD で割った余りを `res` に代入します。
- 例えば、`b = 23` の場合、最初の繰り返しで `b` は奇数です。この時、`res` に `a` を掛けたものを保存します。

#### ステップ4: `a` を二乗し、`b` を半分に
```python
a = (a * a) % MOD
b //= 2
```
- `a` を二乗し、その結果を MOD で割った余りを `a` に代入します。これにより、次のステップで `a` の二乗が計算に使われるようになります。
- `b` を半分にすることで、次のループで `a` の二乗を計算に使えるようにします。これにより、ループが効率よく進みます。

### 3. 事例を使った解説

#### 例: `a = 5`, `b = 23` の場合

この例を通じて、ループがどのように動作するかを見ていきます。

- 最初の状態:
  - `a = 5`
  - `b = 23`
  - `res = 1`
  - `MOD = 1000000007`

1. **最初のループ** (`b = 23`、奇数):
   - `b % 2 == 1` なので、`res = (res * a) % MOD = (1 * 5) % MOD = 5` となります。
   - `a = (a * a) % MOD = (5 * 5) % MOD = 25` となります。
   - `b //= 2` なので、`b = 11` になります。

2. **次のループ** (`b = 11`、奇数):
   - `b % 2 == 1` なので、`res = (res * a) % MOD = (5 * 25) % MOD = 125` となります。
   - `a = (a * a) % MOD = (25 * 25) % MOD = 625` となります。
   - `b //= 2` なので、`b = 5` になります。

3. **次のループ** (`b = 5`、奇数):
   - `b % 2 == 1` なので、`res = (res * a) % MOD = (125 * 625) % MOD = 78125` となります。
   - `a = (a * a) % MOD = (625 * 625) % MOD = 390625` となります。
   - `b //= 2` なので、`b = 2` になります。

4. **次のループ** (`b = 2`、偶数):
   - `b % 2 == 0` なので、`res` は更新されません。
   - `a = (a * a) % MOD = (390625 * 390625) % MOD = 587889561` となります。
   - `b //= 2` なので、`b = 1` になります。

5. **次のループ** (`b = 1`、奇数):
   - `b % 2 == 1` なので、`res = (res * a) % MOD = (78125 * 587889561) % MOD = 871631629` となります。
   - `a = (a * a) % MOD = (587889561 * 587889561) % MOD = 513473790` となります。
   - `b //= 2` なので、`b = 0` になり、ループが終了します。

結果として、`res = 871631629` が得られます。

### 4. `main` 関数の解説

```python
def main():
    a, b = map(int, input().split())
    print(mod_pow(a, b))
```
- `map(int, input().split())` によって、入力を整数として受け取り、それぞれ `a` と `b` に代入します。
- `mod_pow(a, b)` を呼び出して、結果を計算し、その結果を `print` で表示します。

### まとめ
このコードでは、`a^b` を直接計算するのではなく、効率よく処理するために二分累乗法を使用しています。この方法により、指数が非常に大きくても計算が高速に行えます。

<br>
<br>

## [補足] 二分累乗法について
「二分累乗法（または、累乗の二分法）」は、大きな指数の累乗を効率よく計算するためのテクニックです。この方法を使うと、普通に $a^b$ を計算するよりもはるかに少ないステップで計算できます。数学の初心者にもわかるように、この方法がどのように働くのか、基本から丁寧に説明します。

### 1. 通常の累乗計算
まず、普通に $a^b$ を計算すると、 $a$ を $b$ 回掛け算する必要があります。

例えば、 $5^{23}$ を考えてみましょう。

- $5^{23}$ を普通に計算するには、 $5 \times 5 \times 5 \times \dots \times 5$ という計算を23回繰り返さなければなりません。これにはたくさんの掛け算が必要で、 $b$ が大きいと時間がかかってしまいます。

### 2. 二分累乗法の基本アイデア
二分累乗法では、指数 $b$ を半分にしていくことで、累乗を効率的に計算します。

二分累乗法のポイントは次の2つです：
1. $b$ が **偶数** の場合、 $a^b = (a^{b/2})^2$ という性質を使います。つまり、累乗を半分に分割できます。
2. $b$ が **奇数** の場合、 $a^b = a \times a^{b-1}$ として、まず $a$ を掛けてから、残りを偶数の累乗に変えます。

### 3. 具体的な例： $5^{23}$ の計算
二分累乗法を使って、 $5^{23}$ をどのように計算するのか、ステップごとに説明します。

#### ステップ 1:
- $b = 23$ は奇数です。だから、まず $5$ を結果に掛けます（この時点で結果は $5$）。
- その後、 $b = 22$ にします（1を減らして偶数にする）。

#### ステップ 2:
- $b = 22$ は偶数なので、 $5^{22} = (5^{11})^2$ として計算できます。
- ここで、まず $5^{11}$ を計算しないといけません。

#### ステップ 3:
- $b = 11$ は奇数なので、また $5$ を結果に掛けます（現在の結果は $5 \times 5 = 25$）。
- その後、 $b = 10$ にします。

#### ステップ 4:
- $b = 10$ は偶数なので、 $5^{10} = (5^5)^2$ です。
- ここでも $5^5$ をまず計算します。

#### ステップ 5:
- $b = 5$ は奇数なので、また $5$ を結果に掛けます（現在の結果は $25 \times 5 = 125$）。
- その後、 $b = 4$ にします。

#### ステップ 6:
- $b = 4$ は偶数なので、 $5^4 = (5^2)^2$ です。
- 次に $5^2$ を計算します。

#### ステップ 7:
- $b = 2$ は偶数なので、 $5^2 = (5^1)^2$ です。
- $b = 1$ は奇数なので、また $5$ を結果に掛けます（現在の結果は $125 \times 5 = 78125$）。

#### ステップ 8:
- $b = 0$ になり、ループが終了します。この時点で、結果が得られます。

### 4. このコードにおける二分累乗法の使用箇所
このコードでは、指数 $b$ をどんどん半分にしていくという「二分累乗法」の考え方を使っています。

#### 該当する部分のコード
```python
while b > 0:
    if b % 2 == 1:
        res = (res * a) % MOD
    a = (a * a) % MOD
    b //= 2
```
- ここで `b` を半分にする（`b //= 2`）ことが「二分累乗法」です。`b` を半分にするたびに、`a` を二乗していきます（`a = (a * a) % MOD`）。
- また、`b` が奇数の場合には `res` に `a` を掛けるというステップが入ります（`res = (res * a) % MOD`）。

これにより、指数が非常に大きな場合でも、効率的に累乗の計算ができるようになっています。

### 5. 計算ステップ数の削減
通常の累乗計算では $b$ 回の掛け算が必要です。しかし、二分累乗法では $b$ の値を毎回半分にしていくため、必要な計算ステップ数は約 $\log_2(b)$ 回になります。

例えば、 $b = 23$ の場合、通常の方法なら 23 回の掛け算が必要ですが、二分累乗法を使うと約 $\log_2(23) \approx 4.5$ なので、実際には 5 回程度の掛け算で済みます。

これが、二分累乗法が非常に効率的である理由です。指数 $b$ が大きくなればなるほど、この方法のメリットが際立ちます。

### まとめ
- **二分累乗法**は、指数 $b$ を半分にしながら効率よく累乗を計算する方法です。
- この方法により、通常の $b$ 回の掛け算を $\log_2(b)$ 回の掛け算に減らすことができ、特に $b$ が大きい場合に計算が高速になります。
- このコードでは、`a` を二乗しながら `b` を半分にしていくことで、指数が非常に大きい場合でも効率的に計算を行っています。
