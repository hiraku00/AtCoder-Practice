# アルゴリズムと数学 演習問題集

https://atcoder.jp/contests/math-and-algorithm

---
### 009

```
def bf2(S, A):
    dp = [1] + [0] * S
    for i in A:
        print(f'----------------------------------------------------- i : {i}')
        print(range(S - i, -1, -1))
        for j in range(S - i, -1, -1):
            print(f'------------------------------------------ j : {j}')
            print(f'dp[{j}] : {dp[j]}')
            if dp[j] == 1:
                dp[j + i] = 1
                print(f'dp[{j}] == 1 => {dp[j] == 1}')
                print(f'dp[{j} + {i}] = 1')
            print(dp)
    print(f'========')
    print(dp)
    print("Yes" if dp[-1] == 1 else "No")

N, S = map(int, input().split())
A = list(map(int, input().split()))
bf2(S, A)
```

dp[i]は、「i」という合計値を作ることができるかどうかを表しています。<br>
1なら作れる、0なら作れないという意味です。

```
if dp[i]:
    dp[i + n] = 1
```

この部分は、「もしiという合計値が作れるなら、iにnを足した数も作れる」という意味になります。<br>
なぜなら、iが作れて、その上にnを足すことができるからです。

具体的な例で説明しますね。<br>
カードが[1, 2, 4]の3枚だけで、その合計がちょうど7になる組み合わせがあるかどうかを探すとします。

最初に、0から目標の数（この場合は7）までの各数値が作れるかどうかを記録するためのリスト（dp）を作ります。<br>
最初は全て「作れない（=0）」としておきますが、0だけは何も選ばないことで作れるので、「作れる（=1）」とします。

```
dp = [1, 0, 0, 0, 0, 0, 0, 0]
```

次に、各カードについて考えます。

最初のカードは1です。<br>
これを使って作れる数値は1と0（何も選ばない）です。<br>
したがって、dp[1]を「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 0, 0, 0, 0, 0, 0]
```

次に2が書かれたカードを考えます。<br>
このカードを使って作れる数値は2と0（何も選ばない）です。<br>
また、1が作れることがわかっているので、1+2=3も作れます。<br>
したがって、dp[2]とdp[3]を「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 1, 1, 0, 0, 0, 0]
```

最後に4が書かれたカードを考えます。<br>
このカードを使って作れる数値は4と0（何も選ばない）です。<br>
また、1から3までの全ての数が作れることがわかっているので、これらの数に4を足した5から7までの全ての数も作れます。<br>
したがって、dp[4]からdp[7]までを「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 1, 1, 1, 1, 1, 1]
```

以上の手順で、目標の数7が作れることがわかりました。<br>
したがって、「Yes」と出力します。

このように動的計画法では、
小さな問題（小さい数が作れるかどうか）から順に解いていき、最終的に大きな問題（目標の数が作れるかどうか）を解くことができます。<br>
この手法はプログラミングだけでなく、様々な問題解決に応用することができますよ。
