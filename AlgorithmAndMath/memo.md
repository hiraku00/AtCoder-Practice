# アルゴリズムと数学 演習問題集

https://atcoder.jp/contests/math-and-algorithm

---

# 007

このコードは、N 以下の正の整数の中で、X の倍数または Y の倍数であるものの個数を数えるためのプログラムです。

### 1. `gcd` 関数の説明

```python
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a
```

**目的**: 2 つの整数 `a` と `b` の最大公約数（GCD: Greatest Common Divisor）を求めます。

**動作**:

- **最大公約数**とは、2 つの整数を割り切ることができる最も大きな数のことです。
- `a % b` は `a` を `b` で割った余りを表します。
- ユークリッドの互除法を使用します。これは、次のように動作します:
  - `b` が 0 でない限り、`a` に `b` を、`b` に `a % b` を代入し続けます。
  - 最終的に `b` が 0 になると、そのときの `a` が `a` と `b` の最大公約数になります。

**例**:

- `gcd(15, 5)` の場合:
  - 初回: `a = 15`, `b = 5` → `a % b = 15 % 5 = 0`
  - その後: `a = 5`, `b = 0` → 終了、結果は `5`。

### 2. `lcm` 関数の説明

```python
def lcm(a, b):
    return a * b // gcd(a, b)
```

**目的**: 2 つの整数 `a` と `b` の最小公倍数（LCM: Least Common Multiple）を求めます。

**動作**:

- **最小公倍数**とは、2 つの整数の両方を割り切ることができる最小の数のことです。
- 2 つの数の積（`a * b`）を、その数たちの最大公約数で割ることで求めます。

**例**:

- `lcm(15, 5)` の場合:
  - `gcd(15, 5)` は 5 なので、`lcm(15, 5)` は `15 * 5 // 5 = 15`。

### 3. `main` 関数の説明

```python
def main():
    N, X, Y = map(int, input().split())
    cnt_X = N // X
    cnt_Y = N // Y
    lcm_XY = lcm(X, Y)
    cnt_XY = N // lcm_XY
    print(cnt_X + cnt_Y - cnt_XY)
```

**目的**: N 以下の正の整数の中で、X の倍数または Y の倍数であるものの個数を数えて出力します。

**動作の流れ**:

1. **入力の受け取り**:

   - `N, X, Y` という 3 つの整数を入力から取得します。
   - 例えば、`15 3 5` と入力すると、`N=15`, `X=3`, `Y=5` となります。

2. **X の倍数の数を数える**:

   - `cnt_X = N // X` は、`N` 以下の X の倍数の個数を計算します。
   - `15 // 3 = 5` なので、`cnt_X` は 5 です（3, 6, 9, 12, 15 が該当）。

3. **Y の倍数の数を数える**:

   - `cnt_Y = N // Y` は、`N` 以下の Y の倍数の個数を計算します。
   - `15 // 5 = 3` なので、`cnt_Y` は 3 です（5, 10, 15 が該当）。

4. **X と Y の最小公倍数の倍数の数を数える**:

   - `lcm_XY = lcm(X, Y)` は、X と Y の最小公倍数を求めます。この例では `lcm(3, 5)` で `15` になります。
   - `cnt_XY = N // lcm_XY` は、`N` 以下の X と Y の両方の倍数の個数を計算します。`15 // 15 = 1` なので、`cnt_XY` は 1 です（15 が該当）。

5. **結果の計算と出力**:
   - `cnt_X + cnt_Y - cnt_XY` で、X の倍数と Y の倍数を合計し、両方の倍数であるものを 1 回引きます（重複を除くため）。
   - この例では `5 + 3 - 1 = 7` になります（3, 5, 6, 9, 10, 12, 15 の 7 つが該当）。
   - 最終的に `print(7)` として出力します。

### 4. `if __name__ == "__main__": main()` の説明

```python
if __name__ == "__main__":
    main()
```

**目的**: このコードが直接実行された場合に、`main()` 関数を呼び出してプログラムを開始するための標準的な Python の記述です。他のファイルからインポートされた場合には、`main()` が実行されません。

### まとめ

このコードでは、X の倍数や Y の倍数を直接数えた後、両方の倍数を 1 回引くことで、重複を排除し、正しい結果を得ることができます。各ステップでどのような計算が行われているのかを理解することで、倍数や最小公倍数についての知識が深まります。

## [補足] gcd

`gcd` 関数の動作をより分かりやすくするために、複数回ループが発生する例を使って説明します。たとえば、`gcd(48, 18)` の場合を考えてみましょう。

### `gcd` 関数の詳しい解説と例

```python
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a
```

**目的**: 2 つの整数 `a` と `b` の最大公約数（GCD: Greatest Common Divisor）を求めます。

### 例: `gcd(48, 18)` の場合

この例では、`a = 48` と `b = 18` で関数を呼び出します。

1. **初回ループ**:

   - `a = 48`, `b = 18`
   - `a % b = 48 % 18 = 12` となるので、次に `a = 18`, `b = 12` に更新されます。

2. **2 回目のループ**:

   - `a = 18`, `b = 12`
   - `a % b = 18 % 12 = 6` となるので、次に `a = 12`, `b = 6` に更新されます。

3. **3 回目のループ**:

   - `a = 12`, `b = 6`
   - `a % b = 12 % 6 = 0` となるので、次に `a = 6`, `b = 0` に更新されます。

4. **ループ終了**:
   - `b = 0` となったためループを終了し、最終的に `a = 6` なので、`gcd(48, 18)` の結果は `6` になります。

### 動作の解説

- **第 1 回目**: 48 を 18 で割った余りは 12 なので、次のループで 18 と 12 を使います。
- **第 2 回目**: 18 を 12 で割った余りは 6 なので、次のループで 12 と 6 を使います。
- **第 3 回目**: 12 を 6 で割った余りは 0 なので、ループが終了し、最大公約数が 6 であるとわかります。

### 結論

このように、`gcd(48, 18)` は複数回のループを経て最終的に最大公約数が 6 であると判定されます。このプロセスが理解できれば、他の 2 つの数の最大公約数を求める際にも同じ方法を適用することができます。

この例を使うと、ユークリッドの互除法の動作がより明確に理解できるかと思います。これで最大公約数の計算がどのように行われるか、なぜこれが正しい結果を導くのかがわかるでしょう。

---

# 008

このコードは、赤と青のカードに書かれた数字の合計が指定された値 `S` 以下となる組み合わせの数を計算するために使います。コードを順を追って解説します。

### 関数 `count(N, S)` の解説

1. **`cnt = 0`**:

   - まず、組み合わせの数をカウントするための変数 `cnt` を `0` で初期化します。ここに条件を満たす組み合わせの数を足していきます。

2. **`for A in range(1, N+1):`**:

   - ここで、赤のカードに書かれる数字 `A` を `1` から `N` までの範囲でループします。

3. **`max_B = min(N, S-A)`**:

   - 次に、青のカードに書かれる数字 `B` が取ることができる最大の値を `max_B` として計算します。`B` の最大値は、`N` と `S-A` の小さい方になります。これは、`B` が `N` を超えないことと、赤と青のカードの合計が `S` を超えないようにするためです。

4. **`if max_B >= 1:`**:

   - `max_B` が `1` 以上の場合にのみ、次のステップに進みます。これにより、無効な組み合わせ（つまり、`B` の範囲が `1` 未満のもの）をスキップできます。

5. **`cnt += max_B`**:

   - `max_B` だけ `cnt` に足します。これで、赤のカードが `A` であるとき、青のカードが取りうるすべての値の数をカウントに加えることができます。

6. **`return cnt`**:
   - 最後に、合計 `S` 以下のすべての組み合わせの数 `cnt` を返します。

### 関数 `main()` の解説

- **`N, S = map(int, input().split())`**:

  - ここで、標準入力から `N` と `S` の値を受け取り、それぞれ整数に変換します。

- **`print(count(N, S))`**:
  - 先ほど説明した `count` 関数を呼び出し、その結果を表示します。

### 実行の流れ

コードの実行は、`main()` 関数から始まります。標準入力から `N` と `S` を受け取り、それを使って `count(N, S)` を呼び出し、結果を表示します。

### 具体例での説明

#### 例 1: `N = 3`, `S = 4`

- `A = 1` のとき、`max_B = min(3, 4-1) = 3`。`B` は `[1, 2, 3]` の 3 通り。
- `A = 2` のとき、`max_B = min(3, 4-2) = 2`。`B` は `[1, 2]` の 2 通り。
- `A = 3` のとき、`max_B = min(3, 4-3) = 1`。`B` は `[1]` の 1 通り。
- 合計で `6` 通り。

#### 例 2: `N = 869`, `S = 120`

- `A = 1` のとき、`max_B = min(869, 120-1) = 119`。
- `A = 2` のとき、`max_B = min(869, 120-2) = 118`。
- `...`
- このようにして、すべての `A` に対して `max_B` を計算し、それを合計します。最終的な結果は `7140` になります。

### まとめ

このコードは、単純な二重ループを使う代わりに、`B` の範囲をうまく絞り込んで計算量を削減しています。これにより、非常に効率的に目的を達成しています。

## [補足] min と max_B の条件: 具体例で解説！

`max_B = min(N, S-A)` と `if max_B >= 1:` の条件について、具体例を使って分かりやすく説明します。

**状況設定**

- **N:** カードに書ける最大の整数 (例: N = 5 とします)
- **S:** 2 枚のカードに書かれた数の合計の上限 (例: S = 6 とします)
- **A:** 赤のカードに既に書かれた数字

**1. `max_B = min(N, S-A)`**

この行では、青のカードに書ける最大の数字 (`max_B`) を決めています。

- **`N` (カードに書ける最大の整数):** 常に `N` 以下でなければいけません。
- **`S - A` (合計の上限 - 赤のカードの数):** 合計が `S` を超えないためには、 `S - A` 以下でなければいけません。

`min(N, S-A)` を使うことで、これらの条件を両方満たす **より厳しい方の制限** を `max_B` として採用しています。

**具体例**

- **A = 1 のとき:** `max_B = min(5, 6-1) = min(5, 5) = 5` つまり、青のカードには `5` 以下の数字ならどれでも書けます。
- **A = 4 のとき:** `max_B = min(5, 6-4) = min(5, 2) = 2` つまり、青のカードには `2` 以下の数字しか書けません (3 以上は合計が S を超えてしまう)。

**2. `if max_B >= 1:`**

この条件は、 **「青のカードに書ける数字が少なくとも 1 つは存在するか」** をチェックしています。

- **`max_B` が 1 以上:** 青のカードに書ける数字が少なくとも 1 つはあるので、組み合わせが存在します。
- **`max_B` が 0 以下:** 青のカードに書ける数字はありません。これは、赤のカードに書いた数字が大きすぎて、どんな数字を青のカードに書いても合計が `S` を超えてしまう場合です。

**具体例**

- **A = 3 のとき:** `max_B = min(5, 6-3) = 3` となり、条件を満たすので組み合わせが存在します。
- **A = 6 のとき:** `max_B = min(5, 6-6) = 0` となり、条件を満たしません。これは、赤のカードに `6` を書くと、青のカードにどんな数字を書いても合計が `6` を超えてしまうためです。

**まとめ**

これらの条件によって、赤のカードに書いた数字に対して、青のカードに書ける数字の範囲を正しく決定し、組み合わせが存在するかどうかを判断しています。

---

# 009

このコードは、動的計画法（DP）を使って、カードの合計がちょうど `S` になるかどうかを確認するものです。以下に、コードの各部分の解説と具体的な事例を使って処理内容を説明します。

### コードの解説

#### 1. `dp(S, A)` 関数

```python
dp = [1] + [0] * S
```

- ここでは、`dp` というリストを作成しています。`dp[x]` が `1` ならば、合計 `x` を作ることが可能であることを意味します。
- 最初に `dp[0]` を `1` に設定しています。これは、カードを使わずに合計 `0` を作ることができることを意味します。

```python
for i in A:
    for j in range(S-i, -1, -1):
        if dp[j] == 1:
            dp[j+i] = 1
```

- 最初の `for` ループで、各カード `i` の値を順に処理します。
- 次の `for` ループでは、`j` を `S-i` から `0` まで逆に進めながら処理を行います。この逆向きの処理により、同じカードを複数回使うことを防いでいます。
- `dp[j]` が `1` であるなら、`j` の合計が既に作れることを意味するため、`j+i` の合計も作れるようになります。これを `dp[j+i] = 1` で示します。

```python
return "Yes" if dp[-1] == 1 else "No"
```

- 最終的に `dp[S]` が `1` であれば、合計 `S` を作ることが可能であるため "Yes" を返します。そうでない場合は "No" を返します。

#### 2. `main()` 関数

```python
N, S = map(int, input().split())
A = list(map(int, input().split()))
print(dp(S, A))
```

- `N` はカードの枚数、`S` は目標とする合計値です。
- `A` はカードに書かれた整数のリストです。
- これらを `dp(S, A)` 関数に渡して、結果を表示します。

### 事例を使った処理内容の説明

**例:**

```
入力:
N = 3, S = 11
A = [2, 5, 9]

dpテーブルの変化:
初期状態: dp = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

1番目のカード (2):
dp[0 + 2] = dp[2] = 1 になる
dp = [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]

2番目のカード (5):
dp[0 + 5] = dp[5] = 1 になる
dp[2 + 5] = dp[7] = 1 になる
dp = [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0]

3番目のカード (9):
dp[0 + 9] = dp[9] = 1 になる
dp[2 + 9] = dp[11] = 1 になる
dp = [1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1]

最終的なdpテーブル:
dp = [1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1]

dp[11] = 1 なので、結果は "Yes"
```

### 処理内容のまとめ

1. 最初は、`dp` テーブルで `0` の合計だけが作れる状態です。
2. 各カードを使って、新たな合計が作れるかを順に検討していきます。
3. 最後に、`S` が作れるかどうかを `dp[S]` を確認して判断します。

この方法は計算量が `O(N * S)` で、効率的かつ分かりやすいアプローチです。

---

# 011

このコードは、N 以下のすべての素数を見つけてリストとして返し、それを空白区切りで出力するものです。コードの各部分を初心者でも理解できるように、具体的な事例を使って詳細に説明します。

### コード全体の構成

1. **`prime(N)` 関数**: N 以下の素数を探す。
2. **`main()` 関数**: 入力を受け取り、`prime(N)` 関数を呼び出して結果を出力する。
3. **`if __name__ == "__main__":`**: スクリプトが直接実行されたときに`main()`を呼び出す。

### 1. `prime(N)` 関数の詳細

```python
def prime(N):
    primes = [True] * (N+1)
    primes[0] = primes[1] = False
    p = 2
    while p*p <= N:
        if primes[p]:
            for i in range(p*p, N+1, p):
                primes[i] = False
        p += 1
    return [i for i in range(N+1) if primes[i]]
```

#### **`primes = [True] * (N+1)`**

- ここでは、`primes`というリストを作成します。このリストは、N 以下の各数が素数かどうかを記録するためのものです。
- 初期値として、すべての数を`True`に設定します。`True`はその数が「素数である」と仮定することを意味します。
- `N+1`の長さにしているのは、0 から N までの数すべてをリストで表現するためです。

#### **`primes[0] = primes[1] = False`**

- 素数の定義により、0 と 1 は素数ではないため、これらを`False`に設定します。

#### **`p = 2`**

- 2 は最初の素数であり、素数を見つける処理を 2 から開始します。

#### **`while p*p <= N:`**

- この`while`ループは、p の平方（p²）が N 以下である限り繰り返されます。
- なぜ平方かというと、p より小さい約数を既に処理しているためです。

#### **`if primes[p]:`**

- もし`primes[p]`が`True`なら、p は素数であると考えます。
- 例えば、p=2 のとき、2 が素数かどうかを確認し、素数なら次のステップに進みます。

#### **`for i in range(p*p, N+1, p):`**

- p が素数であると分かった場合、その倍数はすべて素数ではないため、`False`に設定します。
- `range(p*p, N+1, p)`は、p² から N までの p の倍数を生成します。
- 例えば、p=2 のとき、`range(4, N+1, 2)`は 4, 6, 8, ... のように、2 の倍数を生成します。

#### **`p += 1`**

- p を 1 増やして、次の数字を確認します。

#### **`return [i for i in range(N+1) if primes[i]]`**

- 最後に、`primes`リストで`True`として残っている数を集めてリストとして返します。これが素数のリストになります。

### 2. `main()` 関数の詳細

#### **`N = int(input())`**

- ユーザーから N の値を入力として受け取ります。

#### **`print(*prime(N))`**

- `prime(N)`関数を呼び出して、N 以下の素数を見つけ、それを空白区切りで出力します。`*`はリストをアンパックして、各要素を個別に渡すことを意味します。

### 3. `if __name__ == "__main__":`

- この部分は、スクリプトが直接実行されたときに`main()`を呼び出すためのものです。

### 実例を使った解説

例えば、N=10 の場合の処理を順を追って見てみましょう。

1. `primes`リストは `[True, True, True, True, True, True, True, True, True, True, True]` と初期化されます。ここで、`primes[0]`と`primes[1]`が`False`に設定されます。

2. p=2 から始まり、2 が素数と判定されるため、その倍数である`primes[4]`, `primes[6]`, `primes[8]`, `primes[10]`が`False`に設定されます。

3. 次に p=3 となり、3 が素数と判定されます。`primes[9]`が`False`に設定されます（3 の倍数の中で 9 が唯一未処理）。

4. 最終的に、`primes`リストは `[False, False, True, True, False, True, False, True, False, False, False]` となり、`True`で残っている数が素数です。

5. これを基に、出力は `2 3 5 7` となります。

これが、N 以下の素数を見つけるための基本的な処理の流れです。

---

# 012

このコードは、与えられた数 `N` が素数であるかどうかを判定するためのものです。ここでは、コードの各部分を初心者にも分かりやすく、具体的な例を用いて解説します。

### 1. `is_prime` 関数の説明

```python
def is_prime(n):
    if n < 2: return False
    for i in range(2, int(n*0.5)+1):
        if n % i == 0:
            return False
    return True
```

#### - `n < 2` のチェック

まず、`n` が 2 未満の場合、素数とは見なされないため、`False` を返します。素数は 2 以上の自然数なので、例えば `n = 1` や `n = 0` の場合は、必ず `False` となります。

#### - 素数判定のためのループ

次に、`n` が 2 以上である場合、`2` から `n` の半分 (`n*0.5`) までの整数で割り切れるかどうかをチェックします。割り切れる整数が見つかった場合、その数は素数ではないため、`False` を返します。

- 例えば `n = 10` の場合、半分の `5` までの整数（`2`, `3`, `4`, `5`）で割り切れるかどうかをチェックします。`10` は `2` で割り切れるので、`False` が返されます。

- 逆に、`n = 7` の場合、半分の `3.5` を切り上げた `4` までの整数（`2`, `3`, `4`）で割り切れません。よって `True` が返されます。

#### - `return True`

最後に、上記のチェックをすべてクリアした場合、その数は素数であるため、`True` を返します。

### 2. `main` 関数の説明

```python
def main():
    N = int(input())
    print("Yes" if is_prime(N) else "No")
```

#### - `N = int(input())`

この行で、ユーザーから標準入力を通じて整数 `N` を取得します。例えば、ユーザーが `53` と入力した場合、`N` には `53` が代入されます。

#### - `print("Yes" if is_prime(N) else "No")`

`is_prime` 関数を使って、`N` が素数かどうかを判定します。素数であれば `True` が返ってくるので "Yes" を出力し、素数でなければ "No" を出力します。

- 例えば、`N = 53` なら `is_prime(53)` が `True` を返すので "Yes" と出力されます。
- 逆に、`N = 77` なら `is_prime(77)` が `False` を返すので "No" と出力されます。

### 3. 実行部分

```python
if __name__ == "__main__":
    main()
```

この部分は、スクリプトが直接実行されたときに `main` 関数を呼び出すためのものです。これにより、コードが実行されるときに `main()` が動き出します。

### 処理の流れを具体例で説明

#### - `N = 53` の場合

1. `main()` が実行され、`N` に `53` が代入されます。
2. `is_prime(53)` が呼ばれます。
3. `53` は 2 以上なので次のステップへ進みます。
4. `2` から `26` までの数で `53` を割り切れるかをチェックします。割り切れる数がないため `True` が返されます。
5. `True` が返されたので、"Yes" が出力されます。

#### - `N = 77` の場合

1. `main()` が実行され、`N` に `77` が代入されます。
2. `is_prime(77)` が呼ばれます。
3. `77` は 2 以上なので次のステップへ進みます。
4. `2` から `39` までの数で `77` を割り切れるかをチェックします。`77` は `7` で割り切れるため `False` が返されます。
5. `False` が返されたので、"No" が出力されます。

このように、このコードは素数を判定するためのシンプルで効果的な方法を提供しています。具体例を通じてコードの動作を理解することができたかと思います。

---

# 013

## Pythonで約数を求めるプログラム

このプログラムは、入力された整数 `N` の約数を全て求めて、それぞれを改行区切りで出力するものです。

**コードの解説:**

1. **`divisor(n)` 関数:**
   - この関数は、整数 `n` を受け取り、その約数のリストを返します。
   - `div = set()` : まず、空の集合 `div` を作成します。集合は、重複する要素を持たないデータ構造です。これにより、同じ約数が複数回出力されるのを防ぎます。
   - `for i in range(1, int(n**0.5)+1):`: 1 から `n` の平方根までの整数 `i` について、以下の処理を繰り返します。
     - `if n % i == 0:`:  `n` が `i` で割り切れる場合、つまり `i` が `n` の約数である場合、以下の処理を行います。
       - `div.add(i)`: `i` を集合 `div` に追加します。
       - `div.add(n // i)`: `n` を `i` で割った商もまた `n` の約数なので、これも集合 `div` に追加します。
   - `return sorted(div)`: 最後に、集合 `div` を昇順にソートしたリストを返します。

2. **`main()` 関数:**
   - この関数は、プログラムのメインの処理を行います。
   - `N = int(input())`: ユーザーからの入力を整数として受け取り、変数 `N` に格納します。
   - `print(*divisor(N), sep='\n')`: `divisor(N)` を呼び出して `N` の約数のリストを取得し、`print()` 関数を使って、それらの約数を改行 (`\n`) 区切りで出力します。 `*` はリストの要素を展開する役割を果たします。

3. **`if __name__ == "__main__":`:**
   - この部分は、このPythonファイルが直接実行された場合にのみ `main()` 関数を実行することを意味します。他のプログラムからこのファイルをモジュールとしてインポートする場合には、`main()` 関数は実行されません。

**処理の過程の例:**

例えば、`N` に 12 が入力された場合の処理過程は以下のようになります。

1. `divisor(12)` が呼び出されます。
2. `div` という空の集合が作成されます。
3. `for` ループで、`i` が 1 から 3 (12 の平方根は 3.46... なので、`int(12**0.5) + 1` は 4 になります) まで以下の処理が繰り返されます。
   - `i = 1`: 12 は 1 で割り切れるので、1 と 12 (12 // 1) が `div` に追加されます。
   - `i = 2`: 12 は 2 で割り切れるので、2 と 6 (12 // 2) が `div` に追加されます。
   - `i = 3`: 12 は 3 で割り切れるので、3 と 4 (12 // 3) が `div` に追加されます。
4. `div` ( `{1, 12, 2, 6, 3, 4}` ) がソートされ、 `[1, 2, 3, 4, 6, 12]` となります。
5. `[1, 2, 3, 4, 6, 12]` が `main()` 関数に返され、それぞれの要素が改行区切りで出力されます。

**出力:**

```
1
2
3
4
6
12
```

---

# 014

はい、このコードは素数を効率的に生成し、それを用いて素因数分解を行う優れたアプローチです。

## コードの解説

### 1. 素数生成関数 `prime(N)`

```python
def prime(N):
    primes = [True] * (N+1)
    primes[0] = primes[1] = False
    p = 2
    while p*p <= N:
        if primes[p]:
            for i in range(p*p, N+1, p):
                primes[i] = False
        p += 1
    return [i for i in range(N+1) if primes[i]]
```

この関数はエラトステネスの篩（ふるい）というアルゴリズムを使用して、2からNまでの素数のリストを生成します。

- `primes`リストを作成し、初めはすべての数を素数候補（`True`）とします。
- 0と1は素数ではないので`False`にします。
- 2から√Nまでの各数pについて：
  - pが素数なら、その倍数（p^2から始めて）をすべて素数でないとマークします。
- 最後に、`True`のままの指標に対応する数（つまり素数）のリストを返します。

例：N = 20の場合
結果: [2, 3, 5, 7, 11, 13, 17, 19]

### 2. 素因数分解関数 `prime_fractorization(n, primes)`

```python
def prime_fractorization(n, primes):
    fractors = []
    for i in primes:
        if i * i > n:
            break
        while n % i == 0:
            fractors.append(i)
            n //= i
    if n > 1:
        fractors.append(n)
    return fractors
```

この関数は、与えられた数nを素因数分解します。

- 生成された素数リスト`primes`の各素数iについて：
  - nがiで割り切れる限り、iを因数リストに追加し、nをiで割ります。
- 最後にnが1より大きければ、それ自体も素因数として追加します。

例：n = 60, primes = [2, 3, 5, 7, 11, 13, 17, 19]の場合
処理：
1. 2で割る：60 ÷ 2 = 30, fractors =
2. 2で割る：30 ÷ 2 = 15, fractors = [2, 2]
3. 3で割る：15 ÷ 3 = 5,  fractors = [2, 2, 3]
4. 5で割る：5 ÷ 5 = 1,   fractors = [2, 2, 3, 5]
結果: [2, 2, 3, 5]

### 3. メイン関数 `main()`

```python
def main():
    N = int(input())
    primes = prime(N)
    print(*prime_fractorization(N, primes))
```

- ユーザーから入力を受け取ります。
- その数までの素数リストを生成します。
- 入力された数を素因数分解し、結果を出力します。

## 処理の流れ（例：N = 60の場合）

1. ユーザーが60を入力
2. `prime(60)`を呼び出し、60までの素数リスト[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]を生成
3. `prime_fractorization(60, primes)`を呼び出し
4. 60を素因数分解：[2, 2, 3, 5]
5. 結果を出力：2 2 3 5

このアプローチは、特に大きな数の素因数分解を行う際に効率的です。素数のリストを事前に生成することで、試し割りの回数を大幅に減らすことができます。

---

# 015

## コード解説： ユークリッドの互除法による最大公約数計算

このPythonコードは、**ユークリッドの互除法**という効率的なアルゴリズムを使って、2つの整数の最大公約数 (GCD) を計算します。

**コードの構成:**

1. **`gcd(a, b)` 関数:**
   - この関数は、引数として2つの整数 `a` と `b` を受け取り、それらの最大公約数を計算して返します。
   - ユークリッドの互除法のロジックを実装しています。

2. **`main()` 関数:**
   - プログラムの主要な処理を行う関数です。
   - ユーザーから2つの整数を入力として受け取り、`gcd()` 関数を呼び出して最大公約数を計算し、結果を表示します。

3. **`if __name__ == "__main__":` ブロック:**
   - このブロックは、スクリプトが直接実行された場合にのみ `main()` 関数を呼び出します。
   - これにより、このスクリプトを他のモジュールからインポートする場合に、`main()` 関数が自動的に実行されるのを防ぎます。

**ユークリッドの互除法の解説:**

このアルゴリズムは、以下の手順で最大公約数を計算します。

1. **大きい方の数を小さい方の数で割った余りを求める。**
2. **元の小さい方の数と余りを用いて、再度1の操作を行う。**
3. **余りが0になるまで1と2の操作を繰り返す。**
4. **余りが0になったときの、割る数（0ではない方）が最大公約数となる。**

**コードの処理内容： 例を用いた説明**

例えば、`A = 24`、`B = 18` の場合を考えます。

1. **`main()` 関数:**
   - `input().split()` によって、ユーザーは "24 18" のように2つの数字をスペースで区切って入力します。
   - `map(int, ...)` は、入力された文字列を整数に変換し、`A` には 24、`B` には 18 がそれぞれ代入されます。
   - `gcd(24, 18)` を呼び出して、最大公約数を計算します。

2. **`gcd(24, 18)` 関数:**
   - **1回目:**
     - `b` (18) は 0 ではないため、`while` ループに入ります。
     - `a` (24) を `b` (18) で割った余り (`24 % 18`) は 6 となります。
     - `a` には `b` の値 (18) が、`b` には余りの値 (6) が代入されます。
   - **2回目:**
     - `b` (6) はまだ 0 ではありません。
     - `a` (18) を `b` (6) で割った余り (`18 % 6`) は 0 となります。
     - `a` には `b` の値 (6) が、`b` には余りの値 (0) が代入されます。
   - **ループ終了:**
     - `b` が 0 になったため、`while` ループが終了します。
   - `a` の値 (6) が `return` されます。

3. **`main()` 関数 (続き):**
   - `gcd(24, 18)` の戻り値 (6) が `print()` によって画面に表示されます。

**まとめ**

このコードは、ユークリッドの互除法という効率的なアルゴリズムを使って、2つの整数の最大公約数を計算します。ユークリッドの互除法は、再帰的に余りを計算することで、最大公約数を高速に見つけることができます。

---
# 016

## 最大公約数を求めるプログラム解説

このプログラムは、複数の整数の最大公約数 (GCD: Greatest Common Divisor) を求めるものです。

### 1. ユークリッドの互除法

最大公約数を求めるために、 **ユークリッドの互除法** という方法を使っています。 これは、2つの数 `a` と `b` (ただし `a > b`) について、

-  `a` を `b` で割った余りを `r` とすると (`a % b = r`)、
-  `a` と `b` の最大公約数は、`b` と `r` の最大公約数と同じになる

という性質を利用した方法です。 これを繰り返していくと、最終的に余りが `0` になり、その時の `b` の値が最大公約数になります。

例えば、12 と 18 の最大公約数を求める場合:

1. 18 ÷ 12 = 1 余り 6
2. 12 ÷ 6 = 2 余り 0

よって、12 と 18 の最大公約数は 6 となります。

### 2. コードの解説

#### 2-1. `gcd(a, b)` 関数:

- この関数は、ユークリッドの互除法を使って、2つの整数 `a` と `b` の最大公約数を計算します。
- `while b != 0:` は、`b` が 0 になるまでループを繰り返すことを意味します。
- ループの中では、`a` と `b` の値を更新しています。 `a` には `b` の値を、`b` には `a` を `b` で割った余り (`a % b`) を代入しています。
- 最終的に `b` が 0 になった時の `a` の値が、`a` と `b` の最大公約数なので、`return a` でその値を返します。

#### 2-2. `gcd_list(A)` 関数:

- この関数は、整数のリスト `A` を受け取り、そのリスト内の全ての要素の最大公約数を計算します。
- `res = A[0]` で、リストの最初の要素を初期値として `res` に代入します。
- `for i in A[1:]:` で、リストの2番目の要素から順番に `i` に代入してループを回します。
- ループの中では、`res` と `i` の最大公約数を `gcd(res, i)` で計算し、その結果を再び `res` に代入します。
- これを繰り返すことで、`res` にはリスト `A` の全ての要素の最大公約数が格納されていきます。
- 最終的に、`return res` で計算結果を返します。

#### 2-3. `main()` 関数:

- プログラムのメイン処理を行います。
- `N = int(input())` で、整数の個数 `N` を入力として受け取ります。
- `A = list(map(int, input().split()))` で、`N` 個の整数をスペース区切りで入力として受け取り、リスト `A` に格納します。
- `print(gcd_list(A))` で、`gcd_list(A)` 関数を呼び出して最大公約数を計算し、その結果を出力します。

#### 2-4. `if __name__ == "__main__":` :

- このプログラムが直接実行された場合にのみ、`main()` 関数を実行します。

### 3. 実行例

例えば、入力として以下のようなデータが与えられたとします。

```
3  # 整数の個数 N
12 18 24 # 整数のリスト A
```

1. `main()` 関数内で、`N` には `3` が、`A` には `[12, 18, 24]` が格納されます。
2. `gcd_list([12, 18, 24])` が実行されます。
    - `res` に `12` が代入されます。
    - 1回目のループ: `gcd(12, 18) = 6` なので、`res` に `6` が代入されます。
    - 2回目のループ: `gcd(6, 24) = 6` なので、`res` に `6` が代入されます。
3. `gcd_list([12, 18, 24])` は `6` を返します。
4. `main()` 関数内の `print()` によって `6` が出力されます。

このように、このプログラムはユークリッドの互除法を用いて、複数の整数の最大公約数を効率的に計算することができます.

---
# 017

## ユークリッドの互除法で最小公倍数が求められる理由

ユークリッドの互除法は、一見最大公約数を求めるためのアルゴリズムですが、なぜ最小公倍数の計算にも使えるのでしょうか？その理由を詳しく解説します。

### 最大公約数と最小公倍数の関係

**最大公約数 (GCD)** と **最小公倍数 (LCM)** の間には、以下の関係が成り立ちます。

- **2 つの自然数 a, b の積** = **a, b の最大公約数** × **a, b の最小公倍数**

つまり、

```
a × b = GCD(a, b) × LCM(a, b)
```

が成り立ちます。

### ユークリッドの互除法と最小公倍数の関係

ユークリッドの互除法を用いて、2 つの数の最大公約数 GCD(a, b) を求めることができます。上記の式を変形すると、

```
LCM(a, b) = (a × b) / GCD(a, b)
```

となります。

つまり、**2 つの数の積を、ユークリッドの互除法で求めた最大公約数で割る**ことで、最小公倍数が求められるのです。

### なぜこの関係が成り立つのか？

この関係が成り立つ直感的な理由としては、以下のことが挙げられます。

- **最大公約数:** 2 つの数に共通する約数のうち、最大のものです。
- **最小公倍数:** 2 つの数を両方割り切ることができる最小の自然数です。

最大公約数は、2 つの数に共通する部分を表し、最小公倍数は、2 つの数を包含する部分を表します。この 2 つの概念は、ある意味で逆の関係にあります。

**具体例:**
2 つの数 12 と 18 を例に考えてみましょう。

- 12 = 2^2 × 3
- 18 = 2 × 3^2

- 最大公約数: 2 × 3 = 6
- 最小公倍数: 2^2 × 3^2 = 36

12 と 18 の積は、2^3 × 3^3 です。この積を最大公約数 6 で割ると、最小公倍数 36 が得られます。

### まとめ

ユークリッドの互除法で最大公約数を求めることで、最小公倍数も計算できるのは、最大公約数と最小公倍数の間の深い関係があるからです。この関係式は、数論において非常に重要な概念であり、様々な問題を解く際に役立ちます。

**ポイント:**

- ユークリッドの互除法は、最大公約数だけでなく、最小公倍数の計算にも応用できる。
- 最大公約数と最小公倍数は、ある意味で逆の関係にある。
- 2 つの数の積を最大公約数で割ると、最小公倍数が得られる。

**コードの解説:**
```python
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def lcm_list(A):
    res = A[0]
    for i in A[1:]:
        res = lcm(res, i)
    return res

def main():
    N = int(input())
    A = list(map(int, input().split()))
    print(lcm_list(A))

if __name__ == "__main__":
    main()
```

1. **`gcd(a, b)` 関数:**
   - 2つの整数 `a` と `b` の最大公約数 (GCD) を計算します。
   - ユークリッドの互除法という効率的なアルゴリズムを使用しています。
     - `b` が 0 になるまで、`(a, b)` を `(b, a % b)` で繰り返し置き換えます。
     - 最終的に `b` が 0 になったときの `a` が最大公約数です。

2. **`lcm(a, b)` 関数:**
   - 2つの整数 `a` と `b` の最小公倍数 (LCM) を計算します。
   - 最小公倍数は、2つの数の積を最大公約数で割ることによって求められます。
     - `return a * b // gcd(a, b)`

3. **`lcm_list(A)` 関数:**
   - 整数のリスト `A` を入力として受け取り、リスト内のすべての整数の最小公倍数を計算します。
   - 最初に、結果を格納する変数 `res` をリストの最初の要素 `A[0]` に初期化します。
   - 次に、リストの2番目の要素から最後の要素まで順番に処理します。
     - 各要素 `i` について、`res` と `i` の最小公倍数を計算し、その結果を `res` に格納します。
   - 最後に、計算された最小公倍数 `res` を返します。

4. **`main()` 関数:**
   - プログラムのメイン処理を行います。
   - まず、入力として整数 `N` を受け取ります。これは、リストの要素数を表します。
   - 次に、空白区切りで入力された `N` 個の整数を `map(int, input().split())` を使って整数に変換し、リスト `A` に格納します。
   - `lcm_list(A)` 関数を呼び出して、リスト `A` の最小公倍数を計算し、結果を出力します。

5. **`if __name__ == "__main__":`:**
   - この部分は、Pythonスクリプトが直接実行された場合にのみ `main()` 関数を呼び出すために使用されます。

**事例:**

入力として `[12, 18, 14]` が与えられた場合の処理内容をステップごとに説明します。

1. `main()` 関数で、`N = 3`, `A = [12, 18, 14]` となります。
2. `lcm_list([12, 18, 14])` が呼び出されます。
   - `res = 12` で初期化されます。
   - `i = 18` のとき:
     - `lcm(12, 18)` が呼び出され、`gcd(12, 18) = 6` なので、`lcm(12, 18) = 36` となります。
     - `res` が 36 に更新されます。
   - `i = 14` のとき:
     - `lcm(36, 14)` が呼び出され、`gcd(36, 14) = 2` なので、`lcm(36, 14) = 252` となります。
     - `res` が 252 に更新されます。
3. `lcm_list([12, 18, 14])` は 252 を返します。
4. `main()` 関数で、252 が出力されます。

したがって、`[12, 18, 14]` の最小公倍数は 252 となります。


---
# 018

このコードは、動的計画法を使って、商品の値段リスト `A` から、2つの商品の合計金額が500円になる組み合わせがいくつあるかを効率的に計算しています。

**コードの解説**

1. **`dp(A)` 関数:**
   - `dp = [0] * 401`: これは、金額を添字としたリスト `dp` を作成し、全ての要素を0で初期化しています。`dp[i]` は、商品の合計金額が `i` 円になる組み合わせの数を表します。
     - 例えば、`dp[100]` は、商品の合計金額が100円になる組み合わせの数、`dp[300]` は合計金額が300円になる組み合わせの数を表します。
     - リストのサイズは401としているのは、商品の最大金額が400円なので、組み合わせで実現できる最大の金額は800円となり、計算に必要な範囲をカバーするためです (今回は500円までで十分ですが)。
   - `count = 0`: これは、合計金額が500円になる組み合わせの数をカウントするための変数です。

   - `for price in A:`: 入力された商品の値段リスト `A` から、一つずつ `price` を取り出して処理を行います。
     - `if price < 500:`:  現在の商品の値段 `price` が500円未満の場合のみ、以下の処理を行います。500円以上の場合は組み合わせで500円を作ることはできないためです。
       - `count += dp[500 - price]`:  `dp[500 - price]` は、現在見ている商品と組み合わせると合計金額が500円になるような、**既に登場した商品の組み合わせの数** を表しています。これを `count` に加算することで、500円になる組み合わせを効率的に数えています。

     - `dp[price] += 1`:  現在の商品の値段 `price` が登場した回数を記録します。これは、以降の商品の処理で、`price` と組み合わせられる可能性があるためです。

   - `return count`:  最後に、合計金額が500円になる組み合わせの数 `count` を返します。

2. **`main()` 関数:**
   - `_ = input()`:  商品の個数を受け取りますが、このコードでは使用しないので、変数には格納せずに読み飛ばしています。
   - `A = map(int, input().split())`:  商品の値段リスト `A` を受け取ります。
   - `print(dp(A))`:  `dp(A)` 関数を呼び出して計算結果を表示します。

**事例を使った処理内容の説明**

例えば、入力例として `A = [100, 300, 400, 400, 200]` が与えられたとします。

1. `price = 100` のとき:
   - `count += dp[400]` (現時点では `dp[400] = 0`)
   - `dp[100] += 1` (`dp[100]` は 1 になります)

2. `price = 300` のとき:
   - `count += dp[200]` (現時点では `dp[200] = 0`)
   - `dp[300] += 1` (`dp[300]` は 1 になります)

3. `price = 400` のとき:
   - `count += dp[100]` (`dp[100]` は 1 なので、`count` が 1 になります)
   - `dp[400] += 1` (`dp[400]` は 1 になります)

4. `price = 400` のとき:
   - `count += dp[100]` (`dp[100]` は 1 なので、`count` が 2 になります)
   - `dp[400] += 1` (`dp[400]` は 2 になります)

5. `price = 200` のとき:
   - `count += dp[300]` (`dp[300]` は 1 なので、`count` が 3 になります)
   - `dp[200] += 1` (`dp[200]` は 1 になります)

最終的に `count` は 3 となり、これが合計金額が500円になる組み合わせの数となります。

このように、このコードは動的計画法を用いることで、効率的に組み合わせの数を計算しています。

---
# 019

このコードの目的は、与えられたカードのリストの中から、同じ色のカード2枚を選ぶ方法が何通りあるかを計算することです。カードには3種類の色があり、色は数値 `1`（赤）、`2`（黄色）、`3`（青）で表されます。

### コードの解説

#### 1. `count_pairs(A)` 関数
この関数は、リスト `A` に含まれる色ごとのカードの枚数をカウントし、同じ色のカードを2枚選ぶ方法の数を返します。

```python
def count_pairs(A):
    count = [A.count(color) for color in (1, 2, 3)]
    return sum(c * (c - 1) // 2 for c in count)
```

- **`A.count(color)`**: リスト `A` の中で指定した色 (`color`) が何回出現するかをカウントします。`color` は `1, 2, 3` という3つの色を順に調べます。
  - `A.count(1)` は `A` の中で赤色カード（1）の枚数を返し、同様に `A.count(2)` は黄色カード、`A.count(3)` は青色カードの枚数を返します。
  - この結果はリスト内包表記で `count` というリストに保存されます。
    - 例えば、`count = [赤の枚数, 黄の枚数, 青の枚数]` というリストになります。

- **`sum(c * (c - 1) // 2 for c in count)`**: この部分は、各色ごとにカードを2枚選ぶ組み合わせ数を計算します。
  - `c * (c - 1) // 2` は、`c` 枚のカードから2枚を選ぶ組み合わせの数を表します。例えば、3枚のカードがあれば `3 * 2 // 2 = 3` 通りの組み合わせが作れます。
  - これを各色（赤、黄、青）について計算し、その合計を返します。

#### 2. `main()` 関数
この関数は、プログラムの実行の流れを制御する役割を持っています。

```python
def main():
    N = int(input())
    A = list(map(int, input().split()))
    print(count_pairs(A))
```

- **`N = int(input())`**: 入力される整数を受け取り、カードの枚数 `N` に格納します。
- **`A = list(map(int, input().split()))`**: 入力されたカードの色情報をリストとして受け取り、`A` に格納します。各カードの色はスペース区切りで入力されます。
- **`print(count_pairs(A))`**: `count_pairs()` 関数を呼び出して結果を計算し、それを出力します。

#### 3. `if __name__ == "__main__():`
```python
if __name__ == "__main__":
    main()
```

この部分は、スクリプトを直接実行した場合に `main()` 関数を呼び出すためのものです。Pythonでは、このようにしてメインの処理を行うことが一般的です。

### 処理内容の説明（例を使って）

**入力例:**
```
6
1 3 2 1 1 2
```

1. **入力の読み取り**
   - `N = 6`: カードの枚数は6枚です。
   - `A = [1, 3, 2, 1, 1, 2]`: 各カードの色は、順に赤(1), 青(3), 黄(2), 赤(1), 赤(1), 黄(2)です。

2. **色の枚数をカウント**
   - `count = [3, 2, 1]`: 赤色カードが3枚、黄色カードが2枚、青色カードが1枚です。

3. **組み合わせ数を計算**
   - 赤色カード: `3 * (3 - 1) // 2 = 3` 通り（3枚から2枚を選ぶ組み合わせ）。
   - 黄色カード: `2 * (2 - 1) // 2 = 1` 通り（2枚から2枚を選ぶ組み合わせ）。
   - 青色カード: `1 * (1 - 1) // 2 = 0` 通り（1枚しかないため、選べません）。
   - 合計で、`3 + 1 + 0 = 4` 通りです。

4. **結果の出力**
   - 結果は `4` なので、この例の場合は、同じ色のカードを2枚選ぶ方法が4通りあることがわかります。

### 結論

このコードは、リスト内包表記と組み合わせ数の計算を簡潔に書いています。初心者向けのポイントとしては、リストの `count` 関数や、組み合わせの計算式 `c * (c - 1) // 2` の意味を理解することが重要です。このコードはとても効率的で、入力されるカードの枚数が大きくても高速に動作します。

---
# 020

## コード解説

このコードは、動的計画法 (DP) を使って、与えられた整数列 `A` から重複なく5個の数字を選び、その和が1000になる組み合わせの数を計算します。

```python
def calc(A):
    dp = [[0] * 1001 for _ in range(6)]
    dp[0][0] = 1

    for num in A:
        for k in range(4, -1, -1):
            for s in range(1000 - num + 1):
                dp[k + 1][s + num] += dp[k][s]
    return dp[5][1000]

def main():
    N = int(input())
    A = list(map(int, input().split()))
    print(calc(A))

if __name__ == "__main__":
    main()
```

### 1. `calc(A)` 関数

#### 1.1. 変数

- `dp`: 動的計画法のテーブル。`dp[k][s]` は、`A` の先頭から何個かまでの数字を使い、ちょうど `k` 個の数字を選んで合計を `s` にできる組み合わせの数 を表します。
- `num`:  入力 `A` から順に取り出される整数。

#### 1.2. 初期化

- `dp[0][0] = 1`: 数字を一つも選ばない (`k=0`) 時に和が0 (`s=0`) になる組み合わせは1通りなので、1で初期化します。

#### 1.3. ループ処理

- **外側のループ**: `A` の各数字 `num` について処理を行います。
- **中側のループ**:  選ぶ数字の個数 `k` を減らしながらループします (`4, 3, 2, 1, 0`)。 `k` を降順に処理することで、同じ数字を複数回使ってしまうことを防いでいます。
- **内側のループ**:  `s` は、`k` 個の数字を選んだ時の和を表す変数で、`1000 - num` から `0` まで降順にループします。

#### 1.4. 更新処理

- `dp[k + 1][s + num] += dp[k][s]`:  `k` 個の数字で和を `s` にできる組み合わせ数に、`num` を加えることで、`k+1` 個の数字で和を `s + num` にできる組み合わせ数を計算し、`dp[k+1][s+num]` に加算しています。

#### 1.5. 返り値

- `dp[5][1000]`:  最終的に、`5` 個の数字を選んで和を `1000` にできる組み合わせの数を返します。

### 2. `main()` 関数

- 入力を受け取り、`calc(A)` を呼び出して結果を出力します。


## 事例を使った説明

例えば、`A = [100, 200, 300, 400, 500]` の場合を考えます。

1. `num = 100` のループ処理では、`dp[1][100]` が 1 になります。
2. `num = 200` のループ処理では、`dp[1][200]`, `dp[2][300]` がそれぞれ 1 になります。
3. `num = 300` のループ処理では、`dp[1][300]`, `dp[2][500]`, `dp[3][600]` がそれぞれ 1 になります。
4. `num = 400` のループ処理では、`dp[1][400]`, `dp[2][600]`, `dp[3][700]`, `dp[4][900]` がそれぞれ 1 になります。
5. `num = 500` のループ処理では、`dp[1][500]`, `dp[2][700]`, `dp[3][800]`, `dp[4][1000]`, `dp[5][1000]` がそれぞれ 1 になります。

最終的に `dp[5][1000] = 1` となり、和が1000になる組み合わせが1通り存在することが分かります。


## まとめ

このコードは、動的計画法を使って効率的に組み合わせの数を計算しています。ループの順番や添字の扱いに工夫があり、理解するには少し練習が必要かもしれません。しかし、一度理解してしまえば、様々な組み合わせの問題に応用することができます。

## [補足] ループ処理部分の詳細説明

ここでは、プログラムの核心部分であるトリプルループの動作を詳しく説明します。

```python
for num in A:
    for k in range(4, -1, -1):
        for s in range(1000 - num + 1):
            dp[k + 1][s + num] += dp[k][s]
```

## ループの意味

1. `for num in A:`
   - 各カードの値（`num`）について処理を行います。

2. `for k in range(4, -1, -1):`
   - `k`は現在使用しているカードの枚数を表します。
   - 4から0まで逆順に処理します。これは新しいカードを追加する際、既存の組み合わせに影響を与えないようにするためです。

3. `for s in range(1000 - num + 1):`
   - `s`は現在の合計を表します。
   - 新しいカード`num`を追加しても1000を超えない範囲で処理します。

4. `dp[k + 1][s + num] += dp[k][s]`
   - `k`枚のカードで合計`s`を作る方法の数を、`k+1`枚のカードで合計`s+num`を作る方法の数に加算します。

## 具体例での説明

入力例：`A = [100, 150, 200, 250, 300]`

最初の2枚のカード（100と150）の処理を詳細に見ていきます。

### カード100の処理

```python
num = 100
for k in range(4, -1, -1):
    for s in range(1000 - 100 + 1):  # 0から900まで
        dp[k + 1][s + 100] += dp[k][s]
```

初期状態：`dp[0][0] = 1`、他はすべて0

1. `k = 4`のとき：何も更新されません（`dp[4][s]`がすべて0のため）
2. `k = 3`のとき：何も更新されません
3. `k = 2`のとき：何も更新されません
4. `k = 1`のとき：何も更新されません
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][100] += dp[0][0]`
     結果：`dp[1][100] = 1`（1枚で100を作る方法が1通り）

### カード150の処理

```python
num = 150
for k in range(4, -1, -1):
    for s in range(1000 - 150 + 1):  # 0から850まで
        dp[k + 1][s + 150] += dp[k][s]
```

1. `k = 4`のとき：何も更新されません
2. `k = 3`のとき：何も更新されません
3. `k = 2`のとき：何も更新されません
4. `k = 1`のとき：
   - `s = 100`の場合：`dp[2][250] += dp[1][100]`
     結果：`dp[2][250] = 1`（2枚で250を作る方法が1通り、100+150）
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][150] += dp[0][0]`
     結果：`dp[1][150] = 1`（1枚で150を作る方法が1通り）

### カード200の処理

```python
num = 200
for k in range(4, -1, -1):
    for s in range(1000 - 200 + 1):  # 0から800まで
        dp[k + 1][s + 200] += dp[k][s]
```

処理前の状態：
- `dp[1][100] = 1`
- `dp[1][150] = 1`
- `dp[2][250] = 1`

1. `k = 4`のとき：何も更新されません
2. `k = 3`のとき：何も更新されません
3. `k = 2`のとき：
   - `s = 250`の場合：`dp[3][450] += dp[2][250]`
     結果：`dp[3][450] = 1`（3枚で450を作る方法が1通り、100+150+200）
4. `k = 1`のとき：
   - `s = 100`の場合：`dp[2][300] += dp[1][100]`
     結果：`dp[2][300] = 1`（2枚で300を作る方法が1通り、100+200）
   - `s = 150`の場合：`dp[2][350] += dp[1][150]`
     結果：`dp[2][350] = 1`（2枚で350を作る方法が1通り、150+200）
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][200] += dp[0][0]`
     結果：`dp[1][200] = 1`（1枚で200を作る方法が1通り）

### カード250の処理

```python
num = 250
for k in range(4, -1, -1):
    for s in range(1000 - 250 + 1):  # 0から750まで
        dp[k + 1][s + 250] += dp[k][s]
```

1. `k = 4`のとき：何も更新されません
2. `k = 3`のとき：
   - `s = 450`の場合：`dp[4][700] += dp[3][450]`
     結果：`dp[4][700] = 1`（4枚で700を作る方法が1通り、100+150+200+250）
3. `k = 2`のとき：
   - `s = 300`の場合：`dp[3][550] += dp[2][300]`
     結果：`dp[3][550] = 1`（3枚で550を作る方法が1通り、100+200+250）
   - `s = 350`の場合：`dp[3][600] += dp[2][350]`
     結果：`dp[3][600] = 1`（3枚で600を作る方法が1通り、150+200+250）
4. `k = 1`のとき：
   - `s = 100`の場合：`dp[2][350] += dp[1][100]`
     結果：`dp[2][350] = 2`（2枚で350を作る方法が2通り、150+200と100+250）
   - `s = 150`の場合：`dp[2][400] += dp[1][150]`
     結果：`dp[2][400] = 1`（2枚で400を作る方法が1通り、150+250）
   - `s = 200`の場合：`dp[2][450] += dp[1][200]`
     結果：`dp[2][450] = 1`（2枚で450を作る方法が1通り、200+250）
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][250] += dp[0][0]`
     結果：`dp[1][250] = 1`（1枚で250を作る方法が1通り）

### カード300の処理

```python
num = 300
for k in range(4, -1, -1):
    for s in range(1000 - 300 + 1):  # 0から700まで
        dp[k + 1][s + 300] += dp[k][s]
```

1. `k = 4`のとき：
   - `s = 700`の場合：`dp[5][1000] += dp[4][700]`
     結果：`dp[5][1000] = 1`（5枚で1000を作る方法が1通り、100+150+200+250+300）
2. `k = 3`のとき：
   - `s = 550`の場合：`dp[4][850] += dp[3][550]`
     結果：`dp[4][850] = 1`（4枚で850を作る方法が1通り、100+200+250+300）
   - `s = 600`の場合：`dp[4][900] += dp[3][600]`
     結果：`dp[4][900] = 1`（4枚で900を作る方法が1通り、150+200+250+300）
3. `k = 2`, `k = 1`, `k = 0`のときの処理も同様に行われます...

### 最終結果

すべてのカードの処理が終わった後、`dp[5][1000] = 1` となります。これは、5枚のカードを使って合計1000を作る方法が1通りあることを意味します。

この例では、唯一の組み合わせは 100 + 150 + 200 + 250 + 300 = 1000 となります。

このプロセスを通じて、プログラムは効率的にすべての可能な組み合わせを探索し、条件を満たす組み合わせの数を数えています。各ステップで `dp` 配列を更新することで、以前の計算結果を再利用し、計算量を大幅に削減しています。


---

# 021

  $\mathbf{u} \cdot \mathbf{v} = |\mathbf{u}| |\mathbf{v}| \cos \theta $

このコードは、組み合わせ $_nC_r$ を計算するための関数を実装しています。

### `comb(n, r)` 関数の解説

#### 1. `r = min(r, n - r)`
この行は、計算を効率化するための工夫です。組み合わせ $_nC_r$ の式は対称性を持っており、次のように成り立ちます：

$${ {}_nC_{r} = {}_nC_{n - r} }$$

したがって、 $r$ を $\min(r, n - r)$ とすることで、計算する項数を減らすことができます。<br>
たとえば、 $n = 6, r = 4$ の場合、 $ _6C_4 $ = $ _6C_2 $ なので、2つ選ぶ場合の計算だけで済みます。<br>
これにより、より少ない回数で計算できます。

#### 2. `res = 1`
ここで変数 `res` は最終的な結果を保存する変数です。最初に 1 で初期化し、ループで掛け算を繰り返していきます。

#### 3. `for i in range(r):`
このループは、組み合わせの公式に基づいて計算を行います。例えば、\( $_nC_r$\) は次の式で計算できます：
<br>&nbsp;&nbsp;&nbsp;&nbsp;
$_nC_r = \dfrac{n \times (n-1) \times \dots \times (n-r+1)}{r \times (r-1) \times \dots \times 1}$

このループでは、分子部分 \( $n \times (n-1) \times \dots$ \) を `res` に掛け算しながら、同時に分母部分 \( $r \times (r-1) \times \dots$ \) で割り算していきます。<br>
これにより、大きな数の階乗を計算することなく、計算が完了します。

#### 4. `res = res * (n - i) // (i + 1)`
この式は、分子と分母の掛け算・割り算を同時に行っています。
- `n - i` は分子の \( $n, n-1, n-2, \dots$ \) に対応しています。
- `i + 1` は分母の \( $1, 2, 3, \dots$ \) に対応しています。

ループの各ステップで `res` に値を計算していきます。

#### 5. `return res`
最終的に計算された組み合わせの結果を返します。

### `main()` 関数の解説

1. `n, r = map(int, input().split())`:
   ユーザーから入力を受け取り、`n` と `r` に整数として代入します。入力は空白区切りで与えられます。

2. `print(comb(n, r))`:
   `comb(n, r)` 関数を呼び出して結果を計算し、`print()` 関数で結果を出力します。

### `if __name__ == "__main__":`

これは、プログラムが直接実行された場合にのみ `main()` 関数が呼び出されるようにするための構造です。<br>
通常、スクリプトをモジュールとしてインポートされた場合、`main()` 関数は実行されません。

---

### 処理の内容を事例で説明

#### 事例: \( $n = 6, r = 2$ \)

1. **`comb(n=6, r=2)` を呼び出す**
   - 最初に `r = min(2, 6-2) = 2` です。この時、\( $r$ \) は変わらず 2 のままです。
   - `res = 1` で初期化します。

2. **ループの1回目 (i=0)**
   - `res = res * (6 - 0) // (0 + 1) = 1 * 6 // 1 = 6`
   - `res` の値は 6 になります。

3. **ループの2回目 (i=1)**
   - `res = res * (6 - 1) // (1 + 1) = 6 * 5 // 2 = 30 // 2 = 15`
   - `res` の値は 15 になります。

4. **ループ終了**
   - `r = 2` のため、2回のループが終了し、`res` は 15 です。

5. **結果を返す**
   - `comb(6, 2)` の結果は 15 となり、最終的に `print()` でこの値が出力されます。

---

### 出力例
入力:
```
6 2
```

出力:
```
15
```

このコードは、計算を効率化しつつシンプルに組み合わせを求めるためのものです。

---
# 022

```python
def count_pairs(A):
    count = {}
    res = 0
    for a in A:
        if 100000 - a in count:
            res += count[100000 - a]

        if a in count:
            count[a] += 1
        else:
            count[a] = 1
    return res

def main():
    N = int(input())
    A = map(int, input().split())
    print(count_pairs(A))

if __name__ == "__main__":
    main()
```

以下は、`count_pairs` 関数とその動作についての詳細な説明です。

### コードの解説

1. **`count_pairs(A)` 関数の目的**:
   - 与えられたカードのリスト `A` から、和が `100000` になるペアの組み合わせの数をカウントする関数です。

2. **変数の初期化**:
   - `count = {}`: カードの値ごとに、これまで出現した回数を記録する辞書です。キーはカードの値、値はそのカードの出現回数です。
   - `res = 0`: 結果として、和が `100000` になるペアの組み合わせの数を保持します。

3. **メインループ**:
   - `for a in A`: リスト `A` 内のカードの値を一つずつ取り出して処理します。

   - **ペアをチェック**:
     - `if 100000 - a in count`: 現在のカード `a` に対して、和が `100000` になるカードが `count` 辞書に既に存在しているか確認します。もし存在すれば、そのカードとペアを組むことができるので、その出現回数分だけ結果 `res` に加算します。

   - **出現回数を更新**:
     - `if a in count`: すでにカード `a` が辞書に存在していれば、その出現回数を1増やします。
     - `else: count[a] = 1`: もしカード `a` が初めて出現した場合、辞書に追加し、その出現回数を1とします。

4. **結果の返却**:
   - ループを通じて見つけたペアの組み合わせの数を `res` として返します。

### 入力と処理の流れの例

**例：**
入力：`N = 6`
カードのリスト `A = [40000, 50000, 20000, 80000, 50000, 30000]`

1. 初期状態：
   - `count = {}` （空の辞書）
   - `res = 0` （ペアの数）

2. 各カードに対する処理：

   - **1枚目 (a = 40000)**:
     - `100000 - 40000 = 60000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1}` として、40000 の出現回数を 1 に設定します。

   - **2枚目 (a = 50000)**:
     - `100000 - 50000 = 50000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1, 50000: 1}` として、50000 の出現回数を 1 に設定します。

   - **3枚目 (a = 20000)**:
     - `100000 - 20000 = 80000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1, 50000: 1, 20000: 1}` として、20000 の出現回数を 1 に設定します。

   - **4枚目 (a = 80000)**:
     - `100000 - 80000 = 20000` が `count` に存在するため、`res` に `count[20000]` の値 1 を加算します。
     - `res = 1`
     - `count = {40000: 1, 50000: 1, 20000: 1, 80000: 1}` として、80000 の出現回数を 1 に設定します。

   - **5枚目 (a = 50000)**:
     - `100000 - 50000 = 50000` が `count` に存在するため、`res` に `count[50000]` の値 1 を加算します。
     - `res = 2`
     - `count = {40000: 1, 50000: 2, 20000: 1, 80000: 1}` として、50000 の出現回数を 2 に設定します。

   - **6枚目 (a = 30000)**:
     - `100000 - 30000 = 70000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1, 50000: 2, 20000: 1, 80000: 1, 30000: 1}` として、30000 の出現回数を 1 に設定します。

3. **最終結果**:
   - `res = 2`（和が `100000` となるペアが 2 組存在）

### 処理内容のまとめ
このプログラムは、リスト `A` を一度だけループすることで、和が `100000` になるペアの数を効率的に計算します。`dict` を使って既に出現したカードの値を管理するため、ペアの検索とカウントを高速に行えます。全体の計算量は **O(N)** で、カードが最大 20 万枚あった場合でも非常に高速に動作します。

---
# 026

```python
def calc(n):
    res = 0
    for i in range(1, n+1):
        res += n/i
        print(res)
    return res

def main():
    N = int(input())
    print(calc(N))

if __name__ == "__main__":
    main()
```

例として、N = 5 の場合を考えてみます：

```python
def calc(n):
    res = 0
    for i in range(n, 0, -1):
        res += n/i
    return res
```

N=5 の場合、以下のように計算が進みます：

1. i = 5 のとき（最初のコイン）：
   res += 5/5 = 1
   説明：最初のコインを得る確率は 5/5 = 1（100%）です。期待コストは 1 ドルです。

2. i = 4 のとき（2 番目のコイン）：
   res += 5/4 = 1.25
   説明：2 番目の新しいコインを得る確率は 4/5 です。期待コストは 5/4 = 1.25 ドルです。
   （平均して 1/(4/5) = 5/4 回の試行が必要）

3. i = 3 のとき（3 番目のコイン）：
   res += 5/3 ≈ 1.67
   説明：3 番目の新しいコインを得る確率は 3/5 です。期待コストは 5/3 ≈ 1.67 ドルです。
   （平均して 1/(3/5) = 5/3 回の試行が必要）

4. i = 2 のとき（4 番目のコイン）：
   res += 5/2 = 2.5
   説明：4 番目の新しいコインを得る確率は 2/5 です。期待コストは 5/2 = 2.5 ドルです。
   （平均して 1/(2/5) = 5/2 回の試行が必要）

5. i = 1 のとき（最後のコイン）：
   res += 5/1 = 5
   説明：最後のコインを得る確率は 1/5 です。期待コストは 5/1 = 5 ドルです。
   （平均して 1/(1/5) = 5 回の試行が必要）

最終的な res ≈ 11.42

この説明方法では、各ステップで新しいコインを得る確率が徐々に減少し、それに伴って期待コストが増加していく様子がよりわかりやすくなります。最初は簡単に新しいコインを得られますが、残りのコインが少なくなるにつれて、特定の新しいコインを得るのが難しくなっていきます。

この合計約 11.42 ドルが、5 種類全てのコインを集めるのに必要な総期待コストとなります。実際の試行では運によって変動しますが、長期的に見ればこの平均値に収束します。

---

# 027

### マージソートの基本的な考え方:

1. 大きな問題を小さな問題に分割する
2. 小さな問題を解決する
3. 小さな問題の解決結果を組み合わせて、大きな問題の解決につなげる

### 具体的な手順:

1. 配列を半分に分ける
2. 分けた半分をさらに半分に分ける（要素が 1 つになるまで繰り返す）
3. 1 つの要素になったら、それらをペアにしてマージ（結合）しながら並べ替える
4. マージを繰り返して、最終的に全体がソートされた 1 つの配列になる

この解説では、コードの動作を一つひとつ丁寧に説明し、実際の配列を使ってマージソートの処理の流れをステップバイステップで解説していきます。**初心者でも理解できるように**、なるべく具体的な数値例を交えて解説します。

### コードの全体の流れ
- このプログラムは、**マージソート**アルゴリズムを使って配列を昇順に並べ替えるためのものです。入力として与えられた数値のリストを再帰的に分割し、最終的にソート済みのリストとして結合する仕組みです。

### 1. `merge_sort` 関数の解説

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
```
- **役割**: この関数は入力された配列をソートするためのメイン部分です。マージソートは**分割統治法**と呼ばれる手法を使います。配列を小さく分割して、最終的にそれらをソートしながらマージします。
- **処理内容**: 最初に配列の長さをチェックします。もし配列が1個以下（要素が0個または1個）であれば、すでにソート済みなので、そのまま配列を返します。

#### 事例
入力配列 `[658, 299, 47, 507, 122]` では、長さが5なので、分割を続けます。

```python
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
```
- **処理内容**: 配列の中央（`mid`）を計算し、左側と右側に分割します。その後、それぞれの部分に対して再帰的に`merge_sort`を呼び出して、さらに細かく分割します。

#### 事例
配列 `[658, 299, 47, 507, 122]` では、`mid = 5 // 2 = 2` なので、次のように分割されます。
- 左側: `[658, 299]`
- 右側: `[47, 507, 122]`

この分割された配列についても再帰的に同様の処理を行います。

```python
    return merge(left, right)
```
- **処理内容**: 左右それぞれがソートされた後、`merge` 関数でマージして1つのソート済み配列を作ります。

### 2. `merge` 関数の解説

```python
def merge(left, right):
    res = []
    i = j = 0
```
- **役割**: `merge` 関数は、ソートされた2つの配列を一つにまとめる役割を担っています。2つのリスト `left` と `right` の要素を比較しながら、昇順に結合します。
- **処理内容**: `res` は結果としてソートされた配列を格納するリスト、`i` と `j` はそれぞれ `left` と `right` の現在のインデックスです。

```python
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            res.append(left[i])
            i += 1
        else:
            res.append(right[j])
            j += 1
```
- **処理内容**: `left` と `right` の要素を1つずつ比較し、値の小さい方を `res` に追加していきます。そして、比較に使ったインデックスを進めます。
  - `left[i]` と `right[j]` を比較し、**小さい方の値**を結果リストに追加します。

#### 事例
- `left = [299, 658]` と `right = [47, 122, 507]` が入力された場合、以下のように処理が進みます：
  1. `299` と `47` を比較 → `47` を `res` に追加 → `res = [47]`
  2. `299` と `122` を比較 → `122` を追加 → `res = [47, 122]`
  3. `299` と `507` を比較 → `299` を追加 → `res = [47, 122, 299]`
  4. `658` と `507` を比較 → `507` を追加 → `res = [47, 122, 299, 507]`

```python
    res.extend(left[i:])
    res.extend(right[j:])
```
- **処理内容**: `left` または `right` のどちらかのリストが先に全て処理される場合があるので、残った方のリストの要素を全て `res` に追加します。

#### 事例
上記の比較の後、`left` の `658` がまだ残っているので、`res = [47, 122, 299, 507, 658]` となります。

```python
    return res
```
- **処理内容**: 結果としてソートされた配列 `res` を返します。

### 3. `main` 関数の解説

```python
def main():
    _ = int(input())
    A = list(map(int, input().split()))
    print(*merge_sort(A))
```
- **役割**: `main` 関数は、プログラムのエントリーポイントです。まず、最初に入力を受け取り、与えられた配列をソートして結果を出力します。
- **処理内容**:
  - 最初に、配列の長さを読み取ります（`_` は使われないので無視しています）。
  - 次に、`input().split()` を使って入力された配列をリスト `A` に変換します。
  - `merge_sort(A)` で配列をソートし、`print` で結果を表示します。

#### 事例
入力が `5`、`658 299 47 507 122` の場合：
- 配列 `A = [658, 299, 47, 507, 122]` となり、この配列が `merge_sort` に渡されます。
- 結果は `[47, 122, 299, 507, 658]` となり、それが出力されます。

---

### 処理の流れ（全体のステップバイステップの解説）

1. **最初の入力**として、`[658, 299, 47, 507, 122]` という配列が与えられます。
2. **`merge_sort`で分割**:
   - 配列を中央で分割し、`[658, 299]` と `[47, 507, 122]` に分かれます。
   - `[658, 299]` はさらに `[658]` と `[299]` に分割され、`[47, 507, 122]` は `[47]` と `[507, 122]` に分割されます。
3. **再帰的に分割**した結果、最小単位（1つの要素だけの配列）になります。これ以上分割できなくなったら、**マージ開始**。
4. **マージのステップ**:
   - `[658]` と `[299]` をマージして `[299, 658]` に。
   - `[507]` と `[122]` をマージして `[122, 507]` に。
   - `[47]` と `[122, 507]` をマージして `[47, 122, 507]` に。
5. 最後に、`[299, 658]` と `[47, 122, 507]` をマージして、**ソートされた最終結果** `[47, 122, 299, 507, 658]` が得られます。

---

### 結論
この説明では、事例を使いながら、各ステップで何が行われているかを明確に示しました。具体的な配列で再帰的な分割とマージの流れを確認することで、マージソートの仕組みがより直感的に理解できるはずです。


---

# 028

```python
def min_cost(N, h):
    dp = [0] * N
    dp[1] = abs(h[1] - h[0])
    for i in range(2, N):
        cost1 = dp[i-1] + abs(h[i] - h[i-1])
        cost2 = dp[i-2] + abs(h[i] - h[i-2])
        dp[i] = min(cost1, cost2)
    return dp[-1]

def main():
    N = int(input())
    h = list(map(int, input().split()))
    print(min_cost(N, h))

if __name__ == "__main__":
    main()
```

## カエルのジャンプ：最小コストを求めるプログラム解説

このプログラムは、カエルが足場をジャンプして進むときに、最小コストでゴールにたどり着く方法を見つけるためのものです。

### １. 全体の流れ

1. `main()`関数で、足場の数(`N`)と、各足場の高さ(`h`)を入力として受け取ります。
2. `min_cost(N, h)`関数を呼び出し、最小コストを計算します。
3. 計算結果（最小コスト）を表示します。

### 2. `min_cost` 関数の解説

この関数が、動的計画法を使って最小コストを計算する心臓部です。

#### 2.1. 変数

* **`dp`**: リストです。`dp[i]` は「足場 `i` に到達するまでの最小コスト」を保存します。
* **`cost1`**: 足場 `i-1` から足場 `i` にジャンプする場合のコストを一時的に保存します。
* **`cost2`**: 足場 `i-2` から足場 `i` にジャンプする場合のコストを一時的に保存します。

#### 2.2. 処理の流れ

1. **初期化**: `dp[0]` を `0` (最初の足場までのコストは0)、`dp[1]` を `abs(h[1] - h[0])` (最初の足場から2番目の足場へのコスト) で初期化します。
2. **最小コストの計算**: `for` 文を使って、2番目の足場から最後の足場まで順番に処理していきます。
    * 各足場 `i` に対して、
        * `cost1` に、足場 `i-1` からジャンプしてきた場合のコストを計算して代入します。
        * `cost2` に、足場 `i-2` からジャンプしてきた場合のコストを計算して代入します。
        * `dp[i]` に、`cost1` と `cost2` の小さい方を代入します。これで、足場 `i` に到達するまでの最小コストが記録されます。
3. **最小コストの返却**: すべての足場について計算が終わったら、最後の足場(`N-1`)に到達するまでの最小コスト(`dp[-1]`)を返します。

### 3. 事例を使った説明

例えば、足場の高さが `h = [30, 10, 60, 10, 60, 50]` の場合を考えます。

1. `dp` は最初は `[0, 20, 0, 0, 0, 0]` となります。(`dp[1]` は `abs(10-30) = 20`)
2. `i = 2` のとき:
    * `cost1 = dp[1] + abs(h[2] - h[1]) = 20 + abs(60 - 10) = 70`
    * `cost2 = dp[0] + abs(h[2] - h[0]) = 0 + abs(60 - 30) = 30`
    * `dp[2] = min(70, 30) = 30` となります。
3. `i = 3` のとき:
    * `cost1 = dp[2] + abs(h[3] - h[2]) = 30 + abs(10 - 60) = 80`
    * `cost2 = dp[1] + abs(h[3] - h[1]) = 20 + abs(10 - 10) = 20`
    * `dp[3] = min(80, 20) = 20` となります。
4. `i = 4` のとき:
    * `cost1 = dp[3] + abs(h[4] - h[3]) = 20 + abs(60 - 10) = 70`
    * `cost2 = dp[2] + abs(h[4] - h[2]) = 30 + abs(60 - 60) = 30`
    * `dp[4] = min(70, 30) = 30` となります。
5. `i = 5` のとき:
    * `cost1 = dp[4] + abs(h[5] - h[4]) = 30 + abs(50 - 60) = 40`
    * `cost2 = dp[3] + abs(h[5] - h[3]) = 20 + abs(50 - 10) = 60`
    * `dp[5] = min(40, 60) = 40` となります。
6. 最終的に `dp = [0, 20, 30, 20, 30, 40]` となり、`dp[-1] = 40` が最小コストとして返されます。

   ```python
   debug
   =========================== i : 2
   cost1(1) : 70
   cost2(0) : 30
   dp : [0, 20, 30, 0, 0, 0]
   =========================== i : 3
   cost1(2) : 80
   cost2(1) : 20
   dp : [0, 20, 30, 20, 0, 0]
   =========================== i : 4
   cost1(3) : 70
   cost2(2) : 30
   dp : [0, 20, 30, 20, 30, 0]
   =========================== i : 5
   cost1(4) : 40
   cost2(3) : 60
   dp : [0, 20, 30, 20, 30, 40]
   ```

### なぜ動的計画法を使うのか？
- 部分問題の再利用: 一度計算した部分問題（例えば、3番目の足場までの最小コスト）は、後の計算で再利用されます。
- 効率化: 全ての組み合わせを愚直に計算するよりも、大幅に計算量を減らすことができます。

### まとめ
このコードは、動的計画法というアルゴリズムを使って、カエルのジャンプ問題を効率的に解いています。
- dp配列: 各足場までの最小コストを記録
- ループ: 2つ前の足場と1つ前の足場からジャンプするコストを比較し、最小のコストを記録
- 最終的な答え: 最後の足場までの最小コストが答え

このコードは、一見複雑に見える問題を、構造化して解くための良い例です。<br>
計算量は O(N) で、N が最大10^5 でも十分に高速に処理できます。

---
# 029

このコードは、N 段の階段を1段または2段ずつ上がるときの、上がり方の数を計算することを目的としています。動的計画法（Dynamic Programming）というアルゴリズムを用いて、効率的に計算を行います。

### コードの詳細解説

#### `min_cost`関数

1. **リスト`dp`の初期化**:
    ```python
    dp = [0] * (N+1)
    ```
    - `dp`は長さ`N+1`のリストで、各インデックス`i`に対して`dp[i]`は`i`段目に到達する方法の数を表します。
    - 例えば、`N=4`の場合、`dp`は `[0, 0, 0, 0, 0]` となります。

2. **初期条件の設定**:
    ```python
    dp[0] = dp[1] = 1
    ```
    - `dp[0]`と`dp[1]`を1に設定します。これは、0段目と1段目に到達する方法がそれぞれ1通りであることを意味します。
    - 例えば、`N=4`の場合、`dp`は `[1, 1, 0, 0, 0]` となります。

3. **動的計画法による計算**:
    ```python
    for i in range(2, N+1):
        dp[i] = dp[i-1] + dp[i-2]
    ```
    - 2段目からN段目までの各段に対して、`dp[i]`を計算します。
    - `dp[i]`は、`dp[i-1]`（1段前から来る方法）と`dp[i-2]`（2段前から来る方法）の合計です。
    - 例えば、`N=4`の場合、以下のように計算されます:
        - `i=2`: `dp[2] = dp[1] + dp[0] = 1 + 1 = 2` → `dp = [1, 1, 2, 0, 0]`
        - `i=3`: `dp[3] = dp[2] + dp[1] = 2 + 1 = 3` → `dp = [1, 1, 2, 3, 0]`
        - `i=4`: `dp[4] = dp[3] + dp[2] = 3 + 2 = 5` → `dp = [1, 1, 2, 3, 5]`

4. **結果の返却**:
    ```python
    return dp[-1]
    ```
    - `dp[-1]`（リストの最後の要素）を返します。これは、N段目に到達する方法の数です。
    - 例えば、`N=4`の場合、`dp[4]`は5なので、5が返されます。

#### `main`関数

1. **標準入力からNを読み込む**:
    ```python
    N = int(input())
    ```
    - ユーザーから入力された値を整数として読み込みます。

2. **`min_cost`関数を呼び出し、結果を出力**:
    ```python
    print(min_cost(N))
    ```
    - `min_cost`関数を呼び出し、その結果を出力します。

#### エントリーポイント

1. **スクリプトのエントリーポイント**:
    ```python
    if __name__ == "__main__":
        main()
    ```
    - このスクリプトが直接実行された場合に`main`関数を呼び出します。

### 処理内容の過程

入力例として、N=4の場合をもう少し詳しく見てみましょう。

1. **初期化**:
    - `dp`リストを初期化します: `dp = [0, 0, 0, 0, 0]`
    - `dp[0]`と`dp[1]`を1に設定します: `dp = [1, 1, 0, 0, 0]`

2. **動的計画法による計算**:
    - `i=2`のとき、`dp[2] = dp[1] + dp[0] = 1 + 1 = 2`: `dp = [1, 1, 2, 0, 0]`
    - `i=3`のとき、`dp[3] = dp[2] + dp[1] = 2 + 1 = 3`: `dp = [1, 1, 2, 3, 0]`
    - `i=4`のとき、`dp[4] = dp[3] + dp[2] = 3 + 2 = 5`: `dp = [1, 1, 2, 3, 5]`

3. **結果の返却**:
    - `dp[-1]`（`dp[4]`）を返します。これは5です。

つまり、N=4の場合、0段目から4段目まで移動する方法は5通りあります。


---
# 030

## ナップサック問題の Python コード解説

### コード全体の説明

このコードは、**ナップサック問題**と呼ばれる、与えられた複数の品物の中から、ナップサックの容量を超えない範囲で、価値の総和を最大にする組み合わせを選ぶ問題を解くための Python プログラムです。

**動的計画法**と呼ばれるアルゴリズムを用いて、効率的に解いています。

### 各部分の解説

#### `knapsack`関数

- **引数:**
  - `N`: 品物の数
  - `W`: ナップサックの容量
  - `items`: 各品物の重さと価値のタプルのリスト
- **処理:**
  - `dp`リスト: 長さが`W+1`のリストを作成し、`dp[i]`に容量`i`のナップサックに入れられる品物の価値の最大値を格納します。
  - 重複ループ:
    - 外側のループ: 各品物`w, v`について処理します。
    - 内側のループ: 容量`j`について、品物`w`を入れる場合と入れない場合で、価値の大きい方を`dp[j]`に更新します。
      - `dp[j-w] + v`: 品物`w`を入れる場合の価値
      - `dp[j]`: 品物`w`を入れない場合の価値
  - `return dp[W]`: 最終的に、容量`W`のナップサックに入れられる品物の価値の最大値を返します。

#### `main`関数

- **入力:**
  - `N`, `W`: 品物の数とナップサックの容量を入力
  - `items`: 各品物の重さと価値を入力し、タプルのリストに格納
- **処理:**
  - `knapsack`関数を呼び出し、結果を出力

**ポイント:**

- **動的計画法:** 一度求めた部分問題の解を保存しておき、後から再利用することで、計算量を削減する手法です。
- **DP テーブル:** `dp`リストは、動的計画法で計算結果を保存するための表（テーブル）のような役割を果たします。
- **状態遷移:** 内側のループで、現在の状態（容量`j`）から、一つ前の状態（容量`j-w`）への遷移を考え、価値を更新しています。

**具体例**

- バッグの耐久重量(W) = 8
- 品物(N) = 3 個
  1. 重さ 3, 価値 30
  2. 重さ 4, 価値 50
  3. 重さ 5, 価値 60

1. `knapsack` 関数:

   - `dp`リストを作ります。これは「重さ j のバッグで得られる最大価値」を記録します。
   - 初期状態: `dp = [0, 0, 0, 0, 0, 0, 0, 0, 0]` (インデックス 0 から 8 まで)

2. 品物を 1 つずつ確認していきます:

   品物 1 (重さ 3, 価値 30):

   - 重さ 8 から 3 まで逆順に確認
   - `dp[8] = max(0, 0+30) = 30`
   - `dp[7] = max(0, 0+30) = 30`
   - `dp[6] = max(0, 0+30) = 30`
   - `dp[5] = max(0, 0+30) = 30`
   - `dp[4] = max(0, 0+30) = 30`
   - `dp[3] = max(0, 0+30) = 30`
   - 結果: `dp = [0, 0, 0, 30, 30, 30, 30, 30, 30]`

   品物 2 (重さ 4, 価値 50):

   - `dp[8] = max(30, 30+50) = 80`
   - `dp[7] = max(30, 30+50) = 80`
   - `dp[6] = max(30, 0+50) = 50`
   - `dp[5] = max(30, 0+50) = 50`
   - `dp[4] = max(30, 0+50) = 50`
   - 結果: `dp = [0, 0, 0, 30, 50, 50, 50, 80, 80]`

   品物 3 (重さ 5, 価値 60):

   - `dp[8] = max(80, 30+60) = 90`
   - `dp[7] = max(80, 0+60) = 80`
   - `dp[6] = max(50, 0+60) = 60`
   - `dp[5] = max(50, 0+60) = 60`
   - 結果: `dp = [0, 0, 0, 30, 50, 60, 60, 80, 90]`

3. 最終的に `dp[8] = 90` が答えになります。これは、重さ 8 のバッグで得られる最大価値が 90 であることを意味します。

`main` 関数は入力を受け取り、`knapsack` 関数を呼び出して結果を出力します。

このアルゴリズムの特徴は、各品物について一度だけ処理を行い、かつメモリ使用量を最小限に抑えている点です。これにより、効率的に問題を解決できます。

### [補足] dp[j] = max(dp[j], dp[j-w]+v) の解説

この部分が一番重要な箇所なので、落ち着いて理解していきましょう！

**状況:**

* `dp[j]` は「ナップサックの容量が `j` の時に実現できる価値の最大値」を格納していくためのリストです。
* 今、重さ `w`、価値 `v` の品物を新たに検討しようとしています。

**この処理が意味すること:**

1. `dp[j]` は、この品物を **入れる前** の、容量 `j` で実現できる最大価値を保持しています。
2. `dp[j-w]+v` は、この品物を **入れる** ことを考えた場合の価値です。
    * まず、`j-w` は「新しい品物を **入れる** ために残しておくべき容量」です。
    * `dp[j-w]` は「その残しておいた容量で実現できる最大価値」です。
    * そこに、新しく入れる品物の価値 `v` を足せば、 **新しい品物を入れた場合の価値** が計算できます。

つまり、`dp[j] = max(dp[j], dp[j-w]+v)` は、

* **「新しい品物を入れない場合」と「入れる場合」の価値を比較し、より価値の高い方を選択する**

という処理を意味しています。

**具体例で確認:**

`items = [(3, 30), (4, 50), (5, 60)]` で、ナップサックの容量 `W = 8` の場合を考えます。

1. `(3, 30)` の品物を検討する段階で、`j = 5` の時を考えてみましょう。
    * `dp[5]` は現時点では `0` です (まだ何も入れていない)。
    * `dp[j-w] = dp[2]` も `0` です。
    * `dp[j-w] + v = 0 + 30 = 30` となります。
    * `max(0, 30) = 30` なので、`dp[5]` は `30` に更新されます。

2. 次に `(4, 50)` を検討する段階で、再び `j = 5` の時を考えます。
    * `dp[5]` は `30` です ((3, 30) を入れた場合の価値が残っている)。
    * `dp[j-w] = dp[1]` は `0` です。
    * `dp[j-w] + v = 0 + 50 = 50` となります。
    * `max(30, 50) = 50` なので、`dp[5]` は `50` に更新されます。

このように、各品物、各容量について「入れるか入れないか」の選択を比較し、`dp` リストを更新していくことで、最終的に `dp[W]` には「ナップサックの容量 `W` で実現できる最大価値」が格納されることになります。

**ポイント:**

* `j` のループが `W` から降順になっているのは、同じ品物を複数回使わないようにするためです。
* 各品物について `dp` リスト全体を更新していくことで、あらゆる組み合わせを効率的に探索しています。

この解説で、`dp[j] = max(dp[j], dp[j-w]+v)` の部分が少しでもクリアになれば幸いです！


---

# 031

### コード全体の流れ

このプログラムは、太郎君が夏休み中に勉強をして得られる最大の実力値を計算します。太郎君は 2 日連続で勉強しないという制約があるため、各日の実力値を考慮しつつ最大値を求める必要があります。

### コードの説明

まずは、具体例として入力例を考えます。

#### 例:

- 日数 `N = 5`
- 各日の実力値 `A = [2, 5, 3, 3, 1]`

### 関数 `dp(N, A)` の説明

```python
def dp(N, A):
    dp = [0] * (N+1)
    dp[1] = A[0]
    for i in range(2, N+1):
        dp[i] = max(dp[i-1], dp[i-2] + A[i-1])
    return dp[-1]
```

#### ステップ 1: 初期化

1. **`dp = [0] * (N+1)`**:

   - `dp`リストを初期化します。このリストは`N+1`個の要素を持ち、全て 0 で初期化されています。
   - `dp[i]`は、`i`日目までの間に得られる最大の実力値を保持します。

   例えば、`N = 5`の場合、最初に作られるリストは次のようになります:

   ```python
   dp = [0, 0, 0, 0, 0, 0]
   ```

2. **`dp[1] = A[0]`**:

   - 1 日目に勉強した場合の実力値を設定します。`dp[1]`に`A[0]`を代入します。
   - `dp[1] = 2`となります。

   この時点で`dp`リストは次のようになります:

   ```python
   dp = [0, 2, 0, 0, 0, 0]
   ```

#### ステップ 2: 動的計画法による計算

3. **`for i in range(2, N+1):`**:

   - 2 日目から N 日目までの各日について計算します。

4. **`dp[i] = max(dp[i-1], dp[i-2] + A[i-1])`**:

   - `dp[i-1]`は、`i-1`日目までの最大の実力値を意味します。これは、`i`日目に勉強しない場合の実力値です。
   - `dp[i-2] + A[i-1]`は、`i-2`日目までの最大の実力値に`i`日目の実力値を加えたものです。これは、`i`日目に勉強する場合の実力値です。
   - より大きな値を`dp[i]`に保存します。

   実際の計算を見てみましょう。

   - `i = 2` の場合:

     - `dp[2] = max(dp[1], dp[0] + A[1]) = max(2, 0 + 5) = 5`
     - `dp = [0, 2, 5, 0, 0, 0]`

   - `i = 3` の場合:

     - `dp[3] = max(dp[2], dp[1] + A[2]) = max(5, 2 + 3) = 5`
     - `dp = [0, 2, 5, 5, 0, 0]`

   - `i = 4` の場合:

     - `dp[4] = max(dp[3], dp[2] + A[3]) = max(5, 5 + 3) = 8`
     - `dp = [0, 2, 5, 5, 8, 0]`

   - `i = 5` の場合:
     - `dp[5] = max(dp[4], dp[3] + A[4]) = max(8, 5 + 1) = 8`
     - `dp = [0, 2, 5, 5, 8, 8]`

#### ステップ 3: 最終的な実力値の取得

5. **`return dp[-1]`**:
   - `dp[-1]`（つまり`dp[5]`）を返します。これが太郎君が得られる最大の実力値です。
   - この例では、結果は `8` となります。

### 全体の流れをまとめると:

- 入力として`N`日分の実力値リスト`A`を受け取ります。
- `dp()`関数で動的計画法を用いて、太郎君が 2 日連続で勉強しないという制約のもとで、得られる最大の実力値を計算します。
- その結果を出力します。今回の例では、答えは`8`となります。

<br>
<br>

---
# 033

このコードは、2次元平面上にある点 `A` と線分 `BC` 上の最短距離を計算するものです。いくつかのサポート関数を使って、処理を分かりやすく、また再利用可能にしています。それぞれの関数の役割と処理の流れを、例を使って解説します。

## 点と線分の距離：数式を用いた詳細解説とコードの仕組み

このコードは、平面上に存在する点と線分の最短距離を求めるためのものです。以下では、数式を交えながらコードの解説を行います。

**問題設定**

2次元平面上に点Aと線分BCが存在するとします。点Aの座標を $(a_x, a_y)$ 、点Bの座標を $(b_x, b_y)$ 、点Cの座標を $(c_x, c_y)$ とします。

**目標**

点Aと線分BC間の最短距離を求めます。

**1. ベクトル計算の準備**

まず、点A, B, C を使って、以下の4つのベクトルを計算します。

* $\overrightarrow{BA} = (a_x - b_x, a_y - b_y)$
* $\overrightarrow{BC} = (c_x - b_x, c_y - b_y)$
* $\overrightarrow{CA} = (a_x - c_x, a_y - c_y)$
* $\overrightarrow{CB} = (b_x - c_x, b_y - c_y)$

**2. 最短距離になる点を探す**

点Aから線分BCへ垂線を下ろし、その足を点Hとします。この点Hこそが、点Aから線分BCへの最短距離を与える点となります。

**3. 点Hの位置で場合分け**

**ケース1：点Hが線分BCの外側で、点B寄りにある場合**

* この時、点Bと点Aを結ぶ線分が最短距離になります。
* $\overrightarrow{BA}$ と $\overrightarrow{BC}$ の内積が負になる、すなわち $\overrightarrow{BA} \cdot \overrightarrow{BC} < 0$ という条件で判別できます。
* この場合、最短距離は点Aと点Bの距離なので、以下のユークリッド距離の公式を用いて計算できます。
    * $\text{距離} = \sqrt{(a_x - b_x)^2 + (a_y - b_y)^2}$

**ケース2：点Hが線分BCの外側で、点C寄りにある場合**

* この時、点Cと点Aを結ぶ線分が最短距離になります。
*  $\overrightarrow{CA}$ と $\overrightarrow{CB}$ の内積が負になる、すなわち $\overrightarrow{CA} \cdot \overrightarrow{CB} < 0$ という条件で判別できます。
* この場合、最短距離は点Aと点Cの距離なので、以下のユークリッド距離の公式を用いて計算できます。
    * $\text{距離} = \sqrt{(a_x - c_x)^2 + (a_y - c_y)^2}$

**ケース3：点Hが線分BC上にある場合**

* この時、点Hと点Aを結ぶ線分が最短距離になります。
* 上記2つのケース以外の場合に該当します。

**点Hの座標を求める**

点Hは線分BC上の点なので、ベクトル $\overrightarrow{BC}$ を用いて以下のように表せます。

$$
\overrightarrow{OH} = \overrightarrow{OB} + t\overrightarrow{BC} \quad (0 \le t \le 1)
$$

ここで、 $\overrightarrow{OH}$ は原点Oから点Hへのベクトル、 $\overrightarrow{OB}$ は原点Oから点Bへのベクトルを表し、 $t$ は線分BCに対する点Hの位置を表すパラメータです。 $t$ が0のとき点Hは点Bと一致し、 $t$ が1のとき点Hは点Cと一致します。

**t の求め方**

点Hは垂線の足なので、 $\overrightarrow{AH}$ と $\overrightarrow{BC}$ は直交します。つまり、内積が0になります。

$$
\overrightarrow{AH} \cdot \overrightarrow{BC} = 0
$$

$\overrightarrow{AH} = \overrightarrow{OH} - \overrightarrow{OA}$ 、 $\overrightarrow{OH} = \overrightarrow{OB} + t\overrightarrow{BC}$ を代入して展開すると、

$$
(\overrightarrow{OB} + t\overrightarrow{BC} - \overrightarrow{OA}) \cdot \overrightarrow{BC} = 0
$$

$$
t = \frac{(\overrightarrow{OA} - \overrightarrow{OB}) \cdot \overrightarrow{BC}}{\overrightarrow{BC} \cdot \overrightarrow{BC}} =  \frac{\overrightarrow{BA} \cdot \overrightarrow{BC}}{\overrightarrow{BC} \cdot \overrightarrow{BC}}
$$

このようにして、 $t$ を求めることができます。

**点Hの座標の算出**

$t$ が求まれば、点Hの座標 $(h_x, h_y)$ は以下のようになります。

$$
h_x = b_x + t(c_x - b_x)
$$

$$
h_y = b_y + t(c_y - b_y)
$$

**最短距離の計算**

点Hの座標が求まれば、点Aと点Hの距離、すなわち最短距離はユークリッド距離の公式を用いて計算できます。

$$
\text{距離} = \sqrt{(a_x - h_x)^2 + (a_y - h_y)^2}
$$


**コードの解説**

```python
import numpy as np
import math

def vector_subtract(v1, v2):
    return [v1[0] - v2[0], v1[1] - v2[1]]

def distance(p1, p2):
    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)

def shortest_distance(A, B, C):
    BA = vector_subtract(A, B) # ベクトルBA
    BC = vector_subtract(C, B) # ベクトルBC
    CA = vector_subtract(A, C) # ベクトルCA
    CB = vector_subtract(B, C) # ベクトルCB

    if np.dot(BA, BC) < 0: # ケース1: 点Hが点Bの外側
        nearest = B
    elif np.dot(CA, CB) < 0: # ケース2: 点Hが点Cの外側
        nearest = C
    else: # ケース3: 点Hが線分BC上
        t = np.dot(BA, BC) / np.dot(BC, BC) # tの計算
        nearest = [B[0] + t * BC[0], B[1] + t * BC[1]] # 点Hの座標

    return distance(A, nearest) # 最短距離の計算
```

### 各関数の解説

1. **`vector_subtract(v1, v2)`**
   - これは、2つのベクトル（2次元座標のリスト）の減算を行う関数です。例えば、ベクトル `v1 = [x1, y1]` からベクトル `v2 = [x2, y2]` を引くと、`[x1 - x2, y1 - y2]` を返します。
   - ベクトルの減算は、点と点の相対的な位置（方向や長さ）を求めるために使います。

2. **`distance(p1, p2)`**
   - この関数は、2点間のユークリッド距離を計算します。距離公式は次の通りです： <br>
     $\text{distance} = \sqrt{(x2 - x1)^2 + (y2 - y1)^2}$
   - これにより、2点の座標間の直線距離を計算できます。

3. **`shortest_distance(A, B, C)`**
   - この関数は、点 `A` から線分 `BC` への最短距離を計算します。処理の流れは以下の通りです。
   - まず、点 `A`、`B`、`C` を基準にベクトル `BA`（BからAへのベクトル）、`BC`（BからCへのベクトル）、`CA`（CからAへのベクトル）などを計算します。
   - 内積 (`np.dot`) を使って、点 `A` が線分 `BC` の範囲内にあるかどうかを判定します。これにより、最短距離がどう決まるかが決定されます。

4. **`main()`**
   - 標準入力から、点 `A`、`B`、`C` の座標を受け取り、それらをリストとして格納し、最短距離を計算する `shortest_distance` 関数に渡して結果を出力します。


### 具体的な事例での処理内容の説明

#### 例1:
```
入力:
A = [0, 5]
B = [1, 1]
C = [3, 0]
```

1. **ベクトルの計算**
   - ベクトル `BA` を計算します。`B = [1, 1]` から `A = [0, 5]` を引くと、
     ```
     BA = [0 - 1, 5 - 1] = [-1, 4]
     ```
   - 同様に、ベクトル `BC` を計算します。
     ```
     BC = [3 - 1, 0 - 1] = [2, -1]
     ```
   - このようにして、`BA` と `BC` が計算されました。

2. **内積計算**
   - ベクトル `BA` と `BC` の内積を計算します。内積とは、ベクトルの「方向」を比較する指標で、次のように計算されます。
     ```
     np.dot(BA, BC) = (-1 * 2) + (4 * -1) = -2 - 4 = -6
     ```
   - 内積が負であるため、点 `A` は線分 `BC` の範囲外、点 `B` 側にあることが分かります。

3. **最短距離の計算**
   - この場合、内積が負であるため、点 `A` から点 `B` への距離が最短になります。
   - 距離を計算するために、関数 `distance(A, B)` を使います。
     ```
     distance(A, B) = sqrt((0 - 1)^2 + (5 - 1)^2) = sqrt(1 + 16) = sqrt(17) ≈ 4.123105625618
     ```
   - このようにして、`A` と `B` の距離が最短距離として返されます。

---

### もう一つの例:
```
入力:
A = [-40, -30]
B = [-50, -10]
C = [-20, -20]
```

1. **ベクトルの計算**
   - `BA` と `BC` を計算します。
     ```
     BA = [-40 - (-50), -30 - (-10)] = [10, -20]
     BC = [-20 - (-50), -20 - (-10)] = [30, -10]
     ```

2. **内積計算**
   - `np.dot(BA, BC)` を計算します。
     ```
     np.dot(BA, BC) = (10 * 30) + (-20 * -10) = 300 + 200 = 500
     ```
   - 内積が正なので、次に進みます。
   - `BC` の長さの2乗は、
     ```
     np.dot(BC, BC) = 30^2 + (-10)^2 = 900 + 100 = 1000
     ```

3. **射影点の計算**
   - `t` を計算します。
     ```
     t = np.dot(BA, BC) / np.dot(BC, BC) = 500 / 1000 = 0.5
     ```
   - これにより、射影点 `nearest` を計算します。
     ```
     nearest = [-50 + 0.5 * 30, -10 + 0.5 * (-10)] = [-50 + 15, -10 - 5] = [-35, -15]
     ```

4. **最短距離の計算**
   - 射影点 `nearest = [-35, -15]` と点 `A = [-40, -30]` との距離を計算します。
     ```
     distance(A, nearest) = sqrt((-40 - (-35))^2 + (-30 - (-15))^2) = sqrt((-5)^2 + (-15)^2) = sqrt(25 + 225) = sqrt(250) ≈ 15.811388300842
     ```

このようにして、`A` から線分 `BC` までの最短距離が計算されます。

---

### まとめ

- **内積の役割**: 点 `A` が線分 `BC` 上のどの位置にあるかを判定するために内積を使用しています。内積が負なら点 `A` は `B` 側にあり、正なら線分 `BC` 上に射影されるか、`C` 側にあります。
- **射影点の計算**: 射影点が線分 `BC` 上にある場合、その点までの距離が最短となります。射影点は `t` を使って計算します。
- **距離計算**: 距離の計算にはユークリッド距離公式を使っており、A と最も近い点（B、C、または射影点）との距離が最短距離として計算されます。

<br>
<br>

---
# 034

### コードの解説

このコードでは、2次元平面上の複数の点の中で、最も近い2つの点の間の距離を計算しています。主な手順として、以下の3つの関数とロジックが含まれています。

1. **`distance(p1, p2)` 関数**：
   - 2つの点 `p1` と `p2` の間のユークリッド距離を計算する関数です。
   - ユークリッド距離は次の式に基づいています：
    <br>&nbsp;&nbsp;&nbsp;&nbsp;
     $d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$
   - `p1[0]` と `p2[0]` がそれぞれ x 座標、`p1[1]` と `p2[1]` がそれぞれ y 座標です。

2. **`find_min_distance(points)` 関数**：
   - 与えられた点のリスト `points` の中で、最も近い2点の距離を求める関数です。
   - まず、非常に大きな初期値 `float('Inf')` を最小距離として設定します。次に、全ての点のペアを二重ループで調べ、距離を計算します。計算した距離が現在の最小距離よりも小さい場合は、その距離を最小距離として更新します。

3. **`main()` 関数**：
   - プログラムのメイン部分です。
   - 最初に、標準入力から点の数 `N` を読み込み、その後、`N` 個の点の座標を受け取ります。受け取った点のリスト `points` を `find_min_distance` 関数に渡して、最も近い2点の距離を計算し、その結果を表示します。

### 処理の流れ

1. **入力の受け取り**:
   - 点の数 `N` を受け取ります。次に、`N` 個の点の座標を標準入力から受け取って、それをリストに格納します。

2. **最小距離の計算**:
   - 点のリストの中から、全ての点のペアを組み合わせて、それぞれの距離を計算します。計算された距離が最小距離よりも小さい場合は、その距離を更新します。

3. **結果の出力**:
   - 最も近い2点の距離を出力します。

### 具体的な事例を使った処理の過程

例えば、次のような入力があったとします：

```
4
0 1
2 0
2 3
3 1
```

1. **`main()` 関数の実行**：
   - 点の数 `N = 4` と点の座標 `[(0, 1), (2, 0), (2, 3), (3, 1)]` を受け取ります。

2. **`find_min_distance(points)` 関数の実行**：
   - `min_distance` を初期化します (`float('Inf')`)。
   - すべての点のペアの距離を計算します：

   | 点のペア               | 距離計算 (ユークリッド距離)                                  | 距離                     |
   |----------------------|------------------------------------------------------------|--------------------------|
   | (0, 1) と (2, 0)     | \( $\sqrt{(2-0)^2 + (0-1)^2} = \sqrt{4 + 1} = \sqrt{5}$ \)   | 約 2.236                  |
   | (0, 1) と (2, 3)     | \( $\sqrt{(2-0)^2 + (3-1)^2} = \sqrt{4 + 4} = \sqrt{8}$ \)   | 約 2.828                  |
   | (0, 1) と (3, 1)     | \( $\sqrt{(3-0)^2 + (1-1)^2} = \sqrt{9 + 0} = \sqrt{9}$ \)   | 3                        |
   | (2, 0) と (2, 3)     | \( $\sqrt{(2-2)^2 + (3-0)^2} = \sqrt{0 + 9} = \sqrt{9}$ \)   | 3                        |
   | (2, 0) と (3, 1)     | \( $\sqrt{(3-2)^2 + (1-0)^2} = \sqrt{1 + 1} = \sqrt{2}$ \)   | 約 1.414                  |
   | (2, 3) と (3, 1)     | \( $\sqrt{(3-2)^2 + (1-3)^2} = \sqrt{1 + 4} = \sqrt{5}$ \)   | 約 2.236                  |

   - 最も近い2点は `(2, 0)` と `(3, 1)` で、距離は約 1.414 です。

3. **結果の出力**：
   - 最小距離である `1.414213562373` が出力されます。

### まとめ
このプログラムは、2次元平面上の複数の点から最も近い2つの点の距離を求めます。`find_min_distance()` 関数で全ての点のペアの距離を計算し、最小距離を見つけます。事例を用いて処理の流れを説明すると、プログラムがどのように点のペアごとに距離を計算して、最も近い点の距離を更新していくかが理解しやすくなります。

<br>
<br>

---
# 035

[参考] 2つの円の位置関係<br>
https://manabitimes.jp/math/745

このコードは、2 つの円の位置関係を判定するプログラムです。具体的には、与えられた 2 つの円の半径と中心座標から、以下の 5 つの位置関係のいずれかに分類し、その番号を出力します。

1. 一方の円が他方の円を完全に含み、2 つの円は接していない
2. 一方の円が他方の円を完全に含み、2 つの円は接している
3. 2 つの円が互いに交差する
4. 2 つの円の内部に共通部分は存在しないが、2 つの円は接している
5. 2 つの円の内部に共通部分は存在せず、2 つの円は接していない


プログラムの特徴と動作について詳細に説明します。

### コードの構成と解説

1. **モジュールのインポート**
   ```python
   import math
   ```
   - `math`モジュールをインポートしています。これは、数学的な関数を使うためです。ここでは、特にユークリッド距離を計算するための平方根関数 `math.sqrt` を使用しています。

2. **関数 `check_circle_position`**
   ```python
   def check_circle_position(r1, r2, d):
       if d < abs(r1 - r2):
           return 1
       elif d == abs(r1 - r2):
           return 2
       elif abs(r1 - r2) < d < r1 + r2:
           return 3
       elif d == r1 + r2:
           return 4
       elif d > r1 + r2:
           return 5
       else:
           return None
   ```
   - **引数**: 2つの円の半径 `r1` と `r2`、および円の中心間の距離 `d` を受け取ります。
   - **判定処理**:
     - `d < abs(r1 - r2)`: <br>&nbsp;&nbsp;&nbsp;
     一方の円が他方を完全に含んでいる状態で接していない場合。この場合、1を返します。
     - `d == abs(r1 - r2)`:<br>&nbsp;&nbsp;&nbsp;
     一方の円が他方を完全に含み、ちょうど接している場合。この場合、2を返します。
     - `abs(r1 - r2) < d < r1 + r2`: <br>&nbsp;&nbsp;&nbsp;
     2つの円が交差している場合。この場合、3を返します。
     - `d == r1 + r2`: <br>&nbsp;&nbsp;&nbsp;
     2つの円が外側でちょうど接している場合。この場合、4を返します。
     - `d > r1 + r2`: <br>&nbsp;&nbsp;&nbsp;
     2つの円が全く交差せず、離れている場合。この場合、5を返します。
   - **返り値**: 位置関係を示す番号を返します。

3. **関数 `main`**
   ```python
   def main():
       x1, y1, r1 = map(int, input().split())
       x2, y2, r2 = map(int, input().split())
       d = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
       print(check_circle_position(r1, r2, d))
   ```
   - **入力の取得**:
     - 2つの円の中心座標 `(x1, y1)` と `(x2, y2)`、および半径 `r1` と `r2` を標準入力から取得します。
     - `map(int, input().split())` を使ってスペース区切りの整数として入力を取得します。
   - **距離の計算**:
     - `d = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)` は2つの円の中心間の距離をユークリッド距離として計算します。

$$
d = \sqrt{(x1 - x2)^2 + (y1 - y2)^2}
$$

   - **位置関係の判定**:
     - `check_circle_position` 関数を呼び出して、返された位置関係の番号を出力します。

### 処理過程の具体例

#### 事例1:
入力:
```
4 1 2
1 5 3
```
- **ステップ1**: 円1の中心座標は `(4, 1)`、半径は `2`。円2の中心座標は `(1, 5)`、半径は `3`。
- **ステップ2**: 中心間の距離 `d` を計算します。

$$
d = \sqrt{(4 - 1)^2 + (1 - 5)^2} = \sqrt{9 + 16} = \sqrt{25} = 5
$$

- **ステップ3**: 判定の流れ
  - 半径の差: `|r1 - r2| = |2 - 3| = 1`
  - 半径の和: `r1 + r2 = 2 + 3 = 5`
  - 距離 `d = 5` は半径の和と等しいので、4番目の状態、つまり「円が外接している」と判断されます。
  出力: `4`

#### 事例2:
入力:
```
1 1 6
3 3 2
```
- **ステップ1**: 円1の中心座標は `(1, 1)`、半径は `6`。円2の中心座標は `(3, 3)`、半径は `2`。
- **ステップ2**: 中心間の距離 `d` を計算します。

$$
d = \sqrt{(1 - 3)^2 + (1 - 3)^2} = \sqrt{4 + 4} = \sqrt{8} \approx 2.83
$$

- **ステップ3**: 判定の流れ
  - 半径の差: `|r1 - r2| = |6 - 2| = 4`
  - 半径の和: `r1 + r2 = 6 + 2 = 8`
  - 距離 `d ≈ 2.83` は半径の差 `4` より小さいため、1番目の状態、つまり「一方の円が他方を完全に含み、接していない」と判断されます。
  出力: `1`

### まとめ:
このコードは、2つの円の位置関係を計算して判定するシンプルなアルゴリズムです。中心間の距離をまず計算し、条件に基づいてその関係を判定していきます。数学的な概念（円の位置関係や座標間の距離）に基づいているので、初心者でも数式を理解しながらステップバイステップで追っていける内容になっています。

<br>
<br>

---
# 036

このコードでは、アナログ時計の時針と分針の端点の距離を三角関数を使って計算しています。これから、コードの全体的な流れ、使われている数式、そして具体的な事例を用いて解説します。

## 1. 基本アイデア

アナログ時計の時針と分針はそれぞれ異なる角速度で回ります。H時M分の時、時針と分針が作る角度を計算し、その角度を基にして2本の針の固定されていない端点間の距離を求めます。

三角形の3辺の長さと角度に関する関係を示す**余弦定理**を使って、距離を計算しています。

### 余弦定理とは
余弦定理は、任意の三角形の2辺とそれらの間の角度を用いて、残りの辺の長さを計算する方法です。

公式は次の通りです： $c^2 = a^2 + b^2 - 2ab \cdot \cos(\theta)$

ここで：
- $a$ と $b$ は、時針と分針の長さに相当します。
- $\theta$ は、時針と分針が作る角度です。
- $c$ は、2つの針の固定されていない端点間の距離（求めたい値）です。

### 解説コード

### `calc_distance(A, B, H, M)` 関数
1. **角度の計算**
   - `angle_H`: 時針の角度を計算します。時針は12時間で1周 (360度) します。したがって、H時の時針の角度は $360 \times \dfrac{H}{12}$ となります。また、M分が経過している場合は、時針が次の時間に少し進んでいるため、分針の進行を考慮して追加の角度を計算します。これが $30 \times \dfrac{M}{60}$ です。
   - `angle_M`: 分針の角度を計算します。分針は1時間で1周 (360度) するため、M分の角度は $360 \times \dfrac{M}{60}$ となります。

2. **時針と分針の角度差**
   - `angle_diff`: 時針と分針が作る角度の絶対値を計算します。もし、この角度差が180度を超える場合、時計回りでなく逆回り（短いほうの角度）を使うため、360 - angle_diff にして最短の角度差に修正します。

3. **角度をラジアンに変換**
   - `math.radians(angle_diff)`: 三角関数を使うためには、角度をラジアン（radians）に変換します。これはPythonの `math` モジュールで行います。

4. **余弦定理で距離を計算**
   - 余弦定理を使って、針の端点間の距離を計算します。<br>
   公式は <br>$\text{distance} = \sqrt{A^2 + B^2 - 2AB \cdot \cos(\theta)}$ です。<br>
   `math.cos(angle_rad)` で角度の余弦を求めています。

### `main()` 関数
- 標準入力から `A, B, H, M` の4つの値を受け取ります。
- `calc_distance` 関数を使って計算し、その結果を表示します。

## 2. 具体例を使った解説

### 入力例
```
3 4 9 0
```
- A = 3 cm (時針の長さ)
- B = 4 cm (分針の長さ)
- H = 9 時
- M = 0 分

#### ステップ 1: 時針の角度を計算する
時針は9時なので、基準角度は $360 \times \dfrac{9}{12} = 270^\circ$ です。分は0なので、時針は9時の場所にいます。したがって、`angle_H = 270`。

#### ステップ 2: 分針の角度を計算する
分針は0分なので、分針は12時の位置にあり、angle_M = $0^\circ$ です。

#### ステップ 3: 角度差を計算する
時針と分針の角度差は $|270 - 0| = 270^\circ$ ですが、この角度は180度を超えているので、逆方向を取るために $360 - 270 = 90^\circ$ に修正します。

#### ステップ 4: 距離の計算
余弦定理を適用します。角度 $90^\circ$ をラジアンに変換すると、 $\theta = \dfrac{\pi}{2}$ です。<br>
余弦の値は $\cos(90^\circ) = 0$ なので、余弦定理の式は次のようになります：<br>
$c^2 = 3^2 + 4^2 - 2 \times 3 \times 4 \times 0 = 9 + 16 = 25$ <br>
したがって、距離 $c = \sqrt{25} = 5$ です。

### 出力
```
5.0
```

## 3. まとめ

- **余弦定理**を使って、時針と分針の端点間の距離を計算しました。
- **角度の計算**では、時針と分針の進行角度を個別に計算し、それらの角度差を求めて短いほうの角度を使いました。
- **余弦定理の適用**により、時計の2本の針が形成する三角形から距離を求めています。

これにより、任意の時刻での時針と分針の端点間の距離を正確に計算できます。

<br>
<br>

---
# 037

このコードは、2 つの線分が平面上で交差するかどうかを判定するものです。<br>
以下に、各部分の詳細な解説と、その数学的背景について初心者向けに説明します。

## [前提] 数学

### 1. ベクトルと外積の基礎

#### 1.1 ベクトルとは
ベクトルとは、**大きさ**と**向き**を持つ量のことです。2次元平面上では、ある点から別の点までを結ぶ矢印として考えることができます。例えば、点A `(x1, y1)` から点B `(x2, y2)` へのベクトルは、次のように表されます。

- ベクトルAB = `(x2 - x1, y2 - y1)`

#### 1.2 外積とは
2次元のベクトルにおける**外積**は、2つのベクトルが作る面積や方向を示します。特に、外積を計算することで、あるベクトルが別のベクトルの**右側**にあるか、**左側**にあるか、または**同じ直線上**にあるかを判定できます。

- **外積の計算式**
  - ベクトル `A = (x1, y1)` とベクトル `B = (x2, y2)` の外積は次のように計算します。
  - 外積 = `x1 * y2 - x2 * y1`

#### 1.3 外積の結果が示す意味
- **外積 > 0** の場合、ベクトルBはベクトルAに対して**左側**にあります。
- **外積 < 0** の場合、ベクトルBはベクトルAに対して**右側**にあります。
- **外積 = 0** の場合、ベクトルAとベクトルBは**同じ直線上**にあります。

この外積の性質を使って、2つの線分が交差しているかどうかを判定します。

### 2. 2本の線分の交差判定

線分の交差判定では、次の点を確認します：
- 2本の線分が交差している場合、1本目の線分の両端の点が、2本目の線分に対して**反対側**に位置しているはずです。同様に、2本目の線分の両端も1本目に対して**反対側**にある必要があります。

具体的にどういうことか、図を想像してみてください。

#### 例：交差している場合
例えば、1本目の線分が `A-B`、2本目の線分が `C-D` とします。
- 線分ABの両端AとBに対して、点Cが左側に、点Dが右側にあるとき、この線分は交差している可能性があります。逆に、線分CDに対して、点Aが左側に、点Bが右側にある場合も交差が確認できます。

この**左右の判定**を外積を使って行います。

### 3. 外積を使った交差判定の詳細

#### 3.1 外積を使って線分の相対的な位置を調べる
外積を使って、次の4つの組み合わせを考えます。

1. 線分ABに対して、CとDがどちら側にあるか。
   - ベクトル `AB` とベクトル `AC` の外積 `cp1`
   - ベクトル `AB` とベクトル `AD` の外積 `cp2`

2. 線分CDに対して、AとBがどちら側にあるか。
   - ベクトル `CD` とベクトル `CA` の外積 `cp3`
   - ベクトル `CD` とベクトル `CB` の外積 `cp4`

これらの外積の符号を確認し、交差しているかを判定します。

#### 3.2 交差しているかの条件
- **線分ABの両端（AとB）が線分CDに対して反対側にある**（外積の符号が異なる）：
  - `cp1 * cp2 <= 0`
- **線分CDの両端（CとD）が線分ABに対して反対側にある**（外積の符号が異なる）：
  - `cp3 * cp4 <= 0`

この条件が両方とも満たされる場合、線分ABとCDは交差していると判断できます。

### 4. コードの流れと具体例

#### 例: 2本の線分が交差する場合
例えば、次の座標で2本の線分が交差しているとします。

- 線分AB: A(1, 1), B(4, 4)
- 線分CD: C(1, 4), D(4, 1)

この場合の処理を見てみましょう。

```python
A = [1, 1]
B = [4, 4]
C = [1, 4]
D = [4, 1]
```

- `AB = (4 - 1, 4 - 1) = (3, 3)`
- `AC = (1 - 1, 4 - 1) = (0, 3)`
- `AD = (4 - 1, 1 - 1) = (3, 0)`

ここで、ベクトル `AB` と `AC` の外積 `cp1` を計算します。
- `cp1 = 3 * 3 - 3 * 0 = 9`

同様に、ベクトル `AB` と `AD` の外積 `cp2` を計算します。
- `cp2 = 3 * 0 - 3 * 3 = -9`

この時点で、`cp1` と `cp2` の符号が異なるので、線分ABに対して、点Cと点Dは反対側にあることが分かります。

同様に、線分CDに対して点Aと点Bの位置関係を調べ、結果的に両方が反対側にあることが確認できるため、これらの線分は交差していると判断できます。

### 5. 最後に

このように、外積は線分の交差判定において重要な役割を果たします。ベクトルの向きを使って、2つの線分が交差しているかどうかを効率的に判定するための手法です。この仕組みは、単純な位置判定だけでは扱いにくい問題を解決するために有効です。

## [本題] コード全体の流れ

1. **座標の入力とベクトルの計算**:

   - 4 つの点の座標を入力し、それぞれを結ぶ線分のベクトルを計算します。

2. **外積の計算**:

   - 計算したベクトルを使って外積を求め、点と線分の位置関係を判定します。

3. **線分の端点をソート**:

   - 線分の端点を比較して、端点が昇順になるように並べ替えます。

4. **交差判定**:
   - 線分が交差しているかどうかを外積とソートされた端点の位置関係を使って判定し、その結果を出力します。

### 各部分の詳細な解説

#### 1. 外積 (`cross_product`) とベクトル (`vector`) の計算

```python
def cross_product(x1, y1, x2, y2):
    return x1 * y2 - x2 * y1

def vector(a, b):
    return b[0] - a[0], b[1] - a[1]
```

- **ベクトル (`vector`)**:

  - 2 つの点 `a` と `b` を与えたとき、その点を結ぶベクトルを計算します。<br>
    ベクトルは方向と長さを持つ量で、`a` から `b` へ向かう方向を示します。
  - 具体的には、`a` から `b` へのベクトルは、<br>
    `b[0] - a[0]`（x 成分）と<br>
    `b[1] - a[1]`（y 成分）<br>
    で表されます。

- **外積 (`cross_product`)**:
  - 2 つのベクトル `AB` と `AC` の外積は、ベクトルが作る平行四辺形の面積に関連しています。<br>
    この値は、点 `C` が線分 `AB` の左側にあるか、右側にあるか、または同一直線上にあるかを判定するのに役立ちます。
  - 具体的には、`cross_product(x1, y1, x2, y2)` は、2 つのベクトルの x 成分と y 成分を使って計算されます。<br>
    この値が正なら右側、負なら左側、ゼロなら同一直線上にあることを意味します。

#### 2. 座標の入力とベクトルの計算

```python
def read_point():
    return list(map(int, input().split()))

def main():
    A = read_point()
    B = read_point()
    C = read_point()
    D = read_point()

    AB = vector(A, B)
    AC = vector(A, C)
    AD = vector(A, D)
    CD = vector(C, D)
    CA = vector(C, A)
    CB = vector(C, B)
```

- **座標の入力 (`read_point`)**:

  - 各点の座標を入力として受け取り、リスト形式で返します。

- **ベクトルの計算**:
  - `AB`, `AC`, `AD`, `CD`, `CA`, `CB` というベクトルを作成します。それぞれのベクトルは、対応する 2 つの点を結んでいます。

#### 3. 外積を使った交差判定

```python
    cp1 = cross_product(*AB, *AC)
    cp2 = cross_product(*AB, *AD)
    cp3 = cross_product(*CD, *CA)
    cp4 = cross_product(*CD, *CB)
```

- **外積 (`cp1`, `cp2`, `cp3`, `cp4`) の計算**:
  - `cp1` と `cp2` は、線分 `AB` に対する点 `C` と点 `D` の位置関係を示します。
  - `cp3` と `cp4` は、線分 `CD` に対する点 `A` と点 `B` の位置関係を示します。
  - 外積の結果を使って、点が線分のどちら側にあるか、または同一直線上にあるかを判定します。

#### 4. 線分の端点をソートして交差判定

```python
    if A > B:
        A, B = B, A
    if C > D:
        C, D = D, C

    if cp1 == 0 and cp2 == 0 and cp3 == 0 and cp4 == 0:
        return print('Yes' if max(A, C) <= min(B, D) else 'No')
    else:
        return print('Yes' if cp1 * cp2 <= 0 and cp3 * cp4 <= 0 else 'No')
```

- **端点のソート**:

  - ここで、端点 `A`, `B`, `C`, `D` を比較し、端点が昇順になるように並べ替えています。<br>
    これにより、線分が正しい順序で比較されるようになります。

- **同一直線上にある場合の判定**:

  - `cp1`, `cp2`, `cp3`, `cp4` がすべてゼロであれば、線分 `AB` と `CD` は同一直線上にあります。<br>
    この場合、`max(A, C) <= min(B, D)` という条件を使って、線分が重なっているかを判定します。
  - この条件が成り立てば、線分は交差しているので「Yes」を返し、そうでなければ「No」を返します。

- **通常の交差判定**:
  - `cp1 * cp2 <= 0 and cp3 * cp4 <= 0` という条件は、各線分の端点が他方の線分の異なる側にある場合に成立します。<br>
    これにより、2 つの線分が交差しているかどうかを判定します。

### まとめ

このコードは、幾何学的な手法を使って 2 つの線分が交差しているかどうかを正確に判定します。外積を使って各点がどちら側にあるかを調べ、さらに線分が同一直線上にある場合の処理も行うことで、すべてのケースに対応できるようにしています。これにより、線分の交差を効率的に判定することができます。

## [事例] 具体例
線分の交差判定において、最終的に4つのパターンが生じることについて、それぞれの事例を使って説明します。また、線分が同じ直線上にある場合のソート処理についても解説します。

### 1. 交差判定の4パターン

2本の線分 `AB` と `CD` が交差するかどうかは、次の4つの条件に基づきます。外積を用いて判定することができ、それぞれ異なる事例が該当します。

#### 条件1: `cp1 * cp2 <= 0`（線分 `AB` に対する `C` と `D` の位置関係）
- `cp1` = ベクトル `AB` とベクトル `AC` の外積
- `cp2` = ベクトル `AB` とベクトル `AD` の外積

#### 条件2: `cp3 * cp4 <= 0`（線分 `CD` に対する `A` と `B` の位置関係）
- `cp3` = ベクトル `CD` とベクトル `CA` の外積
- `cp4` = ベクトル `CD` とベクトル `CB` の外積

この条件が両方とも満たされる場合に線分は交差します。

次に、これらのパターンごとの事例を見ていきます。

### パターン1: 完全に交差している場合

**例**:
- 線分 `AB` と線分 `CD` が完全に交差している場合。
- `A(1, 1)`, `B(4, 4)`, `C(1, 4)`, `D(4, 1)`

```python
A = [1, 1]
B = [4, 4]
C = [1, 4]
D = [4, 1]
```

計算:
- `AB = (3, 3)`
- `AC = (0, 3)`, `AD = (3, 0)`
- 外積 `cp1 = 3 * 3 - 3 * 0 = 9`
- 外積 `cp2 = 3 * 0 - 3 * 3 = -9`

- `CD = (3, -3)`
- `CA = (0, -3)`, `CB = (3, -3)`
- 外積 `cp3 = -3 * -3 - 3 * 0 = 9`
- 外積 `cp4 = -3 * -3 - 3 * -3 = -9`

結果: 両方とも条件を満たすため、**交差している**。

### パターン2: 一部が重なっている場合（重なる部分が含まれる）

**例**:
- `A(1, 1)`, `B(5, 5)`, `C(3, 3)`, `D(6, 6)`
- ここでは、線分 `AB` に対して、線分 `CD` の一部が重なっている。

```python
A = [1, 1]
B = [5, 5]
C = [3, 3]
D = [6, 6]
```

計算:
- `AB = (4, 4)`
- `AC = (2, 2)`, `AD = (5, 5)`
- 外積 `cp1 = 4 * 2 - 4 * 2 = 0`
- 外積 `cp2 = 4 * 5 - 4 * 5 = 0`

結果: 外積が0の場合、これは同じ直線上にあるという意味になります。**重なっている部分がある**ため、この場合も交差とみなします。

### パターン3: 平行だが交差しない場合

**例**:
- 線分 `AB` と `CD` が平行で、完全に別々の位置にある場合。
- `A(1, 1)`, `B(3, 3)`, `C(4, 4)`, `D(6, 6)`

```python
A = [1, 1]
B = [3, 3]
C = [4, 4]
D = [6, 6]
```

計算:
- `AB = (2, 2)`
- `AC = (3, 3)`, `AD = (5, 5)`
- 外積 `cp1 = 2 * 3 - 2 * 3 = 0`
- 外積 `cp2 = 2 * 5 - 2 * 5 = 0`

結果: **平行で、交差していない**。線分が同じ直線上にあるが、重なっていない場合も外積が0になります。

### パターン4: 交差しない（完全に離れている）

**例**:
- 交差していないケース。
- `A(1, 1)`, `B(2, 2)`, `C(3, 3)`, `D(4, 4)`

```python
A = [1, 1]
B = [2, 2]
C = [3, 3]
D = [4, 4]
```

計算:
- `AB = (1, 1)`
- `AC = (2, 2)`, `AD = (3, 3)`
- 外積 `cp1 = 1 * 2 - 1 * 2 = 0`
- 外積 `cp2 = 1 * 3 - 1 * 3 = 0`

結果: **交差していない**。

### 5. ソート処理の意味

外積が0（つまり、ベクトルが同じ直線上にある）場合、線分の**並び順**を考慮して交差しているかを判定します。これは、線分が並んでいるか、重なっているかを確認するために必要です。

#### ソートの例
もし、`A` の座標が `B` より大きい場合、`A` と `B` を入れ替えます。同様に、`C` の座標が `D` より大きければ、それらを入れ替えます。こうすることで、線分が必ず**左から右**に向かうように揃えることができます。これによって、重なりを正確に判定することが可能になります。

#### ソートのコード部分

```python
if A > B:
    A, B = B, A
if C > D:
    C, D = D, C
```

これにより、`A <= B` と `C <= D` という順序が常に守られるようになります。線分が重なっているかどうかを確認するためには、次のようにして重なりの範囲を確認します。

```python
if max(A, C) <= min(B, D):
    'Yes'
else:
    'No'
```

この判定では、`A` と `B`、`C` と `D` の範囲が重なっているかどうかを確認しています。

## [補足] 線分の端点をソートする理由

まず、2 つの線分が同じ直線上にある場合を考えます。たとえば、線分 `AB` と線分 `CD` が同じ直線上にあるとき、これらが重なり合っているかどうかを確認する必要があります。重なり合っていれば「交差している」と判断し、重なっていなければ「交差していない」と判断します。

#### 端点のソートとは？

ソート（順序づけ）とは、数字や物を大きさや順序に従って並び替えることです。ここでは、線分の端点（始点と終点）を比較して、小さい方が始点、大きい方が終点になるように並び替えています。

### 具体例で説明

例えば、次のような点の配置を考えます。

- 点 `A(1, 1)`
- 点 `B(4, 1)`
- 点 `C(2, 1)`
- 点 `D(3, 1)`

この場合、線分 `AB` は `A` から `B` まで、線分 `CD` は `C` から `D` までです。ここで、`A` が `B` より左にあり、`C` が `D` より左にあるため、特に並び替える必要はありません。

### なぜソートが必要か？

もし、端点をソートしないと、例えば次のような状況で正しい判定ができないことがあります。

- 点 `A(4, 1)`
- 点 `B(1, 1)`
- 点 `C(3, 1)`
- 点 `D(2, 1)`

この場合、`A` が `B` より右にあり、`C` が `D` より右にあるため、端点が「逆」に並んでいます。これを放置すると、線分の重なりを正しく判断できない可能性があります。つまり、線分 `AB` は実際には `B` から `A` まで引かれており、`CD` は `D` から `C` まで引かれています。これでは、数学的には「逆方向の線分」になります。

このため、ソートして `A` と `B` を比較し、`A` が `B` より左にくるように（または `C` と `D` についても同様に）並べ替えるのです。これにより、線分の向きを統一し、次の重なり判定が適切に行われるようにします。

### 重なりの判定

端点がソートされた後、次に行うのは、これらの線分が同じ直線上に並んでいる場合、重なっているかどうかを判定することです。

```python
if cp1 == 0 and cp2 == 0 and cp3 == 0 and cp4 == 0:
    return print('Yes' if max(A, C) <= min(B, D) else 'No')
```

この部分では、もし `cp1` から `cp4` までの外積がすべてゼロの場合、線分はすべて同一直線上にあることを示しています。このとき、`max(A, C) <= min(B, D)` という条件を使って、線分が重なっているかどうかを判定しています。

- `max(A, C)` は `A` と `C` の中で右側（大きい方）の点を表し、
- `min(B, D)` は `B` と `D` の中で左側（小さい方）の点を表します。

この条件が成り立つと、2 つの線分は重なっているので「Yes」を返し、そうでなければ「No」を返します。

### まとめ

端点をソートする理由は、線分の向きを統一して正しい重なりの判定ができるようにするためです。ソートを行うことで、同一直線上にある線分が正しく重なっているかどうかを判定し、交差の有無を正確に判断できるようになります。

<br>
<br>

---
# 038

このコードは、遊園地の来場者数を特定の日数の範囲で計算する問題を解いています。各日ごとの来場者数をもとに、累積和を使って効率よく範囲の合計を求めるという流れです。


### 関数の説明

#### 1. `calc_cumulative_sum(N, A)`:
```python
def calc_cumulative_sum(N, A):
    calmulative_sum = [0] * (N+1)
    for i in range(N):
        calmulative_sum[i+1] = calmulative_sum[i] + A[i]
    return calmulative_sum
```
- **目的**: `A` というリストに含まれる日ごとの来場者数から累積和を計算します。
- **引数**:
  - `N`: 日数の合計。リスト `A` の長さに対応しています。
  - `A`: 各日の来場者数が格納されたリストです。
- **処理内容**:
  - 長さ `N+1` の `calmulative_sum` というリストを作成します。`calmulative_sum[i]` は、1日目から `i` 日目までの来場者数の合計です。`calmulative_sum[0]` は0で初期化されます。
  - `A` の各要素を順番に累積し、`calmulative_sum` に値を蓄積します。
- **戻り値**: 累積和を格納したリスト `calmulative_sum` を返します。

#### 2. `answer(calmulative_sum, LR)`:
```python
def answer(calmulative_sum, LR):
    for L, R in LR:
        print(calmulative_sum[R] - calmulative_sum[L-1])
```
- **目的**: クエリ（質問）ごとに、指定された範囲 `[L, R]` の来場者数の合計を計算し、出力します。
- **引数**:
  - `calmulative_sum`: 1日目から各日までの累積和が格納されたリスト。
  - `LR`: 各クエリ（質問）が格納されたリスト。各要素は `(L, R)` というタプルで、`L` 日目から `R` 日目までの合計を求める範囲です。
- **処理内容**:
  - 各 `L, R` について、`calmulative_sum[R] - calmulative_sum[L-1]` で範囲の合計来場者数を計算し、それを出力します。

#### 3. `main()`:
```python
def main():
    N, Q = map(int, input().split())
    A = list(map(int, input().split()))
    LR = [tuple(map(int, input().split())) for _ in range(Q)]
    calmulative_sum = calc_cumulative_sum(N, A)
    answer(calmulative_sum, LR)
```

- **目的**: 入力を受け取り、クエリごとに答えを求めます。
- **処理内容**:
  - `N` と `Q` を入力から読み取り、`A` に来場者数リストを格納します。
  - 各クエリ（質問）を `LR` というリストに格納し、`calc_cumulative_sum()` を使って累積和を計算します。
  - `answer()` を呼び出し、クエリに答えます。

### 具体例での説明

#### 入力例
```
10 5
8 6 9 1 2 1 10 100 1000 10000
2 3
1 4
3 9
6 8
1 10
```

#### ステップ 1: 累積和の計算
入力として、来場者数リスト `A = [8, 6, 9, 1, 2, 1, 10, 100, 1000, 10000]` を受け取ります。

`calc_cumulative_sum(N, A)` では、累積和を次のように計算します。

| `i`  | `A[i]` | `calmulative_sum[i+1]` (1日目からi日目までの合計) |
|------|--------|--------------------------------------------------|
| 0    | 8      | 8                                                |
| 1    | 6      | 14                                               |
| 2    | 9      | 23                                               |
| 3    | 1      | 24                                               |
| 4    | 2      | 26                                               |
| 5    | 1      | 27                                               |
| 6    | 10     | 37                                               |
| 7    | 100    | 137                                              |
| 8    | 1000   | 1137                                              |
| 9    | 10000  | 11137                                             |

最終的に、`calmulative_sum` は次のようになります：
```
calmulative_sum = [0, 8, 14, 23, 24, 26, 27, 37, 137, 1137, 11137]
```

#### ステップ 2: クエリの処理
クエリは5つあります。`answer()` 関数で順に処理します。

1. **クエリ (2, 3)**:
   - 範囲 2日目から3日目の合計を求めます。
   - 計算: `calmulative_sum[3] - calmulative_sum[1] = 23 - 8 = 15`
   - 結果: 15

2. **クエリ (1, 4)**:
   - 範囲 1日目から4日目の合計を求めます。
   - 計算: `calmulative_sum[4] - calmulative_sum[0] = 24 - 0 = 24`
   - 結果: 24

3. **クエリ (3, 9)**:
   - 範囲 3日目から9日目の合計を求めます。
   - 計算: `calmulative_sum[9] - calmulative_sum[2] = 1137 - 14 = 1123`
   - 結果: 1123

4. **クエリ (6, 8)**:
   - 範囲 6日目から8日目の合計を求めます。
   - 計算: `calmulative_sum[8] - calmulative_sum[5] = 137 - 26 = 111`
   - 結果: 111

5. **クエリ (1, 10)**:
   - 範囲 1日目から10日目の合計を求めます。
   - 計算: `calmulative_sum[10] - calmulative_sum[0] = 11137 - 0 = 11137`
   - 結果: 11137

#### 最終出力
```
15
24
1123
111
11137
```

### ポイント
1. **累積和の利点**: 逐一、範囲の合計を計算するのは時間がかかりますが、累積和を使うことで効率よく計算できます。`S[R] - S[L-1]` という形で、事前に計算した和を再利用するため、クエリごとの処理が高速です。
2. **リストの1-indexing**: `calmulative_sum` のリストは0番目を使わず、1番目からN番目を扱うように設計しています。これにより、日数とリストのインデックスが一致し、理解しやすくなっています。

<br>
<br>

---
# 039

### コードの解説

#### 1. `answer` 関数
```python
def answer(N, snow):
    res = []
    for i in range(1, N):
        if snow[i] > 0:
            res.append('<')
        elif snow[i] == 0:
            res.append('=')
        else:
            res.append('>')
    return print(''.join(res))
```
- この関数は、`snow` リストの内容に基づいて、隣接する区画の積雪量を比較し、記号 `'<', '=', '>'` を出力します。
- `res` は、結果を格納するリストです。
- `for` ループでは、`i=1` から `N-1` までを順に見ていきます。`snow[i]` が `0` より大きければ `'<（小さい）'` を追加し、`snow[i]` が `0` なら `'='` を、`0` より小さければ `'>'` を追加します。
- 最後に、`res` の内容を連結して文字列化し、それを出力します。

#### 2. `calc_cumulative_sum` 関数
```python
def calc_cumulative_sum(N, items):
    snow = [0] * (N+1)
    for L, R, X in items:
        snow[L-1] += X
        snow[R] -= X
    return snow
```
- `snow` は長さ `N+1` のリストで、各区間における雪の増減を記録します。
- `items` の各要素は `(L, R, X)` という形式のタプルです。これは、区間 `[L, R]` に `X` cm の雪が積もることを意味します。
- `snow[L-1] += X` は、区間 `L-1` に雪が `X` cm 積もることを表します。
- `snow[R] -= X` は、区間 `R` の次の位置に `-X` を加えて調整するために行います。これは、区間 `[L, R]` にのみ雪が積もることを管理するための「差分配列」の考え方です。

#### 3. `main` 関数
```python
def main():
    N, Q = map(int, input().split())
    items = [tuple(map(int, input().split())) for _ in range(Q)]
    snow = calc_cumulative_sum(N, items)
    answer(N, snow)
```
- この関数では、`N`（区画数）と `Q`（クエリ数）を入力として受け取り、降雪情報を `items` に格納します。
- `calc_cumulative_sum` 関数を使って、各区画にどのような積雪量の変動があったかを計算します。
- その結果に基づいて、隣接する区画の積雪量を比較し、結果を出力するために `answer` 関数を呼び出します。

### 処理の例

#### 入力例
```
5 3
1 2 3
2 5 4
2 4 1
```

1行目の `5 3` は、5つの区画と3つの降雪イベントがあることを示しています。次の3行には、それぞれ `(L, R, X)` 形式で降雪のイベントが与えられています。

- `1 2 3`: 区間 `[1, 2]` に `3` cm の雪が積もる。
- `2 5 4`: 区間 `[2, 5]` に `4` cm の雪が積もる。
- `2 4 1`: 区間 `[2, 4]` に `1` cm の雪が積もる。

#### `calc_cumulative_sum` の処理

入力の3つのイベントを基に、`snow` リストを次のように更新していきます。

1. 初期状態: `snow = [0, 0, 0, 0, 0, 0]`
2. 最初のクエリ `1 2 3` を処理:
   - `snow[0] += 3` → `snow = [3, 0, 0, 0, 0, 0]`
   - `snow[2] -= 3` → `snow = [3, 0, -3, 0, 0, 0]`
3. 次のクエリ `2 5 4` を処理:
   - `snow[1] += 4` → `snow = [3, 4, -3, 0, 0, 0]`
   - `snow[5] -= 4` → `snow = [3, 4, -3, 0, 0, -4]`
4. 最後のクエリ `2 4 1` を処理:
   - `snow[1] += 1` → `snow = [3, 5, -3, 0, 0, -4]`
   - `snow[4] -= 1` → `snow = [3, 5, -3, 0, -1, -4]`

最終的に、`snow = [3, 5, -3, 0, -1, -4]` となります。

#### `answer` の処理

次に、`answer` 関数で積雪量を比較します。この関数では、`i=1` から `N-1` までを比較します。

- `snow[1] = 5` なので、`snow[1] > 0` → `'<'` がリストに追加されます。
- `snow[2] = -3` なので、`snow[2] < 0` → `'>'` がリストに追加されます。
- `snow[3] = 0` なので、`snow[3] == 0` → `'='` がリストに追加されます。
- `snow[4] = -1` なので、`snow[4] < 0` → `'>'` がリストに追加されます。

最終的に、結果は `<>=>` となり、出力されます。

### まとめ

- このコードは差分配列を使って効率よく雪の積もり方を計算しています。
- `snow` リストに雪の増減を記録し、それを基に隣接する区画の積雪量を比較しています。

<br>
<br>

---

# 040

## コードの解説

このコードは、ALGO鉄道の駅間距離と太郎君の訪問駅リストから、総移動距離を計算するプログラムです。

### 関数 `calc_total_distance(A, M, B)`
```python
def calc_total_distance(A, M, B):
    dist = 0
    for i in range(M-1):
        start, end = B[i]-1, B[i+1]-1
        if start < end:
            dist += sum(A[start:end])
        else:
            dist += sum(A[end:start])
    return dist
```


この関数は、駅間距離リスト`A`、訪問駅数`M`、訪問駅リスト`B`を受け取り、総移動距離を計算して返します。

1. **初期化:** `dist = 0` で、総移動距離を初期化します。

2. **訪問駅間のループ:** `for i in range(M-1):` で、訪問駅間の移動を計算するためにループします。

    - `start, end = B[i]-1, B[i+1]-1`:  訪問駅リスト`B`から、現在(`i`)と次の(`i+1`)駅のインデックスを取得します。リストのインデックスは0から始まるため、駅番号から1を引いています。

    - **移動方向の判定:** `if start < end:` で、西から東へ向かう移動かどうかを判定します。

        - **西から東への移動:** `dist += sum(A[start:end])`: `A[start:end]` で、`start`駅（含まれる）から`end`駅（含まれない）までの駅間距離リストを取得し、その合計を`dist`に加算します。

        - **東から西への移動:** `dist += sum(A[end:start])`: 東から西への移動の場合は、`end`駅（含まれる）から`start`駅（含まれない）までの駅間距離リストを取得し、その合計を`dist`に加算します。

3. **総移動距離の返却:** すべての訪問駅間の移動距離を計算したら、`return dist`で総移動距離を返します。

### 関数 `main()`

```python
def main():
    N = int(input())
    A = list(map(int, input().split()))
    M = int(input())
    B = [int(input()) for _ in range(M)]
    print(calc_total_distance(A, M, B))
```


この関数は、プログラムのメイン処理を行います。

1. **入力の受け取り:**
   - `N = int(input())`: 駅の数`N`を入力します。
   - `A = list(map(int, input().split()))`: 駅間距離リスト`A`を入力します。
   - `M = int(input())`: 訪問駅数`M`を入力します。
   - `B = [int(input()) for _ in range(M)]`: 訪問駅リスト`B`を入力します。

2. **総移動距離の計算と出力:** `print(calc_total_distance(A, M, B))` で、`calc_total_distance`関数を呼び出して総移動距離を計算し、結果を出力します。


### `if __name__ == "__main__":`

この部分は、このPythonファイルが直接実行された場合にのみ、`main()`関数が実行されるようにするための記述です。

## 事例を使った処理過程の説明

入力例1を例に、処理過程を説明します。

**入力例1**
```
4
8 6 9
6
2
1
3
2
3
4
```

1. **入力の受け取り:**
   - `N = 4`
   - `A = [8, 6, 9]`
   - `M = 6`
   - `B = [2, 1, 3, 2, 3, 4]`

2. **`calc_total_distance`関数の実行:**

   - `dist = 0` で初期化

   - **1回目のループ (i=0):**
     - `start = 1`, `end = 0` (B[0]=2, B[1]=1)
     - `start > end` なので、東から西への移動
     - `dist += sum(A[0:1]) = 8` (駅1から駅2の距離)

   - **2回目のループ (i=1):**
     - `start = 0`, `end = 2` (B[1]=1, B[2]=3)
     - `start < end` なので、西から東への移動
     - `dist += sum(A[0:2]) = 14` (駅1から駅3の距離)

   - **3回目のループ (i=2):**
     - `start = 2`, `end = 1` (B[2]=3, B[3]=2)
     - `start > end` なので、東から西への移動
     - `dist += sum(A[1:2]) = 6` (駅3から駅2の距離)

   - **4回目のループ (i=3):**
     - `start = 1`, `end = 2` (B[3]=2, B[4]=3)
     - `start < end` なので、西から東への移動
     - `dist += sum(A[1:2]) = 6` (駅2から駅3の距離)

   - **5回目のループ (i=4):**
     - `start = 2`, `end = 3` (B[4]=3, B[5]=4)
     - `start < end` なので、西から東への移動
     - `dist += sum(A[2:3]) = 9` (駅3から駅4の距離)

   - 最終的に `dist = 43` となり、これが総移動距離として出力されます。

このように、このプログラムは訪問駅リストに基づいて駅間の移動をシミュレートし、総移動距離を計算します。

<br>
<br>

---
# 041

## コードの解説

このコードは、コンビニの営業時間中における各時刻の従業員数を計算するプログラムです。

### 関数 `count_employees(T, items)`

```python
def count_employees(T, items):
    diff = [0] * (T+1)
    for L, R in items:
        diff[L] += 1
        diff[R] -= 1

    res = 0
    for i in range(T):
        res += diff[i]
        print(res)
```

この関数は、コンビニの営業時間 `T` と、従業員の出勤・退勤時刻のリスト `items` を受け取り、各時刻の従業員数を計算して出力します。

1. **差分配列の初期化:**
   - `diff = [0] * (T+1)`:  まず、`diff` というリスト（配列）を `T+1` の長さで作成し、全ての要素を `0` で初期化します。このリストは、各時刻における従業員数の **増減** を表すために使われます。`T+1` としているのは、時刻 `T` (閉店時間) に退勤する場合に対応するためです。
2. **従業員の出退勤による増減を記録:**
   - `for L, R in items:`:  従業員の出勤・退勤時刻のリスト `items` から、各従業員のデータを取り出して処理します。
     - `diff[L] += 1`:  従業員が出勤する時刻 `L` に対応する `diff` の要素に `1` を加えます。これは、出勤によって従業員数が 1人増えることを表します。
     - `diff[R] -= 1`:  従業員が退勤する時刻 `R` に対応する `diff` の要素に `1` を減らします。これは、退勤によって従業員数が 1人減ることを表します。
3. **累積和による従業員数の計算:**
   - `res = 0`:  現在の従業員数を表す変数 `res` を `0` で初期化します。
   - `for i in range(T):`: 時刻 `0` から `T-1` までループします。
     - `res += diff[i]`:  現在の従業員数 `res` に、時刻 `i` における従業員数の増減 `diff[i]` を加算します。
     - `print(res)`:  時刻 `i` における従業員数 `res` を出力します。

### 関数 `main()`

この関数は、プログラムのメイン処理を行います。

1. **入力処理:**
   - `T = int(input())`:  コンビニの営業時間 `T` を入力として受け取ります。
   - `N = int(input())`:  従業員数 `N` を入力として受け取ります。
   - `items = [tuple(map(int, input().split())) for _ in range(N)]`:  各従業員の勤務時間 `L`, `R` を入力として受け取り、タプルのリストとして `items` に格納します。
2. **従業員数計算の実行:**
   - `print(count_employees(T, items))`:  `count_employees()` 関数を呼び出して、各時刻の従業員数を計算して出力します。

### `if __name__ == "__main__":`

この部分は、Pythonスクリプトが直接実行された場合にのみ `main()` 関数を呼び出すための記述です。

## 事例を使った処理過程の説明

例えば、コンビニの営業時間 `T` が `10`、従業員数 `N` が `3`、各従業員の勤務時間が `[(0, 3), (2, 4), (5, 6)]` であったとします。

### 1. `count_employees()` 関数の実行

1. `diff = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]` と初期化されます。
2. 1人目の従業員:  `L=0`, `R=3` なので、`diff[0]` に `1` を加え、 `diff[3]` から `1` を減らします。 `diff = [1, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0]` となります。
3. 2人目の従業員:  `L=2`, `R=4` なので、`diff[2]` に `1` を加え、 `diff[4]` から `1` を減らします。 `diff = [1, 0, 1, -1, -1, 0, 0, 0, 0, 0, 0]` となります。
4. 3人目の従業員:  `L=5`, `R=6` なので、`diff[5]` に `1` を加え、 `diff[6]` から `1` を減らします。 `diff = [1, 0, 1, -1, -1, 1, -1, 0, 0, 0, 0]` となります。
5. `res` を `0` で初期化します。
6. 時刻 `0` から `9` までループします:
   - `i = 0`: `res` に `diff[0]` (値は `1`) を加算し、 `res` は `1` になります。これを `print` します。
   - `i = 1`: `res` に `diff[1]` (値は `0`) を加算し、 `res` は `1` になります。これを `print` します。
   - `i = 2`: `res` に `diff[2]` (値は `1`) を加算し、 `res` は `2` になります。これを `print` します。
   - `i = 3`: `res` に `diff[3]` (値は `-1`) を加算し、 `res` は `1` になります。これを `print` します。
   - `i = 4`: `res` に `diff[4]` (値は `-1`) を加算し、 `res` は `0` になります。これを `print` します。
   - `i = 5`: `res` に `diff[5]` (値は `1`) を加算し、 `res` は `1` になります。これを `print` します。
   - `i = 6`: `res` に `diff[6]` (値は `-1`) を加算し、 `res` は `0` になります。これを `print` します。
   - `i = 7`, `i = 8`, `i = 9`:  `diff[7]` から `diff[9]` は全て `0` なので、`res` は変化せず `0` のままです。それぞれ `print` します。

### 2. 出力

最終的な出力は以下のようになります。

```
1
1
2
1
0
1
0
0
0
0
```

これは、各時刻におけるコンビニの従業員数を表しています。

<br>
<br>

---
# 042

このコードの目的は、与えられた正整数 `N` までのすべての整数 `K` に対して、`K × f(K)` の総和を効率的に求めることです。この問題の背景には、**整数の約数**に関する数学的な性質があり、それを活用して高速に計算を行っています。

コードを詳しく解説しながら、例を使って処理の流れをわかりやすく説明します。

---

## 基本的な考え方

まず、問題の焦点は「正の整数 `K` に対して `K × f(K)` の総和を計算する」ことです。`f(K)` は、`K` の正の約数の個数です。

### 例1: `N = 4` の場合

`f(1) = 1` (1の約数は1)
`f(2) = 2` (2の約数は1, 2)
`f(3) = 2` (3の約数は1, 3)
`f(4) = 3` (4の約数は1, 2, 4)

したがって、求めたい総和は次のようになります:

$1 \times 1 + 2 \times 2 + 3 \times 2 + 4 \times 3 = 23$

しかし、`N` が非常に大きい場合（例えば `N = 10^7` など）、このような直接的な計算では遅すぎるので、約数に関する数学的な性質を利用して高速に計算します。

---

## コードの詳細な解説

### 1. 和の公式 (`f(x)`)
```python
def f(x):
    return x * (x + 1) // 2
```

`f(x)` は、**1から `x` までの整数の総和**を計算する関数です。この関数は、次の数学的な公式に基づいています：

$1 + 2 + 3 + \cdots + x = \dfrac{x \times (x + 1)}{2}$ \]

例えば：

- `f(3)` の場合：`1 + 2 + 3 = 6` となり、これは公式に当てはめると次のように計算されます：

$$f(3) = \dfrac{3 \times (3 + 1)}{2} = \frac{3 \times 4}{2} = 6$$

- `f(5)` の場合：`1 + 2 + 3 + 4 + 5 = 15` となります。同様に：

$$f(5) = \dfrac{5 \times (5 + 1)}{2} = \frac{5 \times 6}{2} = 15$$

---

### 2. 約数の和を効率的に計算する (`sum_of_divisors`)
```python
def sum_of_divisors(N):
    res = 0
    for i in range(1, int(N**0.5)+1):
        res += i * i + 2 * i * (f(N//i) - f(i))
    return res
```

この関数では、`1` から `N` までの整数 `K` について、`K × f(K)` の総和を計算しています。以下では、この関数がどのように高速に計算しているかを見ていきます。

#### i のループ範囲

ループの範囲は `i` を `1` から `√N` までに制限しています。なぜかというと、ある数 `K` の約数は対になって現れるからです。例えば、`36` の約数を考えると、次のような対があります：

- 1と36
- 2と18
- 3と12
- 6と6

約数の小さい方を順に見ていけば、大きい方も同時に見つけられるため、`√N` まで調べるだけで済みます。

#### `res += i * i`

これは、`i` が自分自身の倍数である（つまり、`i * i` が約数となる）場合の特別な処理です。完全平方数の時に必要です。例えば、`i = 2` であれば、`2 * 2 = 4` で、`4` 自身が `2` の倍数です。

#### `2 * i * (f(N//i) - f(i))`

この部分は、`i` の倍数を効率的に処理しています。`N // i` は `i` の倍数の最大値です。たとえば `N = 100` の場合、`i = 2` だと `100 // 2 = 50` なので、`2` の倍数は `2, 4, 6, ..., 50` となります。

`f(N // i)` で、`i` の倍数の総和を計算し、`f(i)` を引くことで、`i` 自身を除いた倍数に対応する和を取得しています。

#### 例：`N = 10` の場合

`N = 10` の場合を例に処理を追ってみましょう。

1. `i = 1`
   - `f(N // i) = f(10) = 1 + 2 + ... + 10 = 55`
   - `f(i) = f(1) = 1`
   - 計算する式は `1 * 1 + 2 * 1 * (55 - 1) = 1 + 108 = 109`

2. `i = 2`
   - `f(N // i) = f(5) = 1 + 2 + 3 + 4 + 5 = 15`
   - `f(i) = f(2) = 1 + 2 = 3`
   - 計算する式は `2 * 2 + 2 * 2 * (15 - 3) = 4 + 48 = 52`

3. `i = 3`
   - `f(N // i) = f(3) = 1 + 2 + 3 = 6`
   - `f(i) = f(3) = 6`
   - 計算する式は `3 * 3 + 2 * 3 * (6 - 6) = 9 + 0 = 9`

最終的な結果として、`res = 109 + 52 + 9 = 170` となります。

---

### 計算量の詳細
このコードは、`N` の平方根までの範囲でループを回しています（`O(√N)`）。ループ内の各操作は一定時間（`O(1)`）で実行されるため、全体としての計算量は **`O(√N)`** です。これにより、`N` が非常に大きくても効率的に計算できます。

---

## まとめ

このコードは、数の約数に関する性質を巧妙に利用して、計算量を `O(√N)` に抑えることで高速に結果を求めています。特に大きな `N` に対しても効率的に動作します。

<br>

## [補足] `i * i + 2 * i * (f(N//i) - f(i))` という式の意味

`i * i + 2 * i * (f(N//i) - f(i))` という式の意味について、より詳細に説明します。

この式は、**整数 `N` に対して、その約数 `i` を効率的に扱う**ための工夫が含まれています。ここでは、この式が何を意味しているのかを、具体的な事例を用いて説明していきます。

---

### 背景：整数の約数と和の計算

まず、この問題では、`1` から `N` までのすべての整数 `K` に対して、`K × f(K)` の総和を求めています。ここで、`f(K)` は、`K` の正の約数の個数を表します。

直接的に `K` ごとに計算していくと非常に時間がかかりますが、整数の約数に関する数学的性質を使うことで、効率化が可能です。

#### ポイント

`K` の約数 `i` を見つけるとき、`i` とその倍数 `i * k` も同時に扱います。これによって、全体を効率的に計算できます。

---

### 式の分解と理解

式全体 `i * i + 2 * i * (f(N//i) - f(i))` は、**2つの部分**から成り立っています。それぞれを分解して見ていきましょう。

#### 1. `i * i` の部分

この部分は、`i` 自身が `N` の約数である場合に対応しています。つまり、`i` が `N` の約数のとき、その約数に対して `i × i` を加える必要があります。

- 例：`N = 36` の場合、`i = 6` のとき、`6 × 6 = 36` であるため、この値を加算します。

#### 2. `2 * i * (f(N // i) - f(i))` の部分

この部分は、`i` の倍数に対応しています。`N // i` は `i` の倍数のうち、`N` 以下の最大の倍数を表します。

例えば、`N = 36` で `i = 6` のとき、`N // i = 36 // 6 = 6` になります。`6` の倍数は `6, 12, 18, 24, 30, 36` です。

##### `f(N // i)` とは？

`f(N // i)` は、`1` から `N // i` までの整数の総和を表します。つまり、`i` の倍数を含む総和です。

##### `f(i)` とは？

`f(i)` は、`1` から `i` までの整数の総和を表します。`i` の倍数の中で最小の値である `i` 自身を含むため、それを差し引きます。

##### なぜ `2 * i` ？

ここで `2 * i` が使われるのは、`i` の倍数である数値すべてに対して、この操作を行う必要があるためです。倍数全体に対して、`i` を掛けた分を2倍にして計算します。

---

### 具体的な事例での理解

例えば、`N = 36` で `i = 6` の場合を考えてみましょう。

1. `i * i = 6 * 6 = 36`

   - これは、`6` 自身が約数であることに対応して加算しています。

2. `f(N // i) = f(36 // 6) = f(6) = 1 + 2 + 3 + 4 + 5 + 6 = 21`

3. `f(i) = f(6) = 1 + 2 + 3 + 4 + 5 + 6 = 21`

   - `i` 自身を含む部分を引くため、この場合、`f(N // i) - f(i) = 21 - 21 = 0` になります。

この場合、式の結果は次のようになります：

$$i * i + 2 * i * (f(N // i) - f(i)) = 6 * 6 + 2 * 6 * (21 - 21) = 36 + 0 = 36$$

これが `N = 36` で `i = 6` の場合の計算結果です。

---

### 別の例: `N = 36` で `i = 2`

次に、`i = 2` の場合を見てみましょう。

1. `i * i = 2 * 2 = 4`

2. `f(N // i) = f(36 // 2) = f(18) = 1 + 2 + 3 + ... + 18 = 171`

3. `f(i) = f(2) = 1 + 2 = 3`

この場合、`f(N // i) - f(i) = 171 - 3 = 168` です。

したがって、式は次のように計算されます：

$i * i + 2 * i * (f(N // i) - f(i)) = 2 * 2 + 2 * 2 * 168 = 4 + 672 = 676$

このようにして、`N = 36` に対して `i = 2` の倍数に関連する計算結果が得られます。

---

### 結論

`i * i + 2 * i * (f(N//i) - f(i))` という式は、`i` の倍数に関連するすべての数値を効率的に計算するための式です。`i` 自身が約数である部分と、その倍数に対する計算を同時に処理しています。

このアプローチは、`N` が大きい場合でも効率的に計算できる方法であり、各 `i` に対して必要な計算を最小限に抑えるために工夫されています。


<br>
<br>

---
# 043

### 部活ネットワーク！全員と繋がれるか！？ Pythonコードで徹底解説！

今度は、部活のメンバーを例に、「ある人からメッセージを伝言していくと全員に届くか」を判定するプログラムを解説します！

### 部活メンバーの関係をグラフで表す！

例えば、部員が5人 (Aさん～Eさん)いて、以下の様な関係だったとします。

- Aさん - Bさん, Cさん
- Bさん - Aさん, Dさん
- Cさん - Aさん
- Dさん - Bさん
- Eさん - (無し)

Eさんは、誰も知らない状態です。これを図にすると、こんな感じ！

```
     A
   /   \
  B     C
 /
D

E
```

この図の、
- Aさん、Bさん...を「頂点」
- メンバー同士の関係を「辺」
と呼びます。

### コード解説：伝言ゲームで全員に届け！

**1. 関係リストを作る！( `is_connected` 関数 )**

```python
def is_connected(N, edges):
    graph = [[] for _ in range(N)]  # 空の関係リストを人数分用意
    for a, b in edges:
        graph[a-1].append(b-1)  # aさんと関係がある人を登録
        graph[b-1].append(a-1)  # bさんと関係がある人を登録
    return dfs(graph, N)
```

- `N`: 部員の人数 (今回の例では5人)
- `edges`: メンバー同士の関係リスト (例: `[(1, 2), (1, 3), (2, 4)]`)

まず、 `graph = [[] for _ in range(N)]` で、全員分の空の関係リストを作ります。
 `[ [], [], [], [], [] ]` みたいなイメージですね！

次に、`for a, b in edges:` で、関係 `edges` を一つずつ取り出して、

- `graph[a-1].append(b-1)`: aさんと関係がある人をリストに追加
- `graph[b-1].append(a-1)`: bさんと関係がある人をリストに追加

していきます。
(Pythonでは番号は0から数えるので、`a-1` や `b-1` としています)

今回の例だと、最終的に `graph` は以下のようになります。

```python
graph = [
    [1, 2],  # Aさんと関係がある人: Bさん, Cさん
    [0, 3],  # Bさんと関係がある人: Aさん, Dさん
    [0],    # Cさんと関係がある人: Aさん
    [1],    # Dさんと関係がある人: Bさん
    []     # Eさんと関係がある人: 誰もいない！
]
```

**2. 伝言ゲームスタート！全員に届け！( `dfs` 関数 )**

```python
def dfs(graph, N):
    visited = [False] *  N  # 伝言済みリスト (最初は全員False)
    stack = [0]             # 今から伝言する人リスト (最初はAさん)
    while stack:            # 伝言する人リストが空になるまで続ける
        v = stack.pop()     # 伝言する人リストから一人取り出す
        if not visited[v]:   # もし、その人にまだ伝言していなかったら
            visited[v] = True # 伝言済みにする
            for nv in graph[v]:  # その人と関係がある人リストから一人ずつ取り出して
                stack.append(nv) # 伝言する人リストに追加する
    return all(visited)  # 全員に伝言できたならTrue、そうでなければFalseを返す
```

- `visited`: 伝言済みリスト。最初は全員 `False` で、伝言できたら `True` にしていきます。
- `stack`:  これから伝言する人を順番に入れておくリスト。

**処理の流れ:**

1. 最初はAさん( `0` )を `stack` に入れてスタート！
2. `stack` から一人取り出して (最初はAさん)、その人と関係がある人のリストを `graph` から確認
3. まだ伝言していない人がいたら、伝言済みにし、`stack` に追加します。
4. これを `stack` が空になるまで繰り返します。

**今回の例の場合:**

1. `stack = [0]` (Aさんからスタート)
2. Aさんから伝言開始 (`v=0`)。`visited[0] = True`
   - Aさんと関係があるのはBさんとCさん(`graph[0] = [1, 2]`)
   - Bさん、Cさんはまだ伝言済みではないので、`stack` に追加 -> `stack = [1, 2]`
3. `stack` から Bさんを取り出す(`v=1`)。`visited[1] = True`
   - Bさんと関係があるのはAさんとDさん(`graph[1] = [0, 3]`)
   - Aさんは既に伝言済み(`visited[0] == True`)
   - Dさんはまだ伝言済みではないので、`stack` に追加 -> `stack = [2, 3]`
4. `stack` から Cさんを取り出す(`v=2`)。`visited[2] = True`
   - Cさんと関係があるのはAさんだけ(`graph[2] = [0]`)
   - Aさんは既に伝言済み(`visited[0] == True`)
5. `stack` から Dさんを取り出す(`v=3`)。`visited[3] = True`
   - Dさんと関係があるのはBさんだけ(`graph[3] = [1]`)
   - Bさんは既に伝言済み(`visited[1] == True`)
6. `stack` が空になったので終了。`visited` を確認 -> `[True, True, True, True, False]`
7. Eさんには伝言できていないので、`all(visited)` は **`False`** を返す

**3. 結果発表！( `main` 関数 )**

```python
def main():
    N, M = map(int, input().split()) # 人数と関係の数を入力
    edges = [tuple(map(int, input().split())) for _ in range(M)] # 関係を入力
    if is_connected(N, edges):
        print("The graph is connected.")  # 全員に伝言できたら
    else:
        print("The graph is not connected.") # 伝言できない人がいたら
```

- `N, M`:  部員の人数と、関係の数を入力
- `edges`:  M個の関係を `(1, 2)` のように入力

`is_connected(N, edges)` で全員に伝言できるか判定し、結果に応じてメッセージを出力します。

今回の例では、Eさんに伝言できなかったため、"The graph is not connected." となります。

## まとめ

このように、このコードでは部活メンバーの関係をグラフ構造で表現し、深さ優先探索 (DFS) を用いて全員に伝言が伝わるかを判定しています。

部活の例以外にも、友達関係やコンピュータネットワークなど、様々な場面に応用できます。ぜひ、色々試してみてください！

<br>
<br>

---

# 047

## [参考] 2 部グラフ

https://www.momoyama-usagi.com/entry/math-risan09#i-8

はい、このコードを詳細に解説いたします。初心者の方にも理解しやすいように、段階的に説明していきます。

## 1. 全体の構造

このプログラムは主に 3 つの部分から構成されています：

1. `is_bipartite_graph` 関数：グラフが二部グラフかどうかを判定する主要な関数
2. `bfs` 関数：幅優先探索（BFS）を行う関数（`is_bipartite_graph`の中で定義）
3. `main` 関数：入力を受け取り、結果を出力する関数

## 2. グラフの表現

```python
graph = [[] for _ in range(N+1)]
for A, B in edges:
    graph[A].append(B)
    graph[B].append(A)
```

ここでは、グラフを隣接リストとして表現しています。

- `graph`は長さ`N+1`のリストで、各要素は空のリストです。
- インデックス 0 は使用せず、1 から N までの頂点番号に対応させています。
- 各辺`(A, B)`に対して、A のリストに B を、B のリストに A を追加しています。

例えば、N=4 で辺が(1,2), (2,3), (3,4)の場合：

```python
graph = [[], [2], [1,3], [2,4], [3]]
```

## 3. 色の管理

```python
color = [0] * len(graph)
```

各頂点の色を管理するリストです。

- 0: 未訪問
- 1: 色 1（例：赤）
- -1: 色 2（例：青）

## 4. 幅優先探索（BFS）

```python
def bfs(start):
    queue = deque([start])
    color[start] = 1
    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if color[neighbor] == 0:
                color[neighbor] = -color[node]
                queue.append(neighbor)
            elif color[neighbor] == color[node]:
                return False
    return True
```

この関数が二部グラフの判定の核心部分です。

1. 開始頂点を色 1 で塗り、キューに追加します。
2. キューから頂点を取り出し、その隣接頂点を調べます。
3. 隣接頂点が未訪問なら、現在の頂点と反対の色で塗り、キューに追加します。
4. 隣接頂点が既に同じ色で塗られていたら、二部グラフではないので False を返します。
5. すべての頂点を処理できたら、True を返します。

## 5. 全体の探索

```python
for i in range(1, N+1):
    if color[i] == 0:
        if not bfs(i):
            return 'No'
return 'Yes'
```

グラフが複数の連結成分に分かれている可能性があるため、すべての頂点をチェックします。

## 6. 具体例

N=4, 辺=(1,2), (2,3), (3,4)の場合：

1. 頂点 1 から開始：
   - 1 を赤(1)で塗る
   - 2 を青(-1)で塗る
2. 頂点 2 の隣接点をチェック：
   - 3 を赤(1)で塗る
3. 頂点 3 の隣接点をチェック：
   - 4 を青(-1)で塗る

結果：すべての隣接頂点が異なる色になるので、これは二部グラフです。

一方、N=3, 辺=(1,2), (2,3), (3,1)の場合：

1. 頂点 1 から開始：
   - 1 を赤(1)で塗る
   - 2 を青(-1)で塗る
2. 頂点 2 の隣接点をチェック：
   - 3 を赤(1)で塗る
3. 頂点 3 の隣接点をチェック：
   - 1 が既に赤で塗られているため、矛盾が発生

結果：これは二部グラフではありません。

このように、このプログラムは効率的にグラフを探索し、二部グラフかどうかを判定します。

## [参考] グラフの視覚化

### N=4, 辺=(1,2), (2,3), (3,4)の場合：

このグラフは直線状のパスグラフになります。

```
1 --- 2 --- 3 --- 4
```

このグラフは二部グラフです。頂点を以下のように 2 つのグループに分けることができます：

- グループ 1: 1, 3
- グループ 2: 2, 4

### N=3, 辺=(1,2), (2,3), (3,1)の場合：

このグラフは 3 つの頂点が互いに接続された三角形（サイクル）になります。

```
    1
   / \
  /   \
 3 --- 2
```

このグラフは二部グラフではありません。3 つの頂点が互いに接続されているため、2 つのグループに分けることができません。

これらの例は、二部グラフの性質を理解するのに役立ちます：

1. パスグラフ（N=4 の例）は常に二部グラフです。隣接する頂点を交互に異なるグループに割り当てることができます。

2. 奇数の長さを持つサイクル（N=3 の例）は二部グラフではありません。すべての頂点が互いに接続されているため、2 つのグループに分けることができません。

これらの視覚的な表現は、グラフの構造と二部グラフの概念を理解するのに役立ちます。

---

# 048

了解しました。コード全体の目的と、個別の処理がどのように全体のロジックに組み込まれているかを、初心者にも分かりやすく説明します。具体的な事例も使って、処理の流れをステップバイステップで示します。

### コード全体の目的

このコードの目的は、整数 `K` の倍数の中で、各桁の和が最小になる値を見つけることです。つまり、数 `K` の倍数として最も桁の和が小さい数を求めます。

### 全体の流れ

1. **状態の初期化**:

   - 各余りについて、その余りに到達するための最小桁の和を記録します。

2. **幅優先探索（BFS）**:

   - キューを使って、余りごとに最小桁の和を更新していきます。
   - 現在の数から次の数を生成し、その余りを使って探索を続けます。

3. **結果の取得**:
   - 最終的に余りが `0` となる位置、つまり `K` の倍数に到達するための最小桁の和を返します。

### 詳細な説明

#### 1. 状態の初期化

```python
dist = [10**9] * K
dist[1] = 1
```

- **目的**: 各余りに対して、最小の桁の和を記録します。
- **全体の流れ**:
  - 初めて探索する余り（位置）は `1` です。これに対して最小桁の和を `1` に設定します。つまり、数 `1` の桁の和は `1` です。
  - 他の余りの最小桁の和はまだわからないため、大きな値（`10**9`）で初期化します。

#### 2. 幅優先探索（BFS）

```python
q = deque()
q.append(1)
```

- **目的**: BFS を使って、最小桁の和を効率的に探索します。
- **全体の流れ**:
  - キューに `1` を追加し、ここから探索を始めます。
  - キューが空になるまで、次の数を生成していきます。

##### 生成する次の数とその余り

```python
u = (pos + 1) % K
v = 10 * pos % K
```

- **目的**: 現在の位置から次の位置を計算します。
- **全体の流れ**:
  - **`u`**: 現在の数 `pos` に `1` を追加した新しい数の余りです。数の末尾に `1` を追加する操作です。
  - **`v`**: 現在の数 `pos` に `0` を追加して 10 倍した新しい数の余りです。数の末尾に `0` を追加する操作です。

#### 3. `u` への移動と `v` への移動

```python
if dist[u] > dist[pos] + 1:
    dist[u] = dist[pos] + 1
    q.append(u)

if dist[v] > dist[pos]:
    dist[v] = dist[pos]
    q.append(v)
```

- **目的**: 次に生成した数 `u` や `v` への移動が可能であれば、それをキューに追加し、最小桁の和を更新します。
- **全体の流れ**:
  - **`u` への移動**:
    - `dist[u]` が `dist[pos] + 1` より大きい場合、`u` に到達するための桁の和が更新できるので、`dist[u]` を更新し、`u` をキューに追加します。
    - これは、現在の位置 `pos` に `1` を追加した数の桁の和を計算するためです。
  - **`v` への移動**:
    - `dist[v]` が `dist[pos]` より大きい場合、`v` に到達するための桁の和が更新できるので、`dist[v]` を更新し、`v` をキューに追加します。
    - これは、現在の位置 `pos` に `0` を追加して 10 倍した数の桁の和を計算するためです。

#### 4. 結果の取得

```python
return dist[0]
```

- **目的**: 余りが `0` となる位置、つまり `K` の倍数に到達するための最小桁の和を返します。
- **全体の流れ**:
  - BFS を使って、すべての位置の最小桁の和が計算されます。
  - 最後に、`dist[0]` が `0` の余りに到達するための最小桁の和を示しているので、これを返します。

### 事例を使ったステップバイステップの説明

#### 例 1: K = 6

1. **初期状態**:

   - `dist` = `[10**9, 1, 10**9, 10**9, 10**9, 10**9]`
   - キュー `q` = `[1]`

2. **BFS 探索**:

   - `1` を取り出して、`2` と `10` を生成します。
   - **位置 `2`**:
     - `dist[2]` が `2` に更新され、キューに追加されます。
   - **位置 `10`**:
     - 余り `10 % 6 = 4` となり、`dist[4]` が更新され、キューに追加されます。

3. **次のステップ**:
   - 位置 `2` からさらに数を生成し、余り `0` に到達する数を見つけます。
   - 最終的に、数 `12`（`6 * 2`）が `K` の倍数として最小桁の和 `3` になります。

#### 例 2: K = 41

1. **初期状態**:

   - `dist` = `[10**9] * 41`
   - キュー `q` = `[1]`

2. **BFS 探索**:
   - `1` から数 `11`, `111`, `1111` などを生成し、余り `0` に到達するための最小桁の和を更新します。
   - 最終的に、数 `11111`（`41 * 271`）が最小桁の和 `5` になります。

このように、BFS を用いて `K` の倍数を効率的に探索し、各位置に到達するための最小桁の和を見つけることで、問題の解決を図っています。

---

# 049

この Python コードは、与えられた整数 N に対して、フィボナッチ数列の第 N 項を計算し、それを 10^9+7 で割った余りを返すプログラムです。

**コード全体の流れ**

1. `fib(n)` 関数の定義： フィボナッチ数列の第 n 項を計算する関数です。
2. `main()` 関数の定義： ユーザーからの入力を受け取り、結果を出力するメインの処理部分です。
3. `if __name__ == "__main__":`: このスクリプトが直接実行された場合にのみ `main()` 関数を呼び出すための記述です。

**各部分の詳細解説**

**1. `fib(n)` 関数**

```python
def fib(n):
    MOD = 10**9+7
    a, b = 0, 1
    for _ in range(n):
        a, b = b, (a+b) % MOD
    return a
```

- `MOD = 10**9+7`: これは 10 の 9 乗+7 を表す定数で、計算結果をこの数で割った余りを求めるために使われます。
- `a, b = 0, 1`: フィボナッチ数列の初期値を設定しています。 `a` は最初の項(0 番目)を、`b` は 2 番目の項(1 番目)を表します。
- `for _ in range(n)`: このループは `n` 回繰り返されます。 `_` はループカウンタ変数を使用しない場合の慣例的な記法です。
- `a, b = b, (a+b) % MOD`:
  - この行がフィボナッチ数列の計算の核心部分です。まず `(a+b) % MOD` で、現在の `a` と `b` の和を計算し、 `MOD` で割った余りを求めます。
  - 次に、 `a` には `b` の値を、 `b` には計算した余りを代入することで、次のフィボナッチ数へと更新しています。
- `return a`: ループ終了後、最終的に計算された `a` の値（フィボナッチ数列の第 n 項）を返します。

**事例： n=5 の場合の `fib(n)` 関数の処理の流れ**

1. 初期状態: `a = 0`, `b = 1`
2. 1 回目ループ:
   - `(a + b) % MOD = (0 + 1) % 1000000007 = 1`
   - `a` に `b`(1) が代入され、 `b` に 1 が代入されます。 (`a = 1`, `b = 1`)
3. 2 回目ループ:
   - `(a + b) % MOD = (1 + 1) % 1000000007 = 2`
   - `a = 1`, `b = 2`
4. 3 回目ループ:
   - `(a + b) % MOD = (1 + 2) % 1000000007 = 3`
   - `a = 2`, `b = 3`
5. 4 回目ループ:
   - `(a + b) % MOD = (2 + 3) % 1000000007 = 5`
   - `a = 3`, `b = 5`
6. 5 回目ループ:
   - `(a + b) % MOD = (3 + 5) % 1000000007 = 8`
   - `a = 5`, `b = 8`
7. ループ終了: `a = 5` を返す

**2. `main()` 関数**

```python
def main():
    N = int(input())
    print(fib(N))
```

- `N = int(input())`: ユーザーからの入力を数値として受け取ります。
- `print(fib(N))`: `fib(N)` を呼び出して計算結果を取得し、それを画面に出力します。

**3. `if __name__ == "__main__":`**

```python
if __name__ == "__main__":
    main()
```

この部分は、このスクリプトが直接実行された場合にのみ `main()` 関数を呼び出すことを意味します。 別のスクリプトからこのスクリプトをモジュールとしてインポートする場合には、 `main()` 関数は実行されません。

**処理の流れのまとめ**

1. ユーザーからの入力を `N` として受け取る。
2. `fib(N)` 関数を呼び出し、フィボナッチ数列の第 N 項を計算する。
3. 計算結果を画面に出力する。

このコードは、フィボナッチ数列の計算を効率的に行い、大きな数の剰余計算にも対応できるようになっています。

---

# 050

**コード全体像**

このコードは、任意の整数 `a` の `b` 乗を計算し、その結果を `10**9+7` で割った余りを返すプログラムです。

**コードの解説**

```python
def pow(a, b):  # a の b 乗を計算する関数 pow を定義
    MOD = 10**9+7  # 余りを計算するための定数 MOD を定義
    res = 1  # 結果を格納する変数 res を 1 で初期化
    while b > 0:  # b が 0 より大きい間ループ処理を続ける
        if b % 2 == 1:  # もし b が奇数なら
            res = (res * a) % MOD  # res に a を掛けて MOD で割った余りを代入
        a = (a * a) % MOD  # a を2乗して MOD で割った余りを a に再代入
        b //= 2  # b を 2 で整数除算して b に再代入
    return res  # ループが終了したら res の値を返す

def main():  # メイン処理を行う関数 main を定義
    a, b = map(int, input().split())  # 標準入力から整数 a と b を受け取る
    print(pow(a, b))  # pow(a, b) の結果を標準出力に出力

if __name__ == "__main__":  # このスクリプトが直接実行された場合のみ main() を実行する
    main()
```

**各部の詳細解説**

1. **`pow(a, b)` 関数**

   - 引数として整数 `a` と `b` を受け取ります。
   - `MOD` を `10**9+7` で定義し、結果をこの値で割った余りを計算します。
   - `res = 1` で、結果を格納する変数 `res` を初期化しています。
   - `while b > 0:` のループ内で、繰り返し二乗法を用いて計算を行います。
     - `if b % 2 == 1:`： もし `b` が奇数の場合、`res` に `a` を掛けて `MOD` で割った余りを代入します。これは、奇数乗の場合は `a` が一つ余分に必要になるためです。
     - `a = (a * a) % MOD`： `a` を 2 乗し、`MOD` で割った余りを `a` に再代入することで、常に `a` の値を小さく保ちます。
     - `b //= 2`： `b` を 2 で整数除算し、次のループのために `b` を半分にします。

2. **`main()` 関数**

   - `a, b = map(int, input().split())`： 標準入力から空白区切りで入力された値を、整数型に変換して `a` と `b` に代入します。
   - `print(pow(a, b))`： `pow(a, b)` 関数を実行し、その結果を標準出力に出力します。

3. **`if __name__ == "__main__":`**
   - この部分は、このスクリプトが他のプログラムからインポートされたのではなく、直接実行された場合にのみ `main()` 関数を実行するためのものです。

**動作例**

もし入力が `5 23` であれば、このプログラムは `5` の `23` 乗を計算し、`10**9+7` で割った余りである `871631629` を出力します。

**まとめ**

このプログラムは、繰り返し二乗法と剰余演算を組み合わせることで、大きな数のべき乗を効率的に計算し、オーバーフローを防ぐ方法を示しています。 `main()` 関数と `if __name__ == "__main__":` の部分は、プログラムの実行を制御し、再利用性を高めるための一般的な Python の記述です。

## [補足] pow 関数

`pow` 関数を使わない累乗計算の仕組みを、具体例を交えながら詳しく解説していきます。

**目標： 大きな数でも計算可能な、a の b 乗を MOD で割った余りを求める**

今回のコードは、「繰り返し二乗法」と「剰余演算」というテクニックを組み合わせて、効率的に計算を実現しています。

**1. 繰り返し二乗法： 指数を半分ずつ減らしながら計算**

例えば、11 の 7 乗を計算したいとします。これを素直に計算すると `11 * 11 * 11 * 11 * 11 * 11 * 11` となりますが、乗算の回数が多くて大変です。

そこで、繰り返し二乗法を使って計算を効率化します。

- **7 は奇数なので、11 を一つ分けておく:** 11 _ (11 _ 11 _ 11 _ 11 _ 11 _ 11)
- **括弧内は 11 の 6 乗 (偶数乗) なので、(11 \* 11) の 3 乗に分解:** 11 _ (11 _ 11) _ (11 _ 11) _ (11 _ 11)

このように、指数を半分ずつ減らしながら計算していくことで、乗算の回数を減らすことができます。

**2. 剰余演算： 大きな数を扱うためのテクニック**

大きな数の計算では、計算結果がコンピュータで扱える数値の範囲を超えてしまうことがあります (オーバーフロー)。そこで、剰余演算を使って計算結果を常に一定の範囲内に収めるようにします。

例えば、1000000007 (10^9 + 7) で割った余りを考えます。

- 123456789 を 1000000007 で割った余りは 123456789 です。
- 123456789 \* 2 = 246913578 を 1000000007 で割った余りは 246913578 です。
- 123456789 \* 123456789 は非常に大きな数になりますが、1000000007 で割った余りは、各段階で余りを取ることと同じ結果になります。

**コードの解説**

```python
result = 1  # 結果を格納する変数 (初期値は1)

while b > 0:  # b が 0 になるまでループ (指数を減らしていく)
    if b % 2 == 1:  # b が奇数の時 (指数が奇数の時)
        result = (result * a) % MOD  # result に a をかけて MOD で割った余りを代入
    a = (a * a) % MOD  # a を 2 乗して MOD で割った余りを代入
    b //= 2  # b を半分にする
```

**具体例： a = 3, b = 5, MOD = 7 の場合**

1. 初期状態: `result = 1, a = 3, b = 5, MOD = 7`
2. `b (5)` は奇数なので、`result = (1 * 3) % 7 = 3` となり、`a = (3 * 3) % 7 = 2`, `b = 5 // 2 = 2` となります。
3. `b (2)` は偶数なので、`result = 3` のまま、`a = (2 * 2) % 7 = 4`, `b = 2 // 2 = 1` となります。
4. `b (1)` は奇数なので、`result = (3 * 4) % 7 = 5` となり、`a = (4 * 4) % 7 = 2`, `b = 1 // 2 = 0` となります。
5. `b (0)` は 0 なのでループを抜けます。

最終的に `result = 5` となり、これは `3**5` を `7` で割った余りと等しくなります。

このように、繰り返し二乗法と剰余演算を組み合わせることで、大きな数のべき乗を効率的に計算し、オーバーフローを防ぐことができます。
