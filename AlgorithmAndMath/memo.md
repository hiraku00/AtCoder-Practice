# アルゴリズムと数学 演習問題集

https://atcoder.jp/contests/math-and-algorithm

---
# 009

```
def bf2(S, A):
    dp = [1] + [0] * S
    for i in A:
        print(f'----------------------------------------------------- i : {i}')
        print(range(S - i, -1, -1))
        for j in range(S - i, -1, -1):
            print(f'------------------------------------------ j : {j}')
            print(f'dp[{j}] : {dp[j]}')
            if dp[j] == 1:
                dp[j + i] = 1
                print(f'dp[{j}] == 1 => {dp[j] == 1}')
                print(f'dp[{j} + {i}] = 1')
            print(dp)
    print(f'========')
    print(dp)
    print("Yes" if dp[-1] == 1 else "No")

N, S = map(int, input().split())
A = list(map(int, input().split()))
bf2(S, A)
```

dp[i]は、「i」という合計値を作ることができるかどうかを表しています。<br>
1なら作れる、0なら作れないという意味です。

```
if dp[i]:
    dp[i + n] = 1
```

この部分は、「もしiという合計値が作れるなら、iにnを足した数も作れる」という意味になります。<br>
なぜなら、iが作れて、その上にnを足すことができるからです。

具体的な例で説明しますね。<br>
カードが[1, 2, 4]の3枚だけで、その合計がちょうど7になる組み合わせがあるかどうかを探すとします。

最初に、0から目標の数（この場合は7）までの各数値が作れるかどうかを記録するためのリスト（dp）を作ります。<br>
最初は全て「作れない（=0）」としておきますが、0だけは何も選ばないことで作れるので、「作れる（=1）」とします。

```
dp = [1, 0, 0, 0, 0, 0, 0, 0]
```

次に、各カードについて考えます。

最初のカードは1です。<br>
これを使って作れる数値は1と0（何も選ばない）です。<br>
したがって、dp[1]を「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 0, 0, 0, 0, 0, 0]
```

次に2が書かれたカードを考えます。<br>
このカードを使って作れる数値は2と0（何も選ばない）です。<br>
また、1が作れることがわかっているので、1+2=3も作れます。<br>
したがって、dp[2]とdp[3]を「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 1, 1, 0, 0, 0, 0]
```

最後に4が書かれたカードを考えます。<br>
このカードを使って作れる数値は4と0（何も選ばない）です。<br>
また、1から3までの全ての数が作れることがわかっているので、これらの数に4を足した5から7までの全ての数も作れます。<br>
したがって、dp[4]からdp[7]までを「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 1, 1, 1, 1, 1, 1]
```

以上の手順で、目標の数7が作れることがわかりました。<br>
したがって、「Yes」と出力します。

このように動的計画法では、
小さな問題（小さい数が作れるかどうか）から順に解いていき、最終的に大きな問題（目標の数が作れるかどうか）を解くことができます。<br>
この手法はプログラミングだけでなく、様々な問題解決に応用することができますよ。

---
# 011

`primes_up_to(n)` 関数は、エラトステネスの篩というアルゴリズムを用いて、**与えられた整数 `n` 以下の全ての素数を効率的に探し出す**関数です。

**コードのステップ:**

1. **`primes = [True] * (n + 1)`**:
   - 長さ `n+1` のリスト `primes` を作成し、全ての要素を `True` で初期化します。
   - インデックスは 0 から `n` までとなり、各インデックスは対応する数値を表します (例: インデックス 2 は数値 2 を表す)。
   - このリストは、各数値が素数かどうかを記録するために使用されます。初期では全て `True` なので、最初は全て素数の候補として扱われます。

2. **`primes[0] = primes[1] = False`**:
   - 0 と 1 は素数ではないので、対応するインデックスの値を `False` に設定します。

3. **`p = 2`**:
   - 変数 `p` を 2 で初期化します。`p` は現在確認している素数を表します。

4. **`while p * p <= n`**:
   - `p * p` が `n` 以下である間、ループを繰り返します。
   - この条件は、エラトステネスの篩の効率的な探索範囲を表しています。 `p` より大きい `p` の倍数は、既に `p` の倍数としてマークされているため、`p * p` より大きい数を調べる必要はありません。

5. **`if primes[p]`**:
   - もし `primes[p]` が `True` ならば、`p` はまだ素数としてマークされています。

6. **`for i in range(p * p, n + 1, p)`**:
   - `p * p`: `p` より小さい `p` の倍数は、既に前のステップで除外されているため、`p * p` から開始します。
   - `n + 1`: `n` 以下の素数を求めることが目的なので、`n` を含めるために `n + 1` を終了値としています。
   - `p`: `p` の倍数を除外するために、`p` ずつ増加させていきます。

        **例:**
        <br>
        もし `p = 2`、`n = 10` の場合:
        - `range(p * p, n + 1, p)` は `range(4, 11, 2)` となり、`4, 6, 8, 10` という数列を生成します。
        - つまり、このループは `i` に 4, 6, 8, 10 を順番に代入して、`primes[i] = False` を実行することで、2 の倍数を素数候補から除外します。

7. **`p += 1`**:
   - 次の素数候補に移動します。

8. **`return [i for i in range(n + 1) if primes[i]]`**:
   - `primes` リストの中で `True` となっているインデックスを全て集めて、リストとして返します。 これらのインデックスが `n` 以下の素数を表しています。

**例:**

`n = 10` の場合、`primes` リストは以下のように変化していきます。

- 初期状態: `[False, False, True, True, True, True, True, True, True, True, True]`
- `p = 2` の処理後: `[False, False, True, True, False, True, False, True, False, True, False]`
- `p = 3` の処理後: `[False, False, True, True, False, True, False, True, False, False, False]`
- 最終的に、`True` となっているインデックス `2, 3, 5, 7` が `n` 以下の素数として返されます。

**まとめ:**

`primes_up_to(n)` 関数は、エラトステネスの篩という効率的なアルゴリズムを用いることで、`n` 以下の全ての素数を高速に計算することができます。


---
# 012

```
def isPrime(n):
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0 or n % 3 == 0: return False
    i = 5
    while i * i <= n:
        # n % (i + 2)`は、与えられた数nが次の素数候補(現在の数iから2足した数)で割り切れるかどうかをチェック
        # => i = 5,  i+2 = 7
        # => i = 11, i+2 = 13
        if n % i == 0 or n % (i+2) == 0:
            return False
        i += 6
    return True

N = int(input())
print("Yes" if isPrime(N) else "No")
```

## 素数判定アルゴリズムにおける `i += 6` の解説

**なぜ `i += 6` で6ずつ増やしていくのか**

この素数判定アルゴリズムは、非常に効率的な手法の一つです。特に、`i += 6` という部分がこのアルゴリズムの肝となっています。

**理由を詳しく見ていきましょう:**

1. **偶数と3の倍数を除外:**
   - `if n % 2 == 0 or n % 3 == 0: return False` の部分で、既に2と3の倍数は除外されています。
   - 素数は、2と3を除いて、6n+1 または 6n-1 の形で表すことができます。つまり、全ての素数は6の倍数±1の形をしているということです。

2. **6n+1 と 6n-1 のパターンをカバー:**
   - `i += 6` とすることで、`i` は常に 6n+1 または 6n-1 の形になります。
   - 初期値の `i = 5` は 6n-1 にあたり、`i + 2` は 6n+1 に当たります。
   - このようにして、全ての素数の候補を漏れなくチェックできるのです。

3. **効率化:**
   - 2と3の倍数を事前に除外することで、除算の回数を大幅に減らせます。
   - 6ずつ増やすことで、4や5で割るといった無駄な計算を省いています。

**まとめ:**

`i += 6` とすることで、素数の特性を利用し、効率的に素数判定を行うことができるのです。このアルゴリズムは、素数の分布に関する深い理解に基づいた、洗練された手法と言えるでしょう。

**補足:**

- **なぜ平方根までで十分か:**
  - ある数 `n` を割り切る数が `a` とすると、`n = a * b` と表すことができます。
  - `a` が `√n` より大きい場合、`b` は `√n` より小さくなります。つまり、`√n` までの数で割り切れるか調べれば、`√n` より大きい数で割り切れるかどうかも自動的に分かるということです。

---
# 013

## `for i in range(1, int(n**0.5) + 1):` の解説

このコードの一行は、**約数を求める処理において、なぜ `n` の平方根までをループすれば十分なのか** を理解する上で非常に重要な部分です。

### 1. 平方根の役割
* **対称性:** ある数 `n` の約数 `a` と `b` が存在するとき、`a * b = n` が成り立ちます。
* **平方根:** `n` の平方根を `sqrt(n)` とすると、`sqrt(n) * sqrt(n) = n` となります。
* **対称性の利用:** 上記の2点から、`a <= sqrt(n)` ならば、`b >= sqrt(n)` となります。つまり、`sqrt(n)` より小さい約数 `a` を見つければ、対応する約数 `b` は `sqrt(n)` より大きくなります。

### 2. ループ範囲の理由
* `1` から `sqrt(n)` までをループすることで、`sqrt(n)` より小さい全ての約数 `a` を見つけることができます。
* 上記の対称性より、`sqrt(n)` より大きい約数 `b` は、すでに `a` として見つかっているか、`a * a = n` の場合に `a` と一致します。
* よって、`sqrt(n)` までをループすれば、全ての約数を見つけることができるのです。

### 3. `int(n**0.5) + 1` の理由
* `n**0.5` は `n` の平方根を計算します。
* `int()` で整数部分を取り出すことで、ループの範囲を整数に限定します。
* `+ 1` をしているのは、`sqrt(n)` 自身が約数になる場合を考慮するためです。例えば、`n=4` の場合、`sqrt(n)=2` は約数となります。

### まとめ
このコードのループ範囲は、約数の対称性を利用し、計算量を削減するために設定されています。`sqrt(n)` までをループすることで、全ての約数を漏れなく、かつ重複なく見つけることができるのです。

**この範囲を超えてループしても、新しい約数は見つかりません。**

### 例
```
n = 36
sqrt(n) = 6
```

この場合、1 から 6 までをループすれば、全ての約数 (1, 2, 3, 4, 6, 9, 12, 18, 36) を見つけることができます。



## `divisors = set()` の解説

### `set()` とは？

Python の `set()` は、**重複する要素を含まない**、順序の保証されないコレクション（集合）を表すデータ型です。

### `divisors = set()` の意味

このコードでは、変数 `divisors` に空の集合を代入しています。つまり、**約数を格納するための空の箱**を用意しているようなものです。

**なぜ集合を使うのか？**

* **重複の排除:** 約数として同じ数が複数回出てくる可能性がありますが、集合は重複を自動的に排除してくれるため、重複した約数を格納してしまうことを防ぎます。
* **高速な検索:** 集合は、要素が含まれているかどうかの判定が非常に高速です。そのため、すでに求めた約数が重複しているかを確認する際に、集合を使うと効率的です。

### コード全体における役割

約数を求める処理の中で、`divisors` に見つけた約数を順次追加していきます。集合の性質のおかげで、重複する約数を追加しようとしても無視され、最終的に `divisors` には、その数の全ての約数が重複なしに格納されます。

**例:**

```python
n = 12
divisors = set()
for i in range(1, int(n**0.5) + 1):
    if n % i == 0:
        divisors.add(i)
        divisors.add(n // i)

print(divisors)  # 出力: {1, 2, 3, 4, 6, 12}
```

このコードでは、`divisors` に12の約数が順次追加されていき、最終的に12の全ての約数が集合として格納されます。

### まとめ

`divisors = set()` は、約数を求める問題において、重複を排除し、高速な処理を実現するために非常に有効な手法です。集合の性質を理解することで、より効率的なプログラムを作成することができます。

**何か他に聞きたいことがあれば、お気軽にご質問ください。**

* 集合の他の特徴について知りたい
* より具体的な例を見たい
* 別のデータ構造との比較

など、どんな質問でも構いません。
