# アルゴリズムと数学 演習問題集

https://atcoder.jp/contests/math-and-algorithm

---
# 009

```
def bf2(S, A):
    dp = [1] + [0] * S
    for i in A:
        print(f'----------------------------------------------------- i : {i}')
        print(range(S - i, -1, -1))
        for j in range(S - i, -1, -1):
            print(f'------------------------------------------ j : {j}')
            print(f'dp[{j}] : {dp[j]}')
            if dp[j] == 1:
                dp[j + i] = 1
                print(f'dp[{j}] == 1 => {dp[j] == 1}')
                print(f'dp[{j} + {i}] = 1')
            print(dp)
    print(f'========')
    print(dp)
    print("Yes" if dp[-1] == 1 else "No")

N, S = map(int, input().split())
A = list(map(int, input().split()))
bf2(S, A)
```

dp[i]は、「i」という合計値を作ることができるかどうかを表しています。<br>
1なら作れる、0なら作れないという意味です。

```
if dp[i]:
    dp[i + n] = 1
```

この部分は、「もしiという合計値が作れるなら、iにnを足した数も作れる」という意味になります。<br>
なぜなら、iが作れて、その上にnを足すことができるからです。

具体的な例で説明しますね。<br>
カードが[1, 2, 4]の3枚だけで、その合計がちょうど7になる組み合わせがあるかどうかを探すとします。

最初に、0から目標の数（この場合は7）までの各数値が作れるかどうかを記録するためのリスト（dp）を作ります。<br>
最初は全て「作れない（=0）」としておきますが、0だけは何も選ばないことで作れるので、「作れる（=1）」とします。

```
dp = [1, 0, 0, 0, 0, 0, 0, 0]
```

次に、各カードについて考えます。

最初のカードは1です。<br>
これを使って作れる数値は1と0（何も選ばない）です。<br>
したがって、dp[1]を「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 0, 0, 0, 0, 0, 0]
```

次に2が書かれたカードを考えます。<br>
このカードを使って作れる数値は2と0（何も選ばない）です。<br>
また、1が作れることがわかっているので、1+2=3も作れます。<br>
したがって、dp[2]とdp[3]を「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 1, 1, 0, 0, 0, 0]
```

最後に4が書かれたカードを考えます。<br>
このカードを使って作れる数値は4と0（何も選ばない）です。<br>
また、1から3までの全ての数が作れることがわかっているので、これらの数に4を足した5から7までの全ての数も作れます。<br>
したがって、dp[4]からdp[7]までを「作れる（=1）」に更新します。<br>

```
dp = [1, 1, 1, 1, 1, 1, 1, 1]
```

以上の手順で、目標の数7が作れることがわかりました。<br>
したがって、「Yes」と出力します。

このように動的計画法では、
小さな問題（小さい数が作れるかどうか）から順に解いていき、最終的に大きな問題（目標の数が作れるかどうか）を解くことができます。<br>
この手法はプログラミングだけでなく、様々な問題解決に応用することができますよ。

---
# 011

`primes_up_to(n)` 関数は、エラトステネスの篩というアルゴリズムを用いて、**与えられた整数 `n` 以下の全ての素数を効率的に探し出す**関数です。

**コードのステップ:**

1. **`primes = [True] * (n + 1)`**:
   - 長さ `n+1` のリスト `primes` を作成し、全ての要素を `True` で初期化します。
   - インデックスは 0 から `n` までとなり、各インデックスは対応する数値を表します (例: インデックス 2 は数値 2 を表す)。
   - このリストは、各数値が素数かどうかを記録するために使用されます。初期では全て `True` なので、最初は全て素数の候補として扱われます。

2. **`primes[0] = primes[1] = False`**:
   - 0 と 1 は素数ではないので、対応するインデックスの値を `False` に設定します。

3. **`p = 2`**:
   - 変数 `p` を 2 で初期化します。`p` は現在確認している素数を表します。

4. **`while p * p <= n`**:
   - `p * p` が `n` 以下である間、ループを繰り返します。
   - この条件は、エラトステネスの篩の効率的な探索範囲を表しています。 `p` より大きい `p` の倍数は、既に `p` の倍数としてマークされているため、`p * p` より大きい数を調べる必要はありません。

5. **`if primes[p]`**:
   - もし `primes[p]` が `True` ならば、`p` はまだ素数としてマークされています。

6. **`for i in range(p * p, n + 1, p)`**:
   - `p * p`: `p` より小さい `p` の倍数は、既に前のステップで除外されているため、`p * p` から開始します。
   - `n + 1`: `n` 以下の素数を求めることが目的なので、`n` を含めるために `n + 1` を終了値としています。
   - `p`: `p` の倍数を除外するために、`p` ずつ増加させていきます。

        **例:**
        <br>
        もし `p = 2`、`n = 10` の場合:
        - `range(p * p, n + 1, p)` は `range(4, 11, 2)` となり、`4, 6, 8, 10` という数列を生成します。
        - つまり、このループは `i` に 4, 6, 8, 10 を順番に代入して、`primes[i] = False` を実行することで、2 の倍数を素数候補から除外します。

7. **`p += 1`**:
   - 次の素数候補に移動します。

8. **`return [i for i in range(n + 1) if primes[i]]`**:
   - `primes` リストの中で `True` となっているインデックスを全て集めて、リストとして返します。 これらのインデックスが `n` 以下の素数を表しています。

**例:**

`n = 10` の場合、`primes` リストは以下のように変化していきます。

- 初期状態: `[False, False, True, True, True, True, True, True, True, True, True]`
- `p = 2` の処理後: `[False, False, True, True, False, True, False, True, False, True, False]`
- `p = 3` の処理後: `[False, False, True, True, False, True, False, True, False, False, False]`
- 最終的に、`True` となっているインデックス `2, 3, 5, 7` が `n` 以下の素数として返されます。

**まとめ:**

`primes_up_to(n)` 関数は、エラトステネスの篩という効率的なアルゴリズムを用いることで、`n` 以下の全ての素数を高速に計算することができます。


---
# 012

```
def isPrime(n):
    if n < 2: return False
    if n == 2 or n == 3: return True
    if n % 2 == 0 or n % 3 == 0: return False
    i = 5
    while i * i <= n:
        # n % (i + 2)`は、与えられた数nが次の素数候補(現在の数iから2足した数)で割り切れるかどうかをチェック
        # => i = 5,  i+2 = 7
        # => i = 11, i+2 = 13
        if n % i == 0 or n % (i+2) == 0:
            return False
        i += 6
    return True

N = int(input())
print("Yes" if isPrime(N) else "No")
```

## 素数判定アルゴリズムにおける `i += 6` の解説

**なぜ `i += 6` で6ずつ増やしていくのか**

この素数判定アルゴリズムは、非常に効率的な手法の一つです。特に、`i += 6` という部分がこのアルゴリズムの肝となっています。

**理由を詳しく見ていきましょう:**

1. **偶数と3の倍数を除外:**
   - `if n % 2 == 0 or n % 3 == 0: return False` の部分で、既に2と3の倍数は除外されています。
   - 素数は、2と3を除いて、6n+1 または 6n-1 の形で表すことができます。つまり、全ての素数は6の倍数±1の形をしているということです。

2. **6n+1 と 6n-1 のパターンをカバー:**
   - `i += 6` とすることで、`i` は常に 6n+1 または 6n-1 の形になります。
   - 初期値の `i = 5` は 6n-1 にあたり、`i + 2` は 6n+1 に当たります。
   - このようにして、全ての素数の候補を漏れなくチェックできるのです。

3. **効率化:**
   - 2と3の倍数を事前に除外することで、除算の回数を大幅に減らせます。
   - 6ずつ増やすことで、4や5で割るといった無駄な計算を省いています。

**まとめ:**

`i += 6` とすることで、素数の特性を利用し、効率的に素数判定を行うことができるのです。このアルゴリズムは、素数の分布に関する深い理解に基づいた、洗練された手法と言えるでしょう。

**補足:**

- **なぜ平方根までで十分か:**
  - ある数 `n` を割り切る数が `a` とすると、`n = a * b` と表すことができます。
  - `a` が `√n` より大きい場合、`b` は `√n` より小さくなります。つまり、`√n` までの数で割り切れるか調べれば、`√n` より大きい数で割り切れるかどうかも自動的に分かるということです。

---
# 013

## `for i in range(1, int(n**0.5) + 1):` の解説

このコードの一行は、**約数を求める処理において、なぜ `n` の平方根までをループすれば十分なのか** を理解する上で非常に重要な部分です。

### 1. 平方根の役割
* **対称性:** ある数 `n` の約数 `a` と `b` が存在するとき、`a * b = n` が成り立ちます。
* **平方根:** `n` の平方根を `sqrt(n)` とすると、`sqrt(n) * sqrt(n) = n` となります。
* **対称性の利用:** 上記の2点から、`a <= sqrt(n)` ならば、`b >= sqrt(n)` となります。つまり、`sqrt(n)` より小さい約数 `a` を見つければ、対応する約数 `b` は `sqrt(n)` より大きくなります。

### 2. ループ範囲の理由
* `1` から `sqrt(n)` までをループすることで、`sqrt(n)` より小さい全ての約数 `a` を見つけることができます。
* 上記の対称性より、`sqrt(n)` より大きい約数 `b` は、すでに `a` として見つかっているか、`a * a = n` の場合に `a` と一致します。
* よって、`sqrt(n)` までをループすれば、全ての約数を見つけることができるのです。

### 3. `int(n**0.5) + 1` の理由
* `n**0.5` は `n` の平方根を計算します。
* `int()` で整数部分を取り出すことで、ループの範囲を整数に限定します。
* `+ 1` をしているのは、`sqrt(n)` 自身が約数になる場合を考慮するためです。例えば、`n=4` の場合、`sqrt(n)=2` は約数となります。

### まとめ
このコードのループ範囲は、約数の対称性を利用し、計算量を削減するために設定されています。`sqrt(n)` までをループすることで、全ての約数を漏れなく、かつ重複なく見つけることができるのです。

**この範囲を超えてループしても、新しい約数は見つかりません。**

### 例
```
n = 36
sqrt(n) = 6
```

この場合、1 から 6 までをループすれば、全ての約数 (1, 2, 3, 4, 6, 9, 12, 18, 36) を見つけることができます。



## `divisors = set()` の解説

### `set()` とは？

Python の `set()` は、**重複する要素を含まない**、順序の保証されないコレクション（集合）を表すデータ型です。

### `divisors = set()` の意味

このコードでは、変数 `divisors` に空の集合を代入しています。つまり、**約数を格納するための空の箱**を用意しているようなものです。

**なぜ集合を使うのか？**

* **重複の排除:** 約数として同じ数が複数回出てくる可能性がありますが、集合は重複を自動的に排除してくれるため、重複した約数を格納してしまうことを防ぎます。
* **高速な検索:** 集合は、要素が含まれているかどうかの判定が非常に高速です。そのため、すでに求めた約数が重複しているかを確認する際に、集合を使うと効率的です。

### コード全体における役割

約数を求める処理の中で、`divisors` に見つけた約数を順次追加していきます。集合の性質のおかげで、重複する約数を追加しようとしても無視され、最終的に `divisors` には、その数の全ての約数が重複なしに格納されます。

**例:**

```python
n = 12
divisors = set()
for i in range(1, int(n**0.5) + 1):
    if n % i == 0:
        divisors.add(i)
        divisors.add(n // i)

print(divisors)  # 出力: {1, 2, 3, 4, 6, 12}
```

このコードでは、`divisors` に12の約数が順次追加されていき、最終的に12の全ての約数が集合として格納されます。

### まとめ

`divisors = set()` は、約数を求める問題において、重複を排除し、高速な処理を実現するために非常に有効な手法です。集合の性質を理解することで、より効率的なプログラムを作成することができます。

**何か他に聞きたいことがあれば、お気軽にご質問ください。**

* 集合の他の特徴について知りたい
* より具体的な例を見たい
* 別のデータ構造との比較

など、どんな質問でも構いません。

---
# 014

## 素因数分解プログラムの解説

このPythonコードは、与えられた自然数Nを素因数分解し、その素因数を小さい順にリストで返すプログラムです。

### コードの各部分の解説

* **`def prime_factorization(n):`**
  - `prime_factorization`という名前の関数を作成します。この関数は、素因数分解したい自然数`n`を引数として受け取ります。

* **`factors = []`**
  - 素因数を格納するための空のリスト`factors`を作成します。

* **`for i in range(2, int(n**0.5)+1):`**
  - `i`を2から√nまで1ずつ増やしながらループを繰り返します。
  - √nまで調べれば十分なのは、もしnが合成数であれば、必ず√n以下の約数を持つからです。

* **`while n % i == 0:`**
  - `n`が`i`で割り切れる限り、以下の処理を繰り返します。

* **`factors.append(i)`**
  - `i`を素因数のリスト`factors`に追加します。

* **`n //= i`**
  - `n`を`i`で割り、その商を新しい`n`とします。これにより、次のループで`i`で割り切れるかどうかを再度確認できます。

* **`if n > 1:`**
  - ループが終わった後、`n`が1より大きい場合は、`n`自身が素数なので、`factors`に追加します。

* **`return factors`**
  - 素因数のリスト`factors`を返します。

* **`N = int(input())`**
  - ユーザーから自然数Nを入力し、整数型に変換して変数Nに代入します。

* **`print(*prime_factorization(N))`**
  - `prime_factorization(N)`で得られた素因数のリストを、`*`を使って展開し、空白区切りで出力します。

### プログラム全体の流れ

1. ユーザーが素数分解したい自然数Nを入力します。
2. `prime_factorization`関数が呼び出され、Nが素因数分解されます。
3. 2から√Nまでの整数で順にNを割り、割り切れる場合はその数を素因数としてリストに追加し、Nをその数で割ります。
4. すべての素因数が求められるまで、上記の処理を繰り返します。
5. 求められた素因数のリストが出力されます。

### 例

Nが10の場合、以下のようになります。

1. 2から√10までの整数で順に10を割っていくと、2で割り切れます。
2. 10を2で割って5になり、5は素数なので、素因数は2と5となります。
3. 最終的に、2と5が空白区切りで出力されます。

### まとめ

このプログラムは、**試し割り法**と呼ばれるアルゴリズムを用いて、与えられた自然数を素因数分解しています。シンプルなアルゴリズムですが、小さな数に対しては十分な効率で動作します。

**ポイント:**
* **√nまで調べれば十分:** 合成数であれば、必ず√n以下の約数を持つため、√nまで調べればすべての素因数がわかります。
* **whileループ:** 同じ素因数が複数ある場合、繰り返し割り算することで、すべての素因数を数えることができます。

**注意点:**
* **非常に大きな数:** 非常に大きな数に対しては、計算時間がかかることがあります。
* **より効率的なアルゴリズム:** エラトステネスの篩など、より効率的な素因数分解のアルゴリズムも存在します。

このプログラムを理解することで、素因数分解の仕組みや、アルゴリズムの考え方についてより深く理解できるでしょう。


## 素因数分解の例：36の場合

### コードの動作を詳しく見てみましょう

```python
def prime_factorization(n):
    factors = []
    for i in range(2, int(n**0.5)+1):
        while n % i == 0:
            factors.append(i)
            n //= i
    if n > 1:
        factors.append(n)
    return factors

N = 36
print(*prime_factorization(N))
```

このコードに`N=36`を代入して実行すると、以下のような処理が行われます。

#### 1. 関数`prime_factorization(36)`が呼び出される
* `factors`という空のリストが作成されます。このリストに素因数が順に格納されていきます。
* `i`は2から始まり、√36（つまり6）まで1ずつ増えていきます。

#### 2. ループの1回目（i=2）
* 36は2で割り切れるので、2が`factors`に追加され、36は2で割って18になります。
* 18も2で割り切れるので、再び2が`factors`に追加され、18は2で割って9になります。
* 9は2で割り切れないので、次の`i`に進みます。

#### 3. ループの2回目（i=3）
* 9は3で割り切れるので、3が`factors`に追加され、9は3で割って3になります。
* 3も3で割り切れるので、再び3が`factors`に追加され、3は3で割って1になります。

#### 4. ループ終了
* `n`が1になったので、ループは終了します。

#### 5. 残りの処理
* `n`が1より大きい場合は、`n`自身を素因数として`factors`に追加しますが、今回は`n`が1なので、この処理は行われません。

#### 6. 結果の出力
* `factors`には、[2, 2, 3, 3]が格納されているので、これが出力されます。

### まとめ
つまり、このコードを実行すると、36の素因数分解の結果として、`2 2 3 3`と表示されます。これは、36が2×2×3×3と素因数分解できることを意味しています。

**より具体的に書くと、以下のようになります。**

* 36 ÷ 2 = 18
* 18 ÷ 2 = 9
* 9 ÷ 3 = 3
* 3 ÷ 3 = 1

したがって、36 = 2 × 2 × 3 × 3 となり、素因数は2と3がそれぞれ2つずつであることがわかります。

**視覚的に表すと**

```
36
↓ ÷ 2
18
↓ ÷ 2
9
↓ ÷ 3
3
↓ ÷ 3
1
```

となります。

**このプログラムの利点は、**
* 与えられた任意の自然数の素因数分解を自動で行える
* 計算過程を簡潔に表現できる
* 繰り返し処理を用いて効率的に計算できる
といった点が挙げられます。


---
# 017

## ユークリッドの互除法で最小公倍数が求められる理由

ユークリッドの互除法は、一見最大公約数を求めるためのアルゴリズムですが、なぜ最小公倍数の計算にも使えるのでしょうか？その理由を詳しく解説します。

### 最大公約数と最小公倍数の関係

**最大公約数 (GCD)** と **最小公倍数 (LCM)** の間には、以下の関係が成り立ちます。

* **2つの自然数 a, b の積** = **a, b の最大公約数** × **a, b の最小公倍数**

つまり、
```
a × b = GCD(a, b) × LCM(a, b)
```
が成り立ちます。

### ユークリッドの互除法と最小公倍数の関係

ユークリッドの互除法を用いて、2つの数の最大公約数 GCD(a, b) を求めることができます。上記の式を変形すると、
```
LCM(a, b) = (a × b) / GCD(a, b)
```
となります。

つまり、**2つの数の積を、ユークリッドの互除法で求めた最大公約数で割る**ことで、最小公倍数が求められるのです。

### なぜこの関係が成り立つのか？

この関係が成り立つ直感的な理由としては、以下のことが挙げられます。

* **最大公約数:** 2つの数に共通する約数のうち、最大のものです。
* **最小公倍数:** 2つの数を両方割り切ることができる最小の自然数です。

最大公約数は、2つの数に共通する部分を表し、最小公倍数は、2つの数を包含する部分を表します。この2つの概念は、ある意味で逆の関係にあります。

**具体例:**
2つの数12と18を例に考えてみましょう。
* 12 = 2^2 × 3
* 18 = 2 × 3^2

* 最大公約数: 2 × 3 = 6
* 最小公倍数: 2^2 × 3^2 = 36

12と18の積は、2^3 × 3^3 です。この積を最大公約数6で割ると、最小公倍数36が得られます。

### まとめ

ユークリッドの互除法で最大公約数を求めることで、最小公倍数も計算できるのは、最大公約数と最小公倍数の間の深い関係があるからです。この関係式は、数論において非常に重要な概念であり、様々な問題を解く際に役立ちます。

**ポイント:**
* ユークリッドの互除法は、最大公約数だけでなく、最小公倍数の計算にも応用できる。
* 最大公約数と最小公倍数は、ある意味で逆の関係にある。
* 2つの数の積を最大公約数で割ると、最小公倍数が得られる。

この説明で、ユークリッドの互除法と最小公倍数の関係が理解できたでしょうか？もし、さらに詳しく知りたいことがあれば、お気軽にご質問ください。

---
# 019

```
c = [A.count(c) for c in ('123')]:
```

- リスト内包表記を使って、文字列 A に含まれる '1', '2', '3' のそれぞれの出現回数を数え、その結果を c というリストに格納します。
- 例えば、A が "12132" の場合、c は [2, 1, 1] になります。
- これは、文字 '1' が2回、'2' が1回、'3' が1回出現することを意味します。


```
c_1 = c[0] * (c[0]-1) // 2
c_2 = c[1] * (c[1]-1) // 2
c_3 = c[2] * (c[2]-1) // 2
```

- c の各要素（つまり、各色のカードの枚数）を使って、同じ色のカードを2枚選ぶ組み合わせの数を計算します。
- n * (n-1) // 2 という式は、n個の中から2つを選ぶ組み合わせの数（nCr）を求める公式です。
- c_1, c_2, c_3 はそれぞれ、色 '1', '2', '3' のカードの組み合わせの数になります。


---
# 020

### コードの全体像

このコードは、**動的計画法**を使って、**与えられたカードの数字の組み合わせから、合計が1000になるような5枚のカードの組み合わせの数**を計算しています。

### コードの各部分の解説

#### 1. `dp = [[0]*1001 for _ in range(6)]`
* **dpテーブルの初期化:** この行で、動的計画法で使う表（dpテーブル）を作っています。
* `dp[i][j]`は、i枚のカードを使って合計jを作れる組み合わせの数という意味になります。
* この問題では、最大で5枚のカードを使うので、6行、そして合計が最大1000なので、1001列の表を作っています。すべての要素を最初は0で初期化しています。

#### 2. `for card in A:`
* **カードのループ:** 与えられたカードのリストAの要素（つまり、各カードの数字）を一つずつ取り出して処理します。

#### 3. `for num in range(1000, -1, -1):`
* **合計のループ:** 目標の合計を1000から0まで、1ずつ減らしながら処理します。

#### 4. `for card_cnt in range(5, 0, -1):`
* **カード枚数のループ:** 使用するカードの枚数を5枚から1枚まで、1枚ずつ減らしながら処理します。

#### 5. `if num >= card:`
* **カードの数字との比較:** 目標の合計が、現在のカードの数字以上かどうかを判断します。
* 目標の合計がカードの数字より小さい場合、そのカードを使うことはできないので、次のループに進みます。

#### 6. `dp[card_cnt][num] += dp[card_cnt - 1][num - card]`
* **dpテーブルの更新:**
  * `dp[card_cnt - 1][num - card]`は、1枚少ないカードで、現在の合計からカードの数字を引いた合計を作る組み合わせの数です。
  * `dp[card_cnt][num]`は、現在のカードの枚数で、現在の合計を作る組み合わせの数です。
  * この2つの数を足し合わせることで、現在のカードを使って、現在の合計を作る組み合わせの総数が求められます。

#### 7. `return dp[5][1000]`
* **答えの出力:** 最終的に、5枚のカードを使って合計1000を作る組み合わせの数、つまり`dp[5][1000]`の値を返します。

### 具体的な計算例

例えば、カードの数字が[100, 200, 300, 400, 500]の場合、`dp[2][300]`の値を求めることを考えてみましょう。
* これは、「2枚のカードを使って、合計300を作る組み合わせの数」を表します。
* この場合、100円と200円の2枚を使う方法が考えられます。
* これは、`dp[1][200]`（1枚のカードで200を作る組み合わせ）と、`dp[1][100]`（1枚のカードで100を作る組み合わせ）を足し合わせたものになります。

### まとめ

このコードは、**動的計画法**というアルゴリズムを使って、**部分問題の解を組み合わせて、大きな問題の解を求める**という考え方で、カードの組み合わせ問題を解いています。
* dpテーブルに、一度計算した結果を保存しておくことで、同じ計算を繰り返すのを防ぎ、効率的に答えを求めることができます。
* カードの組み合わせ問題だけでなく、様々な問題にこの考え方を応用することができます。

**もう少し詳しく知りたいことや、別の問題で試してみたい場合は、お気軽に質問してくださいね！**

**例えば、以下の質問に答えてみましょう。**
* 「なぜdpテーブルの計算式がこうなるのか？」
* 「もっと簡単な問題で教えてほしい」
* 「このコードを少し変えて、別の問題を解くことはできるの？」

**ぜひ、あなたの疑問を解決できるように、一緒に考えていきましょう！**

**補足:**
* このコードでは、カードの数字が重複しないことを前提としています。
* カードの枚数や目標の合計を変更することで、様々な問題に対応できます。

**より具体的な例を提示して頂ければ、より詳細な説明をすることができます。**

---
# 021

## コードの説明

### `comb` 関数
この関数は、組み合わせの数 (nCr) を計算します。

**引数:**
* `n`: 全体の要素数
* `r`: 選ぶ要素の数

**処理:**
1. **`r = min(r, n - r)`:** 組み合わせの性質を利用して計算量を削減します。nCr = nC(n-r) なので、r が n/2 より大きい場合は、n-r を r として計算します。
2. **`res = 1`:** 結果を格納する変数を初期化します。
3. **`for` ループ:**
   * `i` が 0 から `r-1` まで繰り返します。
   * `res *= n - i`: 分子の計算 (n * (n-1) * ... * (n-r+1))
   * `res //= i + 1`: 分母の計算 (r! = 1 * 2 * ... * r) で、整数除算を使用するため効率的です。
4. **`return res`:** 計算結果を返します。

### `main` 関数
この関数は、メイン処理を行います。

1. **入力:** 標準入力から `n` と `r` を読み込み、整数に変換してリストに格納します。
2. **計算:** `comb` 関数を使って組み合わせの数を計算します。
3. **出力:** 計算結果を出力します。

### 全体的な流れ
1. `main` 関数が実行されます。
2. 標準入力から `n` と `r` を読み込みます。
3. `comb` 関数が呼ばれ、組み合わせの数が計算されます。
4. 計算結果が出力されます。

### コードの特徴
* 効率的な計算: 組み合わせの性質を利用して計算量を削減し、整数除算を使用することで効率化しています。
* 簡潔なコード: 必要な処理のみを記述し、可読性を保っています。

このコードは、組み合わせの数を計算する一般的なアルゴリズムを実装しており、効率的で読みやすいコードとなっています。


---
# 022


```python
def pair(A):
    D = [0]*100000  # インデックスがカードの値、値が出現回数
    res = 0  # 和が100000になるペアの数
    for a in A:
        res += D[a]  # 現在のカードaとペアになるカードの出現回数を足す
        D[-a] += 1  # 100000 - 現在のカード の出現回数を+1する
    return res
```

**解説:**

このコードは、リスト `D` を巧妙に使い、和が100000になるペアの数を効率的に数えています。

**リスト `D` の役割:**

- `D` は、インデックスがカードの値 (0 ~ 99999)、値がそのカードの出現回数 を表すリストです。
  - 例えば、`D[50000] = 3` なら、カードの値 `50000` が3枚出現したことを意味します。

**コードの解説:**

1. **初期化:**
   - `D = [0]*100000`: 全ての要素が0のリスト `D` を作成します。最初はどのカードも出現していない状態です。
   - `res = 0`: 和が100000になるペアの数を0で初期化します。

2. **カードを順に処理 (for ループ):**
   - `for a in A:`: カードのリスト `A` から、カードを1枚ずつ取り出して `a` に代入します。

     - **`res += D[a]`**:
       - ここで、**現在のカード `a` とペアになるカード** を探します。
       - ペアになるカードの値は `100000 - a` です。
       - `D[a]` は、**既に登場したカードの中で、値が `100000 - a` であるカードの枚数**を表します。
       - つまり、`D[a]` は **現在のカード `a` とペアになるカードが、これまで何枚出現したか** を表しているので、`res` に加算します。

     - **`D[-a] += 1`**:
       - **将来、`-a` とペアになるカードのために、`-a` の出現回数を記録します。**
       - 例えば、 `a = 20000` の場合、 `-a = -20000` となり、これは `D` の範囲外です。
       - しかし、`100000 + (-20000) = 80000` となり、これは `D` の有効なインデックスです。
       - つまり、`D[-a] += 1` は、**将来的に `100000 - a` の値を持つカードが出現した際に、`a` とペアになるカードが1枚増える**ことを記録しているのです。

3. **結果を返す:**
   - `return res`: すべてのカードを調べ終わったら、和が100000になるペアの数 `res` を返します。

**例:**

```
A = [40000, 50000, 20000, 80000, 50000, 30000]
```

このリストを処理する過程を以下に示します。

|  a  |  res  | D[a] | D[-a] | 説明                                              |
|-----|-------|------|-------|---------------------------------------------------|
| 40000 | 0     | 0    | D[60000]+=1 | まだペアは無い。D[60000]に1加算。            |
| 50000 | 0     | 0    | D[50000]+=1 | まだペアは無い。D[50000]に1加算。            |
| 20000 | 0     | 0    | D[80000]+=1 | まだペアは無い。D[80000]に1加算。            |
| 80000 | 1     | 1    | D[20000]+=1 | 20000とペアになる。resに1加算、D[20000]に1加算。 |
| 50000 | 2     | 1    | D[50000]+=1 | 50000とペアになる。resに1加算、D[50000]に1加算。 |
| 30000 | 2     | 0    | D[70000]+=1 | まだペアは無い。D[70000]に1加算。            |

最終的に、`res = 2` となり、和が100000になるペアが2つあることがわかります。


---
# 026


```python
def calc(n):
    res = 0
    for i in range(1, n+1):
        res += n/i
        print(res)
    return res

def main():
    N = int(input())
    print(calc(N))

if __name__ == "__main__":
    main()
```

例として、N = 5 の場合を考えてみます：

```python
def calc(n):
    res = 0
    for i in range(n, 0, -1):
        res += n/i
    return res
```

N=5の場合、以下のように計算が進みます：

1. i = 5 のとき（最初のコイン）：
   res += 5/5 = 1
   説明：最初のコインを得る確率は5/5 = 1（100%）です。期待コストは1ドルです。

2. i = 4 のとき（2番目のコイン）：
   res += 5/4 = 1.25
   説明：2番目の新しいコインを得る確率は4/5です。期待コストは5/4 = 1.25ドルです。
   （平均して1/(4/5) = 5/4回の試行が必要）

3. i = 3 のとき（3番目のコイン）：
   res += 5/3 ≈ 1.67
   説明：3番目の新しいコインを得る確率は3/5です。期待コストは5/3 ≈ 1.67ドルです。
   （平均して1/(3/5) = 5/3回の試行が必要）

4. i = 2 のとき（4番目のコイン）：
   res += 5/2 = 2.5
   説明：4番目の新しいコインを得る確率は2/5です。期待コストは5/2 = 2.5ドルです。
   （平均して1/(2/5) = 5/2回の試行が必要）

5. i = 1 のとき（最後のコイン）：
   res += 5/1 = 5
   説明：最後のコインを得る確率は1/5です。期待コストは5/1 = 5ドルです。
   （平均して1/(1/5) = 5回の試行が必要）

最終的な res ≈ 11.42

この説明方法では、各ステップで新しいコインを得る確率が徐々に減少し、それに伴って期待コストが増加していく様子がよりわかりやすくなります。最初は簡単に新しいコインを得られますが、残りのコインが少なくなるにつれて、特定の新しいコインを得るのが難しくなっていきます。

この合計約11.42ドルが、5種類全てのコインを集めるのに必要な総期待コストとなります。実際の試行では運によって変動しますが、長期的に見ればこの平均値に収束します。


---
# 027

### マージソートの基本的な考え方:
1. 大きな問題を小さな問題に分割する
2. 小さな問題を解決する
3. 小さな問題の解決結果を組み合わせて、大きな問題の解決につなげる

### 具体的な手順:
1. 配列を半分に分ける
2. 分けた半分をさらに半分に分ける（要素が1つになるまで繰り返す）
3. 1つの要素になったら、それらをペアにしてマージ（結合）しながら並べ替える
4. マージを繰り返して、最終的に全体がソートされた1つの配列になる

### 実装の説明:

1. merge_sort 関数:
   ```python
   def merge_sort(arr):
       if len(arr) <= 1:
           return arr

       mid = len(arr) // 2
       left = merge_sort(arr[:mid])
       right = merge_sort(arr[mid:])

       return merge(left, right)
   ```
   - この関数は配列を受け取り、再帰的に処理します。
   - もし配列の長さが1以下なら、そのまま返します（これ以上分割できないため）。
   - 配列を真ん中で2つに分けます。
   - 左半分と右半分それぞれに対して merge_sort を呼び出します（再帰）。
   - 最後に、ソートされた左半分と右半分をマージします。

2. merge 関数:
   ```python
   def merge(left, right):
       res = []
       i, j = 0, 0

       while i < len(left) and j < len(right):
           if left[i] <= right[j]:
               res.append(left[i])
               i += 1
           else:
               res.append(right[j])
               j += 1

       res.extend(left[i:])
       res.extend(right[j:])

       return res
   ```
   - この関数は2つのソート済み配列を受け取り、1つのソート済み配列にマージします。
   - 2つの配列の先頭から順に比較していきます。
   - 小さい方の要素を結果の配列に追加していきます。
   - どちらかの配列を最後まで見たら、残りの要素をそのまま追加します。

### 具体例:

この部分はマージソートの核心部分で、2つのソート済み配列を1つのソート済み配列にマージする処理です。具体的な例を使って説明しましょう。

例えば、以下の2つのソート済み配列があるとします：

left = [1, 3, 5, 7]
right = [2, 4, 6, 8]

これらをマージして [1, 2, 3, 4, 5, 6, 7, 8] という1つのソート済み配列を作ります。

1. while ループの部分:
    ```python
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            res.append(left[i])
            i += 1
        else:
            res.append(right[j])
            j += 1
   ```

    このループは、left と right の両方の配列に要素が残っている間、以下の処理を繰り返します：

    - left[i] と right[j] を比較します。
    - 小さい方（または等しい場合は left の要素）を res に追加します。
    - 追加した方の配列のインデックス（i または j）を1つ進めます。

    例を step by step で見てみましょう：

    - 初期状態: res = [], i = 0, j = 0
    - Step 1: 1 < 2 なので、res = [1], i = 1, j = 0
    - Step 2: 3 > 2 なので、res = [1, 2], i = 1, j = 1
    - Step 3: 3 < 4 なので、res = [1, 2, 3], i = 2, j = 1
    - Step 4: 5 > 4 なので、res = [1, 2, 3, 4], i = 2, j = 2
    - 以降も同様に続きます...

2. 残りの要素の追加:
    ```python
      res.extend(left[i:])
      res.extend(right[j:])
    ```

    while ループが終わった後、どちらかの配列に要素が残っている可能性があります。
    これらの行は、残っている要素をすべて res の末尾に追加します。

    例えば、上記の例で while ループが終わった後の状態は：
    res = [1, 2, 3, 4, 5, 6], i = 3, j = 3

    となっています。left と right にはそれぞれ [7] と [8] が残っているので、
    これらの行によって res は最終的に [1, 2, 3, 4, 5, 6, 7, 8] となります。

<br>
  この方法により、2つのソート済み配列を1回のスキャンで効率的に1つのソート済み配列にマージすることができます。各要素を一度だけ見るため、このマージ操作の時間計算量は O(n) となります（n は2つの配列の要素数の合計）。
  これを再帰的に適用することで、元の大きな配列全体をソートすることができるのです。

### このアルゴリズムの特徴:
- 分割統治法を使用しています（大きな問題を小さな問題に分割して解決）。
- 安定ソートです（同じ値の要素の順序が保たれる）。
- 時間計算量は O(N log N) で、効率的なソートアルゴリズムの1つです。

このように、複雑な問題を小さな部分に分けて解決し、その結果を組み合わせることで、効率的にソートを行うことができます。




---
# 028

```python
def min_cost(N, h):
    dp = [0] * N
    dp[1] = abs(h[0] - h[1])
    for i in range(2, N):
        cost1 = dp[i-1] + abs(h[i] - h[i-1])
        cost2 = dp[i-2] + abs(h[i] - h[i-2])
        dp[i] = min(cost1, cost2)
    return dp[-1]

def main():
    N = int(input())
    h = list(map(int, input().split()))
    print(min_cost(N, h))

if __name__ == "__main__":
    main()
```

このコードの説明：

1. `min_cost` 関数:
   - 引数: `N`（足場の数）と `h`（各足場の高さのリスト）
   - `dp` リストを作成: 各足場までの最小コストを保存
   - 初期化:
     - `dp[0] = 0`（最初の足場のコストは0）
     - `dp[1] = abs(h[0] - h[1])`（2番目の足場へのコスト）
   - 3番目の足場から順に計算:
     - `cost1`: 1つ前の足場から来る場合のコスト
     - `cost2`: 2つ前の足場から来る場合のコスト
     - 小さい方のコストを選択
   - 最後の足場（`dp[-1]`）のコストを返す

このアプローチの特徴：

- メモリ使用: O(N) - `dp` リストを使用
- 時間計算量: O(N) - 各足場を一度ずつ計算
- 可読性: 高い - 動的計画法の流れが分かりやすい
- 柔軟性: 高い - 例えば3つ先の足場へのジャンプを追加するなど、拡張が容易

このコードは、元の問題設定に対して効率的かつ理解しやすい解決策を提供しています。メモリ使用と実行速度のバランスが取れており、中規模から大規模の入力（N ≤ 10^5）に対しても十分に対応できます。


---
# 030

## ナップサック問題のPythonコード解説

### コード全体の説明

このコードは、**ナップサック問題**と呼ばれる、与えられた複数の品物の中から、ナップサックの容量を超えない範囲で、価値の総和を最大にする組み合わせを選ぶ問題を解くためのPythonプログラムです。

**動的計画法**と呼ばれるアルゴリズムを用いて、効率的に解いています。

### 各部分の解説

#### `knapsack`関数
* **引数:**
    * `N`: 品物の数
    * `W`: ナップサックの容量
    * `items`: 各品物の重さと価値のタプルのリスト
* **処理:**
    * `dp`リスト: 長さが`W+1`のリストを作成し、`dp[i]`に容量`i`のナップサックに入れられる品物の価値の最大値を格納します。
    * 重複ループ:
        * 外側のループ: 各品物`w, v`について処理します。
        * 内側のループ: 容量`j`について、品物`w`を入れる場合と入れない場合で、価値の大きい方を`dp[j]`に更新します。
            * `dp[j-w] + v`: 品物`w`を入れる場合の価値
            * `dp[j]`: 品物`w`を入れない場合の価値
    * `return dp[W]`: 最終的に、容量`W`のナップサックに入れられる品物の価値の最大値を返します。

#### `main`関数
* **入力:**
    * `N`, `W`: 品物の数とナップサックの容量を入力
    * `items`: 各品物の重さと価値を入力し、タプルのリストに格納
* **処理:**
    * `knapsack`関数を呼び出し、結果を出力

**ポイント:**
* **動的計画法:** 一度求めた部分問題の解を保存しておき、後から再利用することで、計算量を削減する手法です。
* **DPテーブル:** `dp`リストは、動的計画法で計算結果を保存するための表（テーブル）のような役割を果たします。
* **状態遷移:** 内側のループで、現在の状態（容量`j`）から、一つ前の状態（容量`j-w`）への遷移を考え、価値を更新しています。


**具体例**
- バッグの耐久重量(W) = 8
- 品物(N) = 3個
  1. 重さ3, 価値30
  2. 重さ4, 価値50
  3. 重さ5, 価値60

1. `knapsack` 関数:
   - `dp`リストを作ります。これは「重さjのバッグで得られる最大価値」を記録します。
   - 初期状態: `dp = [0, 0, 0, 0, 0, 0, 0, 0, 0]` (インデックス0から8まで)

2. 品物を1つずつ確認していきます:

   品物1 (重さ3, 価値30):
   - 重さ8から3まで逆順に確認
   - `dp[8] = max(0, 0+30) = 30`
   - `dp[7] = max(0, 0+30) = 30`
   - `dp[6] = max(0, 0+30) = 30`
   - `dp[5] = max(0, 0+30) = 30`
   - `dp[4] = max(0, 0+30) = 30`
   - `dp[3] = max(0, 0+30) = 30`
   - 結果: `dp = [0, 0, 0, 30, 30, 30, 30, 30, 30]`

   品物2 (重さ4, 価値50):
   - `dp[8] = max(30, 30+50) = 80`
   - `dp[7] = max(30, 30+50) = 80`
   - `dp[6] = max(30, 0+50) = 50`
   - `dp[5] = max(30, 0+50) = 50`
   - `dp[4] = max(30, 0+50) = 50`
   - 結果: `dp = [0, 0, 0, 30, 50, 50, 50, 80, 80]`

   品物3 (重さ5, 価値60):
   - `dp[8] = max(80, 30+60) = 90`
   - `dp[7] = max(80, 0+60) = 80`
   - `dp[6] = max(50, 0+60) = 60`
   - `dp[5] = max(50, 0+60) = 60`
   - 結果: `dp = [0, 0, 0, 30, 50, 60, 60, 80, 90]`

3. 最終的に `dp[8] = 90` が答えになります。これは、重さ8のバッグで得られる最大価値が90であることを意味します。

`main` 関数は入力を受け取り、`knapsack` 関数を呼び出して結果を出力します。

このアルゴリズムの特徴は、各品物について一度だけ処理を行い、かつメモリ使用量を最小限に抑えている点です。これにより、効率的に問題を解決できます。


---
# 031

### コード全体の流れ
このプログラムは、太郎君が夏休み中に勉強をして得られる最大の実力値を計算します。太郎君は2日連続で勉強しないという制約があるため、各日の実力値を考慮しつつ最大値を求める必要があります。

### コードの説明

まずは、具体例として入力例を考えます。

#### 例:
- 日数 `N = 5`
- 各日の実力値 `A = [2, 5, 3, 3, 1]`

### 関数 `dp(N, A)` の説明

```python
def dp(N, A):
    dp = [0] * (N+1)
    dp[1] = A[0]
    for i in range(2, N+1):
        dp[i] = max(dp[i-1], dp[i-2] + A[i-1])
    return dp[-1]
```

#### ステップ 1: 初期化

1. **`dp = [0] * (N+1)`**:
   - `dp`リストを初期化します。このリストは`N+1`個の要素を持ち、全て0で初期化されています。
   - `dp[i]`は、`i`日目までの間に得られる最大の実力値を保持します。

   例えば、`N = 5`の場合、最初に作られるリストは次のようになります:
   ```python
   dp = [0, 0, 0, 0, 0, 0]
   ```

2. **`dp[1] = A[0]`**:
   - 1日目に勉強した場合の実力値を設定します。`dp[1]`に`A[0]`を代入します。
   - `dp[1] = 2`となります。

   この時点で`dp`リストは次のようになります:
   ```python
   dp = [0, 2, 0, 0, 0, 0]
   ```

#### ステップ 2: 動的計画法による計算

3. **`for i in range(2, N+1):`**:
   - 2日目からN日目までの各日について計算します。

4. **`dp[i] = max(dp[i-1], dp[i-2] + A[i-1])`**:
   - `dp[i-1]`は、`i-1`日目までの最大の実力値を意味します。これは、`i`日目に勉強しない場合の実力値です。
   - `dp[i-2] + A[i-1]`は、`i-2`日目までの最大の実力値に`i`日目の実力値を加えたものです。これは、`i`日目に勉強する場合の実力値です。
   - より大きな値を`dp[i]`に保存します。

   実際の計算を見てみましょう。

   - `i = 2` の場合:
     - `dp[2] = max(dp[1], dp[0] + A[1]) = max(2, 0 + 5) = 5`
     - `dp = [0, 2, 5, 0, 0, 0]`

   - `i = 3` の場合:
     - `dp[3] = max(dp[2], dp[1] + A[2]) = max(5, 2 + 3) = 5`
     - `dp = [0, 2, 5, 5, 0, 0]`

   - `i = 4` の場合:
     - `dp[4] = max(dp[3], dp[2] + A[3]) = max(5, 5 + 3) = 8`
     - `dp = [0, 2, 5, 5, 8, 0]`

   - `i = 5` の場合:
     - `dp[5] = max(dp[4], dp[3] + A[4]) = max(8, 5 + 1) = 8`
     - `dp = [0, 2, 5, 5, 8, 8]`

#### ステップ 3: 最終的な実力値の取得

5. **`return dp[-1]`**:
   - `dp[-1]`（つまり`dp[5]`）を返します。これが太郎君が得られる最大の実力値です。
   - この例では、結果は `8` となります。

### 全体の流れをまとめると:
- 入力として`N`日分の実力値リスト`A`を受け取ります。
- `dp()`関数で動的計画法を用いて、太郎君が2日連続で勉強しないという制約のもとで、得られる最大の実力値を計算します。
- その結果を出力します。今回の例では、答えは`8`となります。


---
# 033

### コードの解説

#### 1. `calc` 関数の定義
```python
def calc(A, B, C):
    ...
```
- この関数は、3つの点 \(A\), \(B\), \(C\) の座標を引数として受け取り、点 \(A\) から線分 \(BC\) までの最短距離を計算します。

#### 2. ベクトルの定義
```python
BA = [A[0] - B[0], A[1] - B[1]]
BC = [C[0] - B[0], C[1] - B[1]]
CA = [A[0] - C[0], A[1] - C[1]]
CB = [B[0] - C[0], B[1] - C[1]]
```
- `BA` は点 \(B\) から点 \(A\) へのベクトルです。
- `BC` は点 \(B\) から点 \(C\) へのベクトルです。
- `CA` は点 \(C\) から点 \(A\) へのベクトルです。
- `CB` は点 \(C\) から点 \(B\) へのベクトルです。

#### 3. 射影を使った最近接点の計算
```python
if np.dot(BA, BC) < 0:
    nearest = B
elif np.dot(CA, CB) < 0:
    nearest = C
else:
    nearest = [B[0] + np.dot(BA, BC) / (BC[0]**2 + BC[1]**2) * BC[0],
               B[1] + np.dot(BA, BC) / (BC[0]**2 + BC[1]**2) * BC[1]]
```
- `np.dot(BA, BC)` はベクトル `BA` と `BC` の内積を計算します。この内積は、点 \(A\) が線分 \(BC\) 上のどの位置に近いかを判定するのに使います。
  - `np.dot(BA, BC) < 0` の場合、点 \(A\) の最近接点は点 \(B\) です。
  - `np.dot(CA, CB) < 0` の場合、点 \(A\) の最近接点は点 \(C\) です。
  - それ以外の場合、点 \(A\) の最近接点は線分 \(BC\) 上にあります。この場合、ベクトルの射影を使って最近接点 `nearest` を計算します。

#### 4. 距離の計算
```python
res = math.sqrt((nearest[0] - A[0])**2 + (nearest[1] - A[1])**2)
return res
```
- `nearest` から点 \(A\) までの距離をユークリッド距離として計算し、結果 `res` を返します。

このコードは、ベクトルの内積や射影を使用して、効率的に最短距離を計算しています。各ステップは数学的に正確で、与えられた条件に従って処理が分岐するため、正確な結果を得ることができます。



## 詳細説明(内積・射影・距離)

### 1. 内積による最近接点の判定

#### 内積の意味
ベクトルの内積（ドット積）には次のような幾何学的な意味があります：

- ベクトル \( $\mathbf{u}$ \) と \( $\mathbf{v}$ \) の内積は、 \( $\mathbf{u}$ \) の長さと \( $\mathbf{v}$ \) の長さ、そしてその2つのベクトルが成す角度 \( $\theta$ \) のコサイン \( $\cos \theta$ \) の積に等しいです：
  \[
  $\mathbf{u} \cdot \mathbf{v} = |\mathbf{u}| |\mathbf{v}| \cos \theta$
  \]

- もし \($\cos \theta$ \) が正であれば、2つのベクトルは鋭角（0度から90度）をなすことを意味します。内積が負の場合、ベクトルは鈍角（90度から180度）をなしています。

#### 内積を使った判定
- ベクトル `BA` と `BC` の内積 `np.dot(BA, BC)` が負の場合、点 \( A \) が点 \( B \) の方向に進むと、線分 \( BC \) から外れてしまう（つまり、鋭角を作らない）ことを示しています。このとき、点 \( A \) から線分 \( BC \) への最近接点は、点 \( B \) になります。

- 同様に、ベクトル `CA` と `CB` の内積 `np.dot(CA, CB)` が負の場合、点 \( A \) が点 \( C \) の方向に進むと線分 \( BC \) から外れてしまうため、この場合は最近接点は \( C \) になります。

#### 線分上に最近接点がある場合
- もしどちらの内積も正であれば、点 \( A \) の最近接点は線分 \( BC \) 上に存在します。この場合、点 \( A \) から線分 \( BC \) までの最短距離は、次の射影を使って計算します。

### 2. 射影による最近接点の計算

射影とは、あるベクトルを他のベクトルに投影する操作です。点 \( A \) から線分 \( BC \) への射影ベクトルを求めることで、線分上の最近接点の位置を計算します。

#### 射影の計算式
ベクトル \( $\mathbf{BA}$ \) をベクトル \( $\mathbf{BC}$ \) に射影するとき、射影ベクトルの計算式は次のようになります：

\[
$\mathbf{P}$ = $\mathbf{B}$ + $\dfrac{\mathbf{BA} \cdot \mathbf{BC}}{|\mathbf{BC}|^2} \times \mathbf{BC}$
\]

- ここで、 \( \frac{$\mathbf{BA}$ \cdot $\mathbf{BC}$}{|$\mathbf{BC}$|^2} \) はスカラー値で、ベクトル \( $\mathbf{BA}$ \) をベクトル \( $\mathbf{BC}$ \) の方向にどれだけ進むかを決定します。
- その結果、点 \( B \) からこのスカラー倍した \( $\mathbf{BC}$ \) を足し合わせたベクトルが、線分 \( BC \) 上の最近接点 \( P \) になります。

コード内では、この計算を次のように実装しています：

```python
nearest = [B[0] + np.dot(BA, BC) / (BC[0]**2 + BC[1]**2) * BC[0],
           B[1] + np.dot(BA, BC) / (BC[0]**2 + BC[1]**2) * BC[1]]
```

- `np.dot(BA, BC)` は \( $\mathbf{BA}$ \cdot $\mathbf{BC}$ \) という内積。
- `BC[0]**2 + BC[1]**2` は \( |$\mathbf{BC}$|^2 \) というベクトル \( $\mathbf{BC}$ \) の長さの二乗。
- これを使って最近接点 `nearest` を計算します。

### 3. 距離の計算

次に、点 \( A \) から最近接点 \( P \) までの距離を計算します。

#### ユークリッド距離
距離を求めるために使うのはユークリッド距離で、2点 \( (x_1, y_1) \) と \( (x_2, y_2) \) の距離は次の式で計算されます：

\[
$d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$
\]

コードでは次の部分に対応しています：

```python
res = math.sqrt((nearest[0] - A[0])**2 + (nearest[1] - A[1])**2)
```

- `nearest[0]` と `A[0]` はそれぞれ点 \( P \) と \( A \) の x 座標です。同様に `nearest[1]` と `A[1]` は y 座標。
- これにより、点 \( A \) から最近接点 \( P \) までの直線距離を計算し、その結果を返します。

このようにして、点 \( A \) から線分 \( BC \) までの最短距離が計算されます。
