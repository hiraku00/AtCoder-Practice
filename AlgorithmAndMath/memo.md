# アルゴリズムと数学 演習問題集

https://atcoder.jp/contests/math-and-algorithm

<br>

---
# 007

### 数学的な説明

まず、N以下の正の整数の中で、Xの倍数またはYの倍数であるものの個数を求める方法について説明します。

1. **Xの倍数の個数**:
   - N以下の正の整数の中でXの倍数の個数は、NをXで割った商です。例えば、N=15, X=3の場合、15以下の3の倍数は3, 6, 9, 12, 15の5個です。これは15 // 3 = 5で求められます。

2. **Yの倍数の個数**:
   - 同様に、N以下の正の整数の中でYの倍数の個数は、NをYで割った商です。例えば、N=15, Y=5の場合、15以下の5の倍数は5, 10, 15の3個です。これは15 // 5 = 3で求められます。

3. **XとYの両方の倍数の個数**:
   - XとYの両方の倍数は、XとYの最小公倍数（LCM）で割り切れる数です。例えば、X=3, Y=5の場合、最小公倍数は15です。N=15の場合、15以下の15の倍数は15の1個です。これは15 // 15 = 1で求められます。

4. **重複を取り除く**:
   - Xの倍数とYの倍数の合計から、XとYの両方の倍数の個数を引くことで、重複を取り除きます。例えば、N=15, X=3, Y=5の場合、Xの倍数は5個、Yの倍数は3個、両方の倍数は1個です。したがって、5 + 3 - 1 = 7個が答えです。

### コード全体の説明

```python
def gcd(x, y):
    while y != 0:
        x, y = y, x % y
    return x

def lcm(x, y):
    return x * y // gcd(x, y)

def count_multiples(N, X, Y):
    cnt_X = N // X
    cnt_Y = N // Y
    lcm_xy = lcm(X, Y)
    cnt_XY = N // lcm_xy
    return cnt_X + cnt_Y - cnt_XY

def main():
    N, X, Y = map(int, input().split())
    print(count_multiples(N, X, Y))

if __name__ == "__main__":
    main()
```

次に、コード全体で何をやっているかを説明します。

1. **最大公約数（GCD）を求める関数**:
   - `gcd(x, y)`は、ユークリッドの互除法を使って2つの数の最大公約数を求めます。

2. **最小公倍数（LCM）を求める関数**:
   - `lcm(x, y)`は、2つの数の積をその最大公約数で割ることで最小公倍数を求めます。

3. **倍数の個数をカウントする関数**:
   - `count_multiples(N, X, Y)`は、N以下の正の整数の中でXの倍数またはYの倍数であるものの個数を計算します。

4. **メイン関数**:
   - `main()`は、標準入力からN, X, Yの3つの整数を読み込み、`count_multiples`関数を使って結果を出力します。

### コードの詳細な説明

それでは、コードの各部分を事例を用いて詳細に説明します。

#### gcd関数
```python
def gcd(x, y):
    while y != 0:
        x, y = y, x % y
    return x
```
この関数は、ユークリッドの互除法を使って2つの数の最大公約数を求めます。例えば、`gcd(12, 15)`の場合、次のように計算します：
- 12 % 15 = 12
- 15 % 12 = 3
- 12 % 3 = 0
- よって、最大公約数は3です。

#### lcm関数
```python
def lcm(x, y):
    return x * y // gcd(x, y)
```
この関数は、2つの数の最小公倍数を求めます。例えば、`lcm(12, 15)`の場合、次のように計算します：
- 12 * 15 = 180
- gcd(12, 15) = 3
- 180 // 3 = 60
- よって、最小公倍数は60です。

#### count_multiples関数
```python
def count_multiples(N, X, Y):
    cnt_X = N // X
    cnt_Y = N // Y
    lcm_xy = lcm(X, Y)
    cnt_XY = N // lcm_xy
    return cnt_X + cnt_Y - cnt_XY
```
この関数は、N以下の正の整数の中でXの倍数またはYの倍数であるものの個数を計算します。例えば、`count_multiples(15, 3, 5)`の場合、次のように計算します：
- `cnt_X = 15 // 3 = 5`（3の倍数の個数）
- `cnt_Y = 15 // 5 = 3`（5の倍数の個数）
- `lcm_xy = lcm(3, 5) = 15`（3と5の最小公倍数）
- `cnt_XY = 15 // 15 = 1`（3と5の両方の倍数の個数）
- 結果: `5 + 3 - 1 = 7`

#### main関数
```python
def main():
    N, X, Y = map(int, input().split())
    print(count_multiples(N, X, Y))
```
この関数は、標準入力からN, X, Yの3つの整数を読み込み、`count_multiples`関数を使って結果を出力します。

### まとめ

このコードは、N以下の正の整数の中で、Xの倍数またはYの倍数であるものの個数を効率的に計算する方法を示しています。数学的な背景とコードの詳細な説明を通じて、初心者でも理解しやすいように説明しました。何か質問があれば教えてくださいね！

<br>
<br>

---
# 008

はい、承知しました。このコードについて、初心者にも分かりやすく、事例を交えながら詳しく説明していきます。



まず、コードの全体構造を見てみましょう：

1. `count_combination` 関数：この関数が主な計算を行います。
2. `main` 関数：入力を受け取り、結果を出力します。
3. `if __name__ == "__main__":` 部分：このスクリプトが直接実行された時に `main` 関数を呼び出します。

それでは、`count_combination` 関数を詳しく見ていきましょう。

```python
def count_combination(N, S):
    cnt = 0
    for red in range(1, N+1):
        max_blue = min(N, S - red)
        if max_blue >= 1:
            cnt += max_blue
        else:
            break
    return cnt
```

この関数の動作を、具体的な例を使って説明します。
例えば、N = 5（カードに書ける最大の数）、S = 7（合計の上限）とします。

1. `cnt = 0` で、組み合わせの数を数えるカウンターを初期化します。

2. `for red in range(1, N+1):` で、赤いカードに書く数を1から5まで順番に試していきます。

3. 各赤いカードの数に対して、`max_blue = min(N, S - red)` で青いカードに書ける最大の数を計算します。
   - 例えば、赤いカードが2の場合、S - red = 7 - 2 = 5 となります。
   - この5と、カードに書ける最大の数N（この場合も5）を比較し、小さい方を選びます。
   - つまり、青いカードには最大で5まで書けることになります。

4. `if max_blue >= 1:` で、青いカードに正の整数が書けるかチェックします。
   - もし書けるなら、`cnt += max_blue` でその数だけカウンターに加算します。
   - 例えば、赤が2の時、青は1から5まで書けるので、5通りの組み合わせがあります。

5. もし `max_blue < 1` になったら、それ以降の赤いカードの数ではもう条件を満たせないので、`break` でループを抜けます。




### 具体的な計算過程

`N = 5`（カードに書ける最大の数）、`S = 7`（合計の上限）という具体例でコードがどのように動作するかを詳しく説明します。

### 前提条件
- **赤のカード**と**青のカード**に書ける整数は `1` から `5` です。
- **合計**は `7` 以下でなければならないので、赤と青に書いた数字の合計が `7` 以下になる組み合わせを探します。

### 各ステップの具体例

1. **赤のカードに `1` が書かれる場合**:
   - 赤のカードが `1` のとき、青のカードに書ける最大の値は `S - red = 7 - 1 = 6` ですが、青に書ける最大の数は `5` なので、`min(5, 6) = 5`。
   - 青のカードに書ける値は `1` から `5` までです。
   - 組み合わせ: `(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)` の **5通り**

2. **赤のカードに `2` が書かれる場合**:
   - 赤のカードが `2` のとき、青のカードに書ける最大の値は `S - red = 7 - 2 = 5` なので、`min(5, 5) = 5`。
   - 青のカードに書ける値は `1` から `5` までです。
   - 組み合わせ: `(2, 1), (2, 2), (2, 3), (2, 4), (2, 5)` の **5通り**

3. **赤のカードに `3` が書かれる場合**:
   - 赤のカードが `3` のとき、青のカードに書ける最大の値は `S - red = 7 - 3 = 4` なので、`min(5, 4) = 4`。
   - 青のカードに書ける値は `1` から `4` までです。
   - 組み合わせ: `(3, 1), (3, 2), (3, 3), (3, 4)` の **4通り**

4. **赤のカードに `4` が書かれる場合**:
   - 赤のカードが `4` のとき、青のカードに書ける最大の値は `S - red = 7 - 4 = 3` なので、`min(5, 3) = 3`。
   - 青のカードに書ける値は `1` から `3` までです。
   - 組み合わせ: `(4, 1), (4, 2), (4, 3)` の **3通り**

5. **赤のカードに `5` が書かれる場合**:
   - 赤のカードが `5` のとき、青のカードに書ける最大の値は `S - red = 7 - 5 = 2` なので、`min(5, 2) = 2`。
   - 青のカードに書ける値は `1` から `2` までです。
   - 組み合わせ: `(5, 1), (5, 2)` の **2通り**

### 全体の組み合わせの数
これらすべての組み合わせを足すと、次のようになります：
- 赤のカードが `1` の場合: **5通り**
- 赤のカードが `2` の場合: **5通り**
- 赤のカードが `3` の場合: **4通り**
- 赤のカードが `4` の場合: **3通り**
- 赤のカードが `5` の場合: **2通り**

したがって、合計は:

```
5 + 5 + 4 + 3 + 2 = 19 通り
```

この方法の数学的な考え方：
- 合計がS以下という条件は、「青 ≤ S - 赤」と言い換えられます。
- また、青はNを超えてはいけません。
- したがって、青の取りうる最大値は「min(N, S - 赤)」となります。
- この最大値から1までの整数の数が、各赤の値に対する組み合わせの数になります。

この解法の利点は、すべての組み合わせを個別に数える必要がなく、各赤の値に対して可能な青の値の数を一度に計算できることです。これにより、計算速度が大幅に向上します。

最後に、`main` 関数では `input().split()` で入力を受け取り、`map(int, ...)` でそれぞれを整数に変換しています。そして `count_combination` 関数を呼び出し、結果を出力します。

このように、このコードは効率的に組み合わせの数を計算し、大きな入力に対しても高速に動作します。

<br>
<br>

---

# 009

このコードは、動的計画法（DP）を使って、カードの合計がちょうど `S` になるかどうかを確認するものです。以下に、コードの各部分の解説と具体的な事例を使って処理内容を説明します。

### コードの解説

#### 1. `dp(S, A)` 関数

```python
dp = [1] + [0] * S
```

- ここでは、`dp` というリストを作成しています。`dp[x]` が `1` ならば、合計 `x` を作ることが可能であることを意味します。
- 最初に `dp[0]` を `1` に設定しています。これは、カードを使わずに合計 `0` を作ることができることを意味します。

```python
for i in A:
    for j in range(S-i, -1, -1):
        if dp[j] == 1:
            dp[j+i] = 1
```

- 最初の `for` ループで、各カード `i` の値を順に処理します。
- 次の `for` ループでは、`j` を `S-i` から `0` まで逆に進めながら処理を行います。この逆向きの処理により、同じカードを複数回使うことを防いでいます。
- `dp[j]` が `1` であるなら、`j` の合計が既に作れることを意味するため、`j+i` の合計も作れるようになります。これを `dp[j+i] = 1` で示します。

```python
return "Yes" if dp[-1] == 1 else "No"
```

- 最終的に `dp[S]` が `1` であれば、合計 `S` を作ることが可能であるため "Yes" を返します。そうでない場合は "No" を返します。

#### 2. `main()` 関数

```python
N, S = map(int, input().split())
A = list(map(int, input().split()))
print(dp(S, A))
```

- `N` はカードの枚数、`S` は目標とする合計値です。
- `A` はカードに書かれた整数のリストです。
- これらを `dp(S, A)` 関数に渡して、結果を表示します。

### 事例を使った処理内容の説明

**例:**

```
入力:
N = 3, S = 11
A = [2, 5, 9]

dpテーブルの変化:
初期状態: dp = [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

1番目のカード (2):
dp[0 + 2] = dp[2] = 1 になる
dp = [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]

2番目のカード (5):
dp[0 + 5] = dp[5] = 1 になる
dp[2 + 5] = dp[7] = 1 になる
dp = [1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0]

3番目のカード (9):
dp[0 + 9] = dp[9] = 1 になる
dp[2 + 9] = dp[11] = 1 になる
dp = [1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1]

最終的なdpテーブル:
dp = [1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1]

dp[11] = 1 なので、結果は "Yes"
```

### 処理内容のまとめ

1. 最初は、`dp` テーブルで `0` の合計だけが作れる状態です。
2. 各カードを使って、新たな合計が作れるかを順に検討していきます。
3. 最後に、`S` が作れるかどうかを `dp[S]` を確認して判断します。

この方法は計算量が `O(N * S)` で、効率的かつ分かりやすいアプローチです。

---

# 011

このコードは、N 以下のすべての素数を見つけてリストとして返し、それを空白区切りで出力するものです。コードの各部分を初心者でも理解できるように、具体的な事例を使って詳細に説明します。

### コード全体の構成

1. **`prime(N)` 関数**: N 以下の素数を探す。
2. **`main()` 関数**: 入力を受け取り、`prime(N)` 関数を呼び出して結果を出力する。
3. **`if __name__ == "__main__":`**: スクリプトが直接実行されたときに`main()`を呼び出す。

### 1. `prime(N)` 関数の詳細

```python
def prime(N):
    primes = [True] * (N+1)
    primes[0] = primes[1] = False
    p = 2
    while p*p <= N:
        if primes[p]:
            for i in range(p*p, N+1, p):
                primes[i] = False
        p += 1
    return [i for i in range(N+1) if primes[i]]
```

#### **`primes = [True] * (N+1)`**

- ここでは、`primes`というリストを作成します。このリストは、N 以下の各数が素数かどうかを記録するためのものです。
- 初期値として、すべての数を`True`に設定します。`True`はその数が「素数である」と仮定することを意味します。
- `N+1`の長さにしているのは、0 から N までの数すべてをリストで表現するためです。

#### **`primes[0] = primes[1] = False`**

- 素数の定義により、0 と 1 は素数ではないため、これらを`False`に設定します。

#### **`p = 2`**

- 2 は最初の素数であり、素数を見つける処理を 2 から開始します。

#### **`while p*p <= N:`**

- この`while`ループは、p の平方（p²）が N 以下である限り繰り返されます。
- なぜ平方かというと、p より小さい約数を既に処理しているためです。

#### **`if primes[p]:`**

- もし`primes[p]`が`True`なら、p は素数であると考えます。
- 例えば、p=2 のとき、2 が素数かどうかを確認し、素数なら次のステップに進みます。

#### **`for i in range(p*p, N+1, p):`**

- p が素数であると分かった場合、その倍数はすべて素数ではないため、`False`に設定します。
- `range(p*p, N+1, p)`は、p² から N までの p の倍数を生成します。
- 例えば、p=2 のとき、`range(4, N+1, 2)`は 4, 6, 8, ... のように、2 の倍数を生成します。

#### **`p += 1`**

- p を 1 増やして、次の数字を確認します。

#### **`return [i for i in range(N+1) if primes[i]]`**

- 最後に、`primes`リストで`True`として残っている数を集めてリストとして返します。これが素数のリストになります。

### 2. `main()` 関数の詳細

#### **`N = int(input())`**

- ユーザーから N の値を入力として受け取ります。

#### **`print(*prime(N))`**

- `prime(N)`関数を呼び出して、N 以下の素数を見つけ、それを空白区切りで出力します。`*`はリストをアンパックして、各要素を個別に渡すことを意味します。

### 3. `if __name__ == "__main__":`

- この部分は、スクリプトが直接実行されたときに`main()`を呼び出すためのものです。

### 実例を使った解説

例えば、N=10 の場合の処理を順を追って見てみましょう。

1. `primes`リストは `[True, True, True, True, True, True, True, True, True, True, True]` と初期化されます。ここで、`primes[0]`と`primes[1]`が`False`に設定されます。

2. p=2 から始まり、2 が素数と判定されるため、その倍数である`primes[4]`, `primes[6]`, `primes[8]`, `primes[10]`が`False`に設定されます。

3. 次に p=3 となり、3 が素数と判定されます。`primes[9]`が`False`に設定されます（3 の倍数の中で 9 が唯一未処理）。

4. 最終的に、`primes`リストは `[False, False, True, True, False, True, False, True, False, False, False]` となり、`True`で残っている数が素数です。

5. これを基に、出力は `2 3 5 7` となります。

これが、N 以下の素数を見つけるための基本的な処理の流れです。

---

# 012

このコードは、与えられた数 `N` が素数であるかどうかを判定するためのものです。ここでは、コードの各部分を初心者にも分かりやすく、具体的な例を用いて解説します。

### 1. `is_prime` 関数の説明

```python
def is_prime(n):
    if n < 2: return False
    for i in range(2, int(n*0.5)+1):
        if n % i == 0:
            return False
    return True
```

#### - `n < 2` のチェック

まず、`n` が 2 未満の場合、素数とは見なされないため、`False` を返します。素数は 2 以上の自然数なので、例えば `n = 1` や `n = 0` の場合は、必ず `False` となります。

#### - 素数判定のためのループ

次に、`n` が 2 以上である場合、`2` から `n` の半分 (`n*0.5`) までの整数で割り切れるかどうかをチェックします。割り切れる整数が見つかった場合、その数は素数ではないため、`False` を返します。

- 例えば `n = 10` の場合、半分の `5` までの整数（`2`, `3`, `4`, `5`）で割り切れるかどうかをチェックします。`10` は `2` で割り切れるので、`False` が返されます。

- 逆に、`n = 7` の場合、半分の `3.5` を切り上げた `4` までの整数（`2`, `3`, `4`）で割り切れません。よって `True` が返されます。

#### - `return True`

最後に、上記のチェックをすべてクリアした場合、その数は素数であるため、`True` を返します。

### 2. `main` 関数の説明

```python
def main():
    N = int(input())
    print("Yes" if is_prime(N) else "No")
```

#### - `N = int(input())`

この行で、ユーザーから標準入力を通じて整数 `N` を取得します。例えば、ユーザーが `53` と入力した場合、`N` には `53` が代入されます。

#### - `print("Yes" if is_prime(N) else "No")`

`is_prime` 関数を使って、`N` が素数かどうかを判定します。素数であれば `True` が返ってくるので "Yes" を出力し、素数でなければ "No" を出力します。

- 例えば、`N = 53` なら `is_prime(53)` が `True` を返すので "Yes" と出力されます。
- 逆に、`N = 77` なら `is_prime(77)` が `False` を返すので "No" と出力されます。

### 3. 実行部分

```python
if __name__ == "__main__":
    main()
```

この部分は、スクリプトが直接実行されたときに `main` 関数を呼び出すためのものです。これにより、コードが実行されるときに `main()` が動き出します。

### 処理の流れを具体例で説明

#### - `N = 53` の場合

1. `main()` が実行され、`N` に `53` が代入されます。
2. `is_prime(53)` が呼ばれます。
3. `53` は 2 以上なので次のステップへ進みます。
4. `2` から `26` までの数で `53` を割り切れるかをチェックします。割り切れる数がないため `True` が返されます。
5. `True` が返されたので、"Yes" が出力されます。

#### - `N = 77` の場合

1. `main()` が実行され、`N` に `77` が代入されます。
2. `is_prime(77)` が呼ばれます。
3. `77` は 2 以上なので次のステップへ進みます。
4. `2` から `39` までの数で `77` を割り切れるかをチェックします。`77` は `7` で割り切れるため `False` が返されます。
5. `False` が返されたので、"No" が出力されます。

このように、このコードは素数を判定するためのシンプルで効果的な方法を提供しています。具体例を通じてコードの動作を理解することができたかと思います。

---

# 013

## Pythonで約数を求めるプログラム

このプログラムは、入力された整数 `N` の約数を全て求めて、それぞれを改行区切りで出力するものです。

**コードの解説:**

1. **`divisor(n)` 関数:**
   - この関数は、整数 `n` を受け取り、その約数のリストを返します。
   - `div = set()` : まず、空の集合 `div` を作成します。集合は、重複する要素を持たないデータ構造です。これにより、同じ約数が複数回出力されるのを防ぎます。
   - `for i in range(1, int(n**0.5)+1):`: 1 から `n` の平方根までの整数 `i` について、以下の処理を繰り返します。
     - `if n % i == 0:`:  `n` が `i` で割り切れる場合、つまり `i` が `n` の約数である場合、以下の処理を行います。
       - `div.add(i)`: `i` を集合 `div` に追加します。
       - `div.add(n // i)`: `n` を `i` で割った商もまた `n` の約数なので、これも集合 `div` に追加します。
   - `return sorted(div)`: 最後に、集合 `div` を昇順にソートしたリストを返します。

2. **`main()` 関数:**
   - この関数は、プログラムのメインの処理を行います。
   - `N = int(input())`: ユーザーからの入力を整数として受け取り、変数 `N` に格納します。
   - `print(*divisor(N), sep='\n')`: `divisor(N)` を呼び出して `N` の約数のリストを取得し、`print()` 関数を使って、それらの約数を改行 (`\n`) 区切りで出力します。 `*` はリストの要素を展開する役割を果たします。

3. **`if __name__ == "__main__":`:**
   - この部分は、このPythonファイルが直接実行された場合にのみ `main()` 関数を実行することを意味します。他のプログラムからこのファイルをモジュールとしてインポートする場合には、`main()` 関数は実行されません。

**処理の過程の例:**

例えば、`N` に 12 が入力された場合の処理過程は以下のようになります。

1. `divisor(12)` が呼び出されます。
2. `div` という空の集合が作成されます。
3. `for` ループで、`i` が 1 から 3 (12 の平方根は 3.46... なので、`int(12**0.5) + 1` は 4 になります) まで以下の処理が繰り返されます。
   - `i = 1`: 12 は 1 で割り切れるので、1 と 12 (12 // 1) が `div` に追加されます。
   - `i = 2`: 12 は 2 で割り切れるので、2 と 6 (12 // 2) が `div` に追加されます。
   - `i = 3`: 12 は 3 で割り切れるので、3 と 4 (12 // 3) が `div` に追加されます。
4. `div` ( `{1, 12, 2, 6, 3, 4}` ) がソートされ、 `[1, 2, 3, 4, 6, 12]` となります。
5. `[1, 2, 3, 4, 6, 12]` が `main()` 関数に返され、それぞれの要素が改行区切りで出力されます。

**出力:**

```
1
2
3
4
6
12
```

---

# 014

はい、このコードは素数を効率的に生成し、それを用いて素因数分解を行う優れたアプローチです。

## コードの解説

### 1. 素数生成関数 `prime(N)`

```python
def prime(N):
    primes = [True] * (N+1)
    primes[0] = primes[1] = False
    p = 2
    while p*p <= N:
        if primes[p]:
            for i in range(p*p, N+1, p):
                primes[i] = False
        p += 1
    return [i for i in range(N+1) if primes[i]]
```

この関数はエラトステネスの篩（ふるい）というアルゴリズムを使用して、2からNまでの素数のリストを生成します。

- `primes`リストを作成し、初めはすべての数を素数候補（`True`）とします。
- 0と1は素数ではないので`False`にします。
- 2から√Nまでの各数pについて：
  - pが素数なら、その倍数（p^2から始めて）をすべて素数でないとマークします。
- 最後に、`True`のままの指標に対応する数（つまり素数）のリストを返します。

例：N = 20の場合
結果: [2, 3, 5, 7, 11, 13, 17, 19]

### 2. 素因数分解関数 `prime_fractorization(n, primes)`

```python
def prime_fractorization(n, primes):
    fractors = []
    for i in primes:
        if i * i > n:
            break
        while n % i == 0:
            fractors.append(i)
            n //= i
    if n > 1:
        fractors.append(n)
    return fractors
```

この関数は、与えられた数nを素因数分解します。

- 生成された素数リスト`primes`の各素数iについて：
  - nがiで割り切れる限り、iを因数リストに追加し、nをiで割ります。
- 最後にnが1より大きければ、それ自体も素因数として追加します。

例：n = 60, primes = [2, 3, 5, 7, 11, 13, 17, 19]の場合
処理：
1. 2で割る：60 ÷ 2 = 30, fractors =
2. 2で割る：30 ÷ 2 = 15, fractors = [2, 2]
3. 3で割る：15 ÷ 3 = 5,  fractors = [2, 2, 3]
4. 5で割る：5 ÷ 5 = 1,   fractors = [2, 2, 3, 5]
結果: [2, 2, 3, 5]

### 3. メイン関数 `main()`

```python
def main():
    N = int(input())
    primes = prime(N)
    print(*prime_fractorization(N, primes))
```

- ユーザーから入力を受け取ります。
- その数までの素数リストを生成します。
- 入力された数を素因数分解し、結果を出力します。

## 処理の流れ（例：N = 60の場合）

1. ユーザーが60を入力
2. `prime(60)`を呼び出し、60までの素数リスト[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59]を生成
3. `prime_fractorization(60, primes)`を呼び出し
4. 60を素因数分解：[2, 2, 3, 5]
5. 結果を出力：2 2 3 5

このアプローチは、特に大きな数の素因数分解を行う際に効率的です。素数のリストを事前に生成することで、試し割りの回数を大幅に減らすことができます。

---

# 015

## コード解説： ユークリッドの互除法による最大公約数計算

このPythonコードは、**ユークリッドの互除法**という効率的なアルゴリズムを使って、2つの整数の最大公約数 (GCD) を計算します。

**コードの構成:**

1. **`gcd(a, b)` 関数:**
   - この関数は、引数として2つの整数 `a` と `b` を受け取り、それらの最大公約数を計算して返します。
   - ユークリッドの互除法のロジックを実装しています。

2. **`main()` 関数:**
   - プログラムの主要な処理を行う関数です。
   - ユーザーから2つの整数を入力として受け取り、`gcd()` 関数を呼び出して最大公約数を計算し、結果を表示します。

3. **`if __name__ == "__main__":` ブロック:**
   - このブロックは、スクリプトが直接実行された場合にのみ `main()` 関数を呼び出します。
   - これにより、このスクリプトを他のモジュールからインポートする場合に、`main()` 関数が自動的に実行されるのを防ぎます。

**ユークリッドの互除法の解説:**

このアルゴリズムは、以下の手順で最大公約数を計算します。

1. **大きい方の数を小さい方の数で割った余りを求める。**
2. **元の小さい方の数と余りを用いて、再度1の操作を行う。**
3. **余りが0になるまで1と2の操作を繰り返す。**
4. **余りが0になったときの、割る数（0ではない方）が最大公約数となる。**

**コードの処理内容： 例を用いた説明**

例えば、`A = 24`、`B = 18` の場合を考えます。

1. **`main()` 関数:**
   - `input().split()` によって、ユーザーは "24 18" のように2つの数字をスペースで区切って入力します。
   - `map(int, ...)` は、入力された文字列を整数に変換し、`A` には 24、`B` には 18 がそれぞれ代入されます。
   - `gcd(24, 18)` を呼び出して、最大公約数を計算します。

2. **`gcd(24, 18)` 関数:**
   - **1回目:**
     - `b` (18) は 0 ではないため、`while` ループに入ります。
     - `a` (24) を `b` (18) で割った余り (`24 % 18`) は 6 となります。
     - `a` には `b` の値 (18) が、`b` には余りの値 (6) が代入されます。
   - **2回目:**
     - `b` (6) はまだ 0 ではありません。
     - `a` (18) を `b` (6) で割った余り (`18 % 6`) は 0 となります。
     - `a` には `b` の値 (6) が、`b` には余りの値 (0) が代入されます。
   - **ループ終了:**
     - `b` が 0 になったため、`while` ループが終了します。
   - `a` の値 (6) が `return` されます。

3. **`main()` 関数 (続き):**
   - `gcd(24, 18)` の戻り値 (6) が `print()` によって画面に表示されます。

**まとめ**

このコードは、ユークリッドの互除法という効率的なアルゴリズムを使って、2つの整数の最大公約数を計算します。ユークリッドの互除法は、再帰的に余りを計算することで、最大公約数を高速に見つけることができます。

---
# 016

## 最大公約数を求めるプログラム解説

このプログラムは、複数の整数の最大公約数 (GCD: Greatest Common Divisor) を求めるものです。

### 1. ユークリッドの互除法

最大公約数を求めるために、 **ユークリッドの互除法** という方法を使っています。 これは、2つの数 `a` と `b` (ただし `a > b`) について、

-  `a` を `b` で割った余りを `r` とすると (`a % b = r`)、
-  `a` と `b` の最大公約数は、`b` と `r` の最大公約数と同じになる

という性質を利用した方法です。 これを繰り返していくと、最終的に余りが `0` になり、その時の `b` の値が最大公約数になります。

例えば、12 と 18 の最大公約数を求める場合:

1. 18 ÷ 12 = 1 余り 6
2. 12 ÷ 6 = 2 余り 0

よって、12 と 18 の最大公約数は 6 となります。

### 2. コードの解説

#### 2-1. `gcd(a, b)` 関数:

- この関数は、ユークリッドの互除法を使って、2つの整数 `a` と `b` の最大公約数を計算します。
- `while b != 0:` は、`b` が 0 になるまでループを繰り返すことを意味します。
- ループの中では、`a` と `b` の値を更新しています。 `a` には `b` の値を、`b` には `a` を `b` で割った余り (`a % b`) を代入しています。
- 最終的に `b` が 0 になった時の `a` の値が、`a` と `b` の最大公約数なので、`return a` でその値を返します。

#### 2-2. `gcd_list(A)` 関数:

- この関数は、整数のリスト `A` を受け取り、そのリスト内の全ての要素の最大公約数を計算します。
- `res = A[0]` で、リストの最初の要素を初期値として `res` に代入します。
- `for i in A[1:]:` で、リストの2番目の要素から順番に `i` に代入してループを回します。
- ループの中では、`res` と `i` の最大公約数を `gcd(res, i)` で計算し、その結果を再び `res` に代入します。
- これを繰り返すことで、`res` にはリスト `A` の全ての要素の最大公約数が格納されていきます。
- 最終的に、`return res` で計算結果を返します。

#### 2-3. `main()` 関数:

- プログラムのメイン処理を行います。
- `N = int(input())` で、整数の個数 `N` を入力として受け取ります。
- `A = list(map(int, input().split()))` で、`N` 個の整数をスペース区切りで入力として受け取り、リスト `A` に格納します。
- `print(gcd_list(A))` で、`gcd_list(A)` 関数を呼び出して最大公約数を計算し、その結果を出力します。

#### 2-4. `if __name__ == "__main__":` :

- このプログラムが直接実行された場合にのみ、`main()` 関数を実行します。

### 3. 実行例

例えば、入力として以下のようなデータが与えられたとします。

```
3  # 整数の個数 N
12 18 24 # 整数のリスト A
```

1. `main()` 関数内で、`N` には `3` が、`A` には `[12, 18, 24]` が格納されます。
2. `gcd_list([12, 18, 24])` が実行されます。
    - `res` に `12` が代入されます。
    - 1回目のループ: `gcd(12, 18) = 6` なので、`res` に `6` が代入されます。
    - 2回目のループ: `gcd(6, 24) = 6` なので、`res` に `6` が代入されます。
3. `gcd_list([12, 18, 24])` は `6` を返します。
4. `main()` 関数内の `print()` によって `6` が出力されます。

このように、このプログラムはユークリッドの互除法を用いて、複数の整数の最大公約数を効率的に計算することができます.

---
# 017

## ユークリッドの互除法で最小公倍数が求められる理由

ユークリッドの互除法は、一見最大公約数を求めるためのアルゴリズムですが、なぜ最小公倍数の計算にも使えるのでしょうか？その理由を詳しく解説します。

### 最大公約数と最小公倍数の関係

**最大公約数 (GCD)** と **最小公倍数 (LCM)** の間には、以下の関係が成り立ちます。

- **2 つの自然数 a, b の積** = **a, b の最大公約数** × **a, b の最小公倍数**

つまり、

```
a × b = GCD(a, b) × LCM(a, b)
```

が成り立ちます。

### ユークリッドの互除法と最小公倍数の関係

ユークリッドの互除法を用いて、2 つの数の最大公約数 GCD(a, b) を求めることができます。上記の式を変形すると、

```
LCM(a, b) = (a × b) / GCD(a, b)
```

となります。

つまり、**2 つの数の積を、ユークリッドの互除法で求めた最大公約数で割る**ことで、最小公倍数が求められるのです。

### なぜこの関係が成り立つのか？

この関係が成り立つ直感的な理由としては、以下のことが挙げられます。

- **最大公約数:** 2 つの数に共通する約数のうち、最大のものです。
- **最小公倍数:** 2 つの数を両方割り切ることができる最小の自然数です。

最大公約数は、2 つの数に共通する部分を表し、最小公倍数は、2 つの数を包含する部分を表します。この 2 つの概念は、ある意味で逆の関係にあります。

**具体例:**
2 つの数 12 と 18 を例に考えてみましょう。

- 12 = 2^2 × 3
- 18 = 2 × 3^2

- 最大公約数: 2 × 3 = 6
- 最小公倍数: 2^2 × 3^2 = 36

12 と 18 の積は、2^3 × 3^3 です。この積を最大公約数 6 で割ると、最小公倍数 36 が得られます。

### まとめ

ユークリッドの互除法で最大公約数を求めることで、最小公倍数も計算できるのは、最大公約数と最小公倍数の間の深い関係があるからです。この関係式は、数論において非常に重要な概念であり、様々な問題を解く際に役立ちます。

**ポイント:**

- ユークリッドの互除法は、最大公約数だけでなく、最小公倍数の計算にも応用できる。
- 最大公約数と最小公倍数は、ある意味で逆の関係にある。
- 2 つの数の積を最大公約数で割ると、最小公倍数が得られる。

**コードの解説:**
```python
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return a

def lcm(a, b):
    return a * b // gcd(a, b)

def lcm_list(A):
    res = A[0]
    for i in A[1:]:
        res = lcm(res, i)
    return res

def main():
    N = int(input())
    A = list(map(int, input().split()))
    print(lcm_list(A))

if __name__ == "__main__":
    main()
```

1. **`gcd(a, b)` 関数:**
   - 2つの整数 `a` と `b` の最大公約数 (GCD) を計算します。
   - ユークリッドの互除法という効率的なアルゴリズムを使用しています。
     - `b` が 0 になるまで、`(a, b)` を `(b, a % b)` で繰り返し置き換えます。
     - 最終的に `b` が 0 になったときの `a` が最大公約数です。

2. **`lcm(a, b)` 関数:**
   - 2つの整数 `a` と `b` の最小公倍数 (LCM) を計算します。
   - 最小公倍数は、2つの数の積を最大公約数で割ることによって求められます。
     - `return a * b // gcd(a, b)`

3. **`lcm_list(A)` 関数:**
   - 整数のリスト `A` を入力として受け取り、リスト内のすべての整数の最小公倍数を計算します。
   - 最初に、結果を格納する変数 `res` をリストの最初の要素 `A[0]` に初期化します。
   - 次に、リストの2番目の要素から最後の要素まで順番に処理します。
     - 各要素 `i` について、`res` と `i` の最小公倍数を計算し、その結果を `res` に格納します。
   - 最後に、計算された最小公倍数 `res` を返します。

4. **`main()` 関数:**
   - プログラムのメイン処理を行います。
   - まず、入力として整数 `N` を受け取ります。これは、リストの要素数を表します。
   - 次に、空白区切りで入力された `N` 個の整数を `map(int, input().split())` を使って整数に変換し、リスト `A` に格納します。
   - `lcm_list(A)` 関数を呼び出して、リスト `A` の最小公倍数を計算し、結果を出力します。

5. **`if __name__ == "__main__":`:**
   - この部分は、Pythonスクリプトが直接実行された場合にのみ `main()` 関数を呼び出すために使用されます。

**事例:**

入力として `[12, 18, 14]` が与えられた場合の処理内容をステップごとに説明します。

1. `main()` 関数で、`N = 3`, `A = [12, 18, 14]` となります。
2. `lcm_list([12, 18, 14])` が呼び出されます。
   - `res = 12` で初期化されます。
   - `i = 18` のとき:
     - `lcm(12, 18)` が呼び出され、`gcd(12, 18) = 6` なので、`lcm(12, 18) = 36` となります。
     - `res` が 36 に更新されます。
   - `i = 14` のとき:
     - `lcm(36, 14)` が呼び出され、`gcd(36, 14) = 2` なので、`lcm(36, 14) = 252` となります。
     - `res` が 252 に更新されます。
3. `lcm_list([12, 18, 14])` は 252 を返します。
4. `main()` 関数で、252 が出力されます。

したがって、`[12, 18, 14]` の最小公倍数は 252 となります。


---
# 018

このコードは、動的計画法を使って、商品の値段リスト `A` から、2つの商品の合計金額が500円になる組み合わせがいくつあるかを効率的に計算しています。

**コードの解説**

1. **`dp(A)` 関数:**
   - `dp = [0] * 401`: これは、金額を添字としたリスト `dp` を作成し、全ての要素を0で初期化しています。`dp[i]` は、商品の合計金額が `i` 円になる組み合わせの数を表します。
     - 例えば、`dp[100]` は、商品の合計金額が100円になる組み合わせの数、`dp[300]` は合計金額が300円になる組み合わせの数を表します。
     - リストのサイズは401としているのは、商品の最大金額が400円なので、組み合わせで実現できる最大の金額は800円となり、計算に必要な範囲をカバーするためです (今回は500円までで十分ですが)。
   - `count = 0`: これは、合計金額が500円になる組み合わせの数をカウントするための変数です。

   - `for price in A:`: 入力された商品の値段リスト `A` から、一つずつ `price` を取り出して処理を行います。
     - `if price < 500:`:  現在の商品の値段 `price` が500円未満の場合のみ、以下の処理を行います。500円以上の場合は組み合わせで500円を作ることはできないためです。
       - `count += dp[500 - price]`:  `dp[500 - price]` は、現在見ている商品と組み合わせると合計金額が500円になるような、**既に登場した商品の組み合わせの数** を表しています。これを `count` に加算することで、500円になる組み合わせを効率的に数えています。

     - `dp[price] += 1`:  現在の商品の値段 `price` が登場した回数を記録します。これは、以降の商品の処理で、`price` と組み合わせられる可能性があるためです。

   - `return count`:  最後に、合計金額が500円になる組み合わせの数 `count` を返します。

2. **`main()` 関数:**
   - `_ = input()`:  商品の個数を受け取りますが、このコードでは使用しないので、変数には格納せずに読み飛ばしています。
   - `A = map(int, input().split())`:  商品の値段リスト `A` を受け取ります。
   - `print(dp(A))`:  `dp(A)` 関数を呼び出して計算結果を表示します。

**事例を使った処理内容の説明**

例えば、入力例として `A = [100, 300, 400, 400, 200]` が与えられたとします。

1. `price = 100` のとき:
   - `count += dp[400]` (現時点では `dp[400] = 0`)
   - `dp[100] += 1` (`dp[100]` は 1 になります)

2. `price = 300` のとき:
   - `count += dp[200]` (現時点では `dp[200] = 0`)
   - `dp[300] += 1` (`dp[300]` は 1 になります)

3. `price = 400` のとき:
   - `count += dp[100]` (`dp[100]` は 1 なので、`count` が 1 になります)
   - `dp[400] += 1` (`dp[400]` は 1 になります)

4. `price = 400` のとき:
   - `count += dp[100]` (`dp[100]` は 1 なので、`count` が 2 になります)
   - `dp[400] += 1` (`dp[400]` は 2 になります)

5. `price = 200` のとき:
   - `count += dp[300]` (`dp[300]` は 1 なので、`count` が 3 になります)
   - `dp[200] += 1` (`dp[200]` は 1 になります)

最終的に `count` は 3 となり、これが合計金額が500円になる組み合わせの数となります。

このように、このコードは動的計画法を用いることで、効率的に組み合わせの数を計算しています。

---
# 019

このコードの目的は、与えられたカードのリストの中から、同じ色のカード2枚を選ぶ方法が何通りあるかを計算することです。カードには3種類の色があり、色は数値 `1`（赤）、`2`（黄色）、`3`（青）で表されます。

### コードの解説

#### 1. `count_pairs(A)` 関数
この関数は、リスト `A` に含まれる色ごとのカードの枚数をカウントし、同じ色のカードを2枚選ぶ方法の数を返します。

```python
def count_pairs(A):
    count = [A.count(color) for color in (1, 2, 3)]
    return sum(c * (c - 1) // 2 for c in count)
```

- **`A.count(color)`**: リスト `A` の中で指定した色 (`color`) が何回出現するかをカウントします。`color` は `1, 2, 3` という3つの色を順に調べます。
  - `A.count(1)` は `A` の中で赤色カード（1）の枚数を返し、同様に `A.count(2)` は黄色カード、`A.count(3)` は青色カードの枚数を返します。
  - この結果はリスト内包表記で `count` というリストに保存されます。
    - 例えば、`count = [赤の枚数, 黄の枚数, 青の枚数]` というリストになります。

- **`sum(c * (c - 1) // 2 for c in count)`**: この部分は、各色ごとにカードを2枚選ぶ組み合わせ数を計算します。
  - `c * (c - 1) // 2` は、`c` 枚のカードから2枚を選ぶ組み合わせの数を表します。例えば、3枚のカードがあれば `3 * 2 // 2 = 3` 通りの組み合わせが作れます。
  - これを各色（赤、黄、青）について計算し、その合計を返します。

#### 2. `main()` 関数
この関数は、プログラムの実行の流れを制御する役割を持っています。

```python
def main():
    N = int(input())
    A = list(map(int, input().split()))
    print(count_pairs(A))
```

- **`N = int(input())`**: 入力される整数を受け取り、カードの枚数 `N` に格納します。
- **`A = list(map(int, input().split()))`**: 入力されたカードの色情報をリストとして受け取り、`A` に格納します。各カードの色はスペース区切りで入力されます。
- **`print(count_pairs(A))`**: `count_pairs()` 関数を呼び出して結果を計算し、それを出力します。

#### 3. `if __name__ == "__main__():`
```python
if __name__ == "__main__":
    main()
```

この部分は、スクリプトを直接実行した場合に `main()` 関数を呼び出すためのものです。Pythonでは、このようにしてメインの処理を行うことが一般的です。

### 処理内容の説明（例を使って）

**入力例:**
```
6
1 3 2 1 1 2
```

1. **入力の読み取り**
   - `N = 6`: カードの枚数は6枚です。
   - `A = [1, 3, 2, 1, 1, 2]`: 各カードの色は、順に赤(1), 青(3), 黄(2), 赤(1), 赤(1), 黄(2)です。

2. **色の枚数をカウント**
   - `count = [3, 2, 1]`: 赤色カードが3枚、黄色カードが2枚、青色カードが1枚です。

3. **組み合わせ数を計算**
   - 赤色カード: `3 * (3 - 1) // 2 = 3` 通り（3枚から2枚を選ぶ組み合わせ）。
   - 黄色カード: `2 * (2 - 1) // 2 = 1` 通り（2枚から2枚を選ぶ組み合わせ）。
   - 青色カード: `1 * (1 - 1) // 2 = 0` 通り（1枚しかないため、選べません）。
   - 合計で、`3 + 1 + 0 = 4` 通りです。

4. **結果の出力**
   - 結果は `4` なので、この例の場合は、同じ色のカードを2枚選ぶ方法が4通りあることがわかります。

### 結論

このコードは、リスト内包表記と組み合わせ数の計算を簡潔に書いています。初心者向けのポイントとしては、リストの `count` 関数や、組み合わせの計算式 `c * (c - 1) // 2` の意味を理解することが重要です。このコードはとても効率的で、入力されるカードの枚数が大きくても高速に動作します。

---
# 020

## コード解説

このコードは、動的計画法 (DP) を使って、与えられた整数列 `A` から重複なく5個の数字を選び、その和が1000になる組み合わせの数を計算します。

```python
def calc(A):
    dp = [[0] * 1001 for _ in range(6)]
    dp[0][0] = 1

    for num in A:
        for k in range(4, -1, -1):
            for s in range(1000 - num + 1):
                dp[k + 1][s + num] += dp[k][s]
    return dp[5][1000]

def main():
    N = int(input())
    A = list(map(int, input().split()))
    print(calc(A))

if __name__ == "__main__":
    main()
```

### 1. `calc(A)` 関数

#### 1.1. 変数

- `dp`: 動的計画法のテーブル。`dp[k][s]` は、`A` の先頭から何個かまでの数字を使い、ちょうど `k` 個の数字を選んで合計を `s` にできる組み合わせの数 を表します。
- `num`:  入力 `A` から順に取り出される整数。

#### 1.2. 初期化

- `dp[0][0] = 1`: 数字を一つも選ばない (`k=0`) 時に和が0 (`s=0`) になる組み合わせは1通りなので、1で初期化します。

#### 1.3. ループ処理

- **外側のループ**: `A` の各数字 `num` について処理を行います。
- **中側のループ**:  選ぶ数字の個数 `k` を減らしながらループします (`4, 3, 2, 1, 0`)。 `k` を降順に処理することで、同じ数字を複数回使ってしまうことを防いでいます。
- **内側のループ**:  `s` は、`k` 個の数字を選んだ時の和を表す変数で、`1000 - num` から `0` まで降順にループします。

#### 1.4. 更新処理

- `dp[k + 1][s + num] += dp[k][s]`:  `k` 個の数字で和を `s` にできる組み合わせ数に、`num` を加えることで、`k+1` 個の数字で和を `s + num` にできる組み合わせ数を計算し、`dp[k+1][s+num]` に加算しています。

#### 1.5. 返り値

- `dp[5][1000]`:  最終的に、`5` 個の数字を選んで和を `1000` にできる組み合わせの数を返します。

### 2. `main()` 関数

- 入力を受け取り、`calc(A)` を呼び出して結果を出力します。


## 事例を使った説明

例えば、`A = [100, 200, 300, 400, 500]` の場合を考えます。

1. `num = 100` のループ処理では、`dp[1][100]` が 1 になります。
2. `num = 200` のループ処理では、`dp[1][200]`, `dp[2][300]` がそれぞれ 1 になります。
3. `num = 300` のループ処理では、`dp[1][300]`, `dp[2][500]`, `dp[3][600]` がそれぞれ 1 になります。
4. `num = 400` のループ処理では、`dp[1][400]`, `dp[2][600]`, `dp[3][700]`, `dp[4][900]` がそれぞれ 1 になります。
5. `num = 500` のループ処理では、`dp[1][500]`, `dp[2][700]`, `dp[3][800]`, `dp[4][1000]`, `dp[5][1000]` がそれぞれ 1 になります。

最終的に `dp[5][1000] = 1` となり、和が1000になる組み合わせが1通り存在することが分かります。


## まとめ

このコードは、動的計画法を使って効率的に組み合わせの数を計算しています。ループの順番や添字の扱いに工夫があり、理解するには少し練習が必要かもしれません。しかし、一度理解してしまえば、様々な組み合わせの問題に応用することができます。

## [補足] ループ処理部分の詳細説明

ここでは、プログラムの核心部分であるトリプルループの動作を詳しく説明します。

```python
for num in A:
    for k in range(4, -1, -1):
        for s in range(1000 - num + 1):
            dp[k + 1][s + num] += dp[k][s]
```

## ループの意味

1. `for num in A:`
   - 各カードの値（`num`）について処理を行います。

2. `for k in range(4, -1, -1):`
   - `k`は現在使用しているカードの枚数を表します。
   - 4から0まで逆順に処理します。これは新しいカードを追加する際、既存の組み合わせに影響を与えないようにするためです。

3. `for s in range(1000 - num + 1):`
   - `s`は現在の合計を表します。
   - 新しいカード`num`を追加しても1000を超えない範囲で処理します。

4. `dp[k + 1][s + num] += dp[k][s]`
   - `k`枚のカードで合計`s`を作る方法の数を、`k+1`枚のカードで合計`s+num`を作る方法の数に加算します。

## 具体例での説明

入力例：`A = [100, 150, 200, 250, 300]`

最初の2枚のカード（100と150）の処理を詳細に見ていきます。

### カード100の処理

```python
num = 100
for k in range(4, -1, -1):
    for s in range(1000 - 100 + 1):  # 0から900まで
        dp[k + 1][s + 100] += dp[k][s]
```

初期状態：`dp[0][0] = 1`、他はすべて0

1. `k = 4`のとき：何も更新されません（`dp[4][s]`がすべて0のため）
2. `k = 3`のとき：何も更新されません
3. `k = 2`のとき：何も更新されません
4. `k = 1`のとき：何も更新されません
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][100] += dp[0][0]`
     結果：`dp[1][100] = 1`（1枚で100を作る方法が1通り）

### カード150の処理

```python
num = 150
for k in range(4, -1, -1):
    for s in range(1000 - 150 + 1):  # 0から850まで
        dp[k + 1][s + 150] += dp[k][s]
```

1. `k = 4`のとき：何も更新されません
2. `k = 3`のとき：何も更新されません
3. `k = 2`のとき：何も更新されません
4. `k = 1`のとき：
   - `s = 100`の場合：`dp[2][250] += dp[1][100]`
     結果：`dp[2][250] = 1`（2枚で250を作る方法が1通り、100+150）
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][150] += dp[0][0]`
     結果：`dp[1][150] = 1`（1枚で150を作る方法が1通り）

### カード200の処理

```python
num = 200
for k in range(4, -1, -1):
    for s in range(1000 - 200 + 1):  # 0から800まで
        dp[k + 1][s + 200] += dp[k][s]
```

処理前の状態：
- `dp[1][100] = 1`
- `dp[1][150] = 1`
- `dp[2][250] = 1`

1. `k = 4`のとき：何も更新されません
2. `k = 3`のとき：何も更新されません
3. `k = 2`のとき：
   - `s = 250`の場合：`dp[3][450] += dp[2][250]`
     結果：`dp[3][450] = 1`（3枚で450を作る方法が1通り、100+150+200）
4. `k = 1`のとき：
   - `s = 100`の場合：`dp[2][300] += dp[1][100]`
     結果：`dp[2][300] = 1`（2枚で300を作る方法が1通り、100+200）
   - `s = 150`の場合：`dp[2][350] += dp[1][150]`
     結果：`dp[2][350] = 1`（2枚で350を作る方法が1通り、150+200）
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][200] += dp[0][0]`
     結果：`dp[1][200] = 1`（1枚で200を作る方法が1通り）

### カード250の処理

```python
num = 250
for k in range(4, -1, -1):
    for s in range(1000 - 250 + 1):  # 0から750まで
        dp[k + 1][s + 250] += dp[k][s]
```

1. `k = 4`のとき：何も更新されません
2. `k = 3`のとき：
   - `s = 450`の場合：`dp[4][700] += dp[3][450]`
     結果：`dp[4][700] = 1`（4枚で700を作る方法が1通り、100+150+200+250）
3. `k = 2`のとき：
   - `s = 300`の場合：`dp[3][550] += dp[2][300]`
     結果：`dp[3][550] = 1`（3枚で550を作る方法が1通り、100+200+250）
   - `s = 350`の場合：`dp[3][600] += dp[2][350]`
     結果：`dp[3][600] = 1`（3枚で600を作る方法が1通り、150+200+250）
4. `k = 1`のとき：
   - `s = 100`の場合：`dp[2][350] += dp[1][100]`
     結果：`dp[2][350] = 2`（2枚で350を作る方法が2通り、150+200と100+250）
   - `s = 150`の場合：`dp[2][400] += dp[1][150]`
     結果：`dp[2][400] = 1`（2枚で400を作る方法が1通り、150+250）
   - `s = 200`の場合：`dp[2][450] += dp[1][200]`
     結果：`dp[2][450] = 1`（2枚で450を作る方法が1通り、200+250）
5. `k = 0`のとき：
   - `s = 0`の場合：`dp[1][250] += dp[0][0]`
     結果：`dp[1][250] = 1`（1枚で250を作る方法が1通り）

### カード300の処理

```python
num = 300
for k in range(4, -1, -1):
    for s in range(1000 - 300 + 1):  # 0から700まで
        dp[k + 1][s + 300] += dp[k][s]
```

1. `k = 4`のとき：
   - `s = 700`の場合：`dp[5][1000] += dp[4][700]`
     結果：`dp[5][1000] = 1`（5枚で1000を作る方法が1通り、100+150+200+250+300）
2. `k = 3`のとき：
   - `s = 550`の場合：`dp[4][850] += dp[3][550]`
     結果：`dp[4][850] = 1`（4枚で850を作る方法が1通り、100+200+250+300）
   - `s = 600`の場合：`dp[4][900] += dp[3][600]`
     結果：`dp[4][900] = 1`（4枚で900を作る方法が1通り、150+200+250+300）
3. `k = 2`, `k = 1`, `k = 0`のときの処理も同様に行われます...

### 最終結果

すべてのカードの処理が終わった後、`dp[5][1000] = 1` となります。これは、5枚のカードを使って合計1000を作る方法が1通りあることを意味します。

この例では、唯一の組み合わせは 100 + 150 + 200 + 250 + 300 = 1000 となります。

このプロセスを通じて、プログラムは効率的にすべての可能な組み合わせを探索し、条件を満たす組み合わせの数を数えています。各ステップで `dp` 配列を更新することで、以前の計算結果を再利用し、計算量を大幅に削減しています。


---

# 021

  $\mathbf{u} \cdot \mathbf{v} = |\mathbf{u}| |\mathbf{v}| \cos \theta $

このコードは、組み合わせ $_nC_r$ を計算するための関数を実装しています。

### `comb(n, r)` 関数の解説

#### 1. `r = min(r, n - r)`
この行は、計算を効率化するための工夫です。組み合わせ $_nC_r$ の式は対称性を持っており、次のように成り立ちます：

$${ {}_nC_{r} = {}_nC_{n - r} }$$

したがって、 $r$ を $\min(r, n - r)$ とすることで、計算する項数を減らすことができます。<br>
たとえば、 $n = 6, r = 4$ の場合、 $ _6C_4 $ = $ _6C_2 $ なので、2つ選ぶ場合の計算だけで済みます。<br>
これにより、より少ない回数で計算できます。

#### 2. `res = 1`
ここで変数 `res` は最終的な結果を保存する変数です。最初に 1 で初期化し、ループで掛け算を繰り返していきます。

#### 3. `for i in range(r):`
このループは、組み合わせの公式に基づいて計算を行います。例えば、\( $_nC_r$\) は次の式で計算できます：
<br>&nbsp;&nbsp;&nbsp;&nbsp;
$_nC_r = \dfrac{n \times (n-1) \times \dots \times (n-r+1)}{r \times (r-1) \times \dots \times 1}$

このループでは、分子部分 \( $n \times (n-1) \times \dots$ \) を `res` に掛け算しながら、同時に分母部分 \( $r \times (r-1) \times \dots$ \) で割り算していきます。<br>
これにより、大きな数の階乗を計算することなく、計算が完了します。

#### 4. `res = res * (n - i) // (i + 1)`
この式は、分子と分母の掛け算・割り算を同時に行っています。
- `n - i` は分子の \( $n, n-1, n-2, \dots$ \) に対応しています。
- `i + 1` は分母の \( $1, 2, 3, \dots$ \) に対応しています。

ループの各ステップで `res` に値を計算していきます。

#### 5. `return res`
最終的に計算された組み合わせの結果を返します。

### `main()` 関数の解説

1. `n, r = map(int, input().split())`:
   ユーザーから入力を受け取り、`n` と `r` に整数として代入します。入力は空白区切りで与えられます。

2. `print(comb(n, r))`:
   `comb(n, r)` 関数を呼び出して結果を計算し、`print()` 関数で結果を出力します。

### `if __name__ == "__main__":`

これは、プログラムが直接実行された場合にのみ `main()` 関数が呼び出されるようにするための構造です。<br>
通常、スクリプトをモジュールとしてインポートされた場合、`main()` 関数は実行されません。

---

### 処理の内容を事例で説明

#### 事例: \( $n = 6, r = 2$ \)

1. **`comb(n=6, r=2)` を呼び出す**
   - 最初に `r = min(2, 6-2) = 2` です。この時、\( $r$ \) は変わらず 2 のままです。
   - `res = 1` で初期化します。

2. **ループの1回目 (i=0)**
   - `res = res * (6 - 0) // (0 + 1) = 1 * 6 // 1 = 6`
   - `res` の値は 6 になります。

3. **ループの2回目 (i=1)**
   - `res = res * (6 - 1) // (1 + 1) = 6 * 5 // 2 = 30 // 2 = 15`
   - `res` の値は 15 になります。

4. **ループ終了**
   - `r = 2` のため、2回のループが終了し、`res` は 15 です。

5. **結果を返す**
   - `comb(6, 2)` の結果は 15 となり、最終的に `print()` でこの値が出力されます。

---

### 出力例
入力:
```
6 2
```

出力:
```
15
```

このコードは、計算を効率化しつつシンプルに組み合わせを求めるためのものです。

---
# 022

```python
def count_pairs(A):
    count = {}
    res = 0
    for a in A:
        if 100000 - a in count:
            res += count[100000 - a]

        if a in count:
            count[a] += 1
        else:
            count[a] = 1
    return res

def main():
    N = int(input())
    A = map(int, input().split())
    print(count_pairs(A))

if __name__ == "__main__":
    main()
```

以下は、`count_pairs` 関数とその動作についての詳細な説明です。

### コードの解説

1. **`count_pairs(A)` 関数の目的**:
   - 与えられたカードのリスト `A` から、和が `100000` になるペアの組み合わせの数をカウントする関数です。

2. **変数の初期化**:
   - `count = {}`: カードの値ごとに、これまで出現した回数を記録する辞書です。キーはカードの値、値はそのカードの出現回数です。
   - `res = 0`: 結果として、和が `100000` になるペアの組み合わせの数を保持します。

3. **メインループ**:
   - `for a in A`: リスト `A` 内のカードの値を一つずつ取り出して処理します。

   - **ペアをチェック**:
     - `if 100000 - a in count`: 現在のカード `a` に対して、和が `100000` になるカードが `count` 辞書に既に存在しているか確認します。もし存在すれば、そのカードとペアを組むことができるので、その出現回数分だけ結果 `res` に加算します。

   - **出現回数を更新**:
     - `if a in count`: すでにカード `a` が辞書に存在していれば、その出現回数を1増やします。
     - `else: count[a] = 1`: もしカード `a` が初めて出現した場合、辞書に追加し、その出現回数を1とします。

4. **結果の返却**:
   - ループを通じて見つけたペアの組み合わせの数を `res` として返します。

### 入力と処理の流れの例

**例：**
入力：`N = 6`
カードのリスト `A = [40000, 50000, 20000, 80000, 50000, 30000]`

1. 初期状態：
   - `count = {}` （空の辞書）
   - `res = 0` （ペアの数）

2. 各カードに対する処理：

   - **1枚目 (a = 40000)**:
     - `100000 - 40000 = 60000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1}` として、40000 の出現回数を 1 に設定します。

   - **2枚目 (a = 50000)**:
     - `100000 - 50000 = 50000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1, 50000: 1}` として、50000 の出現回数を 1 に設定します。

   - **3枚目 (a = 20000)**:
     - `100000 - 20000 = 80000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1, 50000: 1, 20000: 1}` として、20000 の出現回数を 1 に設定します。

   - **4枚目 (a = 80000)**:
     - `100000 - 80000 = 20000` が `count` に存在するため、`res` に `count[20000]` の値 1 を加算します。
     - `res = 1`
     - `count = {40000: 1, 50000: 1, 20000: 1, 80000: 1}` として、80000 の出現回数を 1 に設定します。

   - **5枚目 (a = 50000)**:
     - `100000 - 50000 = 50000` が `count` に存在するため、`res` に `count[50000]` の値 1 を加算します。
     - `res = 2`
     - `count = {40000: 1, 50000: 2, 20000: 1, 80000: 1}` として、50000 の出現回数を 2 に設定します。

   - **6枚目 (a = 30000)**:
     - `100000 - 30000 = 70000` が `count` にないため、ペアは作れません。
     - `count = {40000: 1, 50000: 2, 20000: 1, 80000: 1, 30000: 1}` として、30000 の出現回数を 1 に設定します。

3. **最終結果**:
   - `res = 2`（和が `100000` となるペアが 2 組存在）

### 処理内容のまとめ
このプログラムは、リスト `A` を一度だけループすることで、和が `100000` になるペアの数を効率的に計算します。`dict` を使って既に出現したカードの値を管理するため、ペアの検索とカウントを高速に行えます。全体の計算量は **O(N)** で、カードが最大 20 万枚あった場合でも非常に高速に動作します。

---
# 026

```python
def calc(n):
    res = 0
    for i in range(1, n+1):
        res += n/i
        print(res)
    return res

def main():
    N = int(input())
    print(calc(N))

if __name__ == "__main__":
    main()
```

例として、N = 5 の場合を考えてみます：

```python
def calc(n):
    res = 0
    for i in range(n, 0, -1):
        res += n/i
    return res
```

N=5 の場合、以下のように計算が進みます：

1. i = 5 のとき（最初のコイン）：
   res += 5/5 = 1
   説明：最初のコインを得る確率は 5/5 = 1（100%）です。期待コストは 1 ドルです。

2. i = 4 のとき（2 番目のコイン）：
   res += 5/4 = 1.25
   説明：2 番目の新しいコインを得る確率は 4/5 です。期待コストは 5/4 = 1.25 ドルです。
   （平均して 1/(4/5) = 5/4 回の試行が必要）

3. i = 3 のとき（3 番目のコイン）：
   res += 5/3 ≈ 1.67
   説明：3 番目の新しいコインを得る確率は 3/5 です。期待コストは 5/3 ≈ 1.67 ドルです。
   （平均して 1/(3/5) = 5/3 回の試行が必要）

4. i = 2 のとき（4 番目のコイン）：
   res += 5/2 = 2.5
   説明：4 番目の新しいコインを得る確率は 2/5 です。期待コストは 5/2 = 2.5 ドルです。
   （平均して 1/(2/5) = 5/2 回の試行が必要）

5. i = 1 のとき（最後のコイン）：
   res += 5/1 = 5
   説明：最後のコインを得る確率は 1/5 です。期待コストは 5/1 = 5 ドルです。
   （平均して 1/(1/5) = 5 回の試行が必要）

最終的な res ≈ 11.42

この説明方法では、各ステップで新しいコインを得る確率が徐々に減少し、それに伴って期待コストが増加していく様子がよりわかりやすくなります。最初は簡単に新しいコインを得られますが、残りのコインが少なくなるにつれて、特定の新しいコインを得るのが難しくなっていきます。

この合計約 11.42 ドルが、5 種類全てのコインを集めるのに必要な総期待コストとなります。実際の試行では運によって変動しますが、長期的に見ればこの平均値に収束します。

---

# 027

### マージソートの基本的な考え方:

1. 大きな問題を小さな問題に分割する
2. 小さな問題を解決する
3. 小さな問題の解決結果を組み合わせて、大きな問題の解決につなげる

### 具体的な手順:

1. 配列を半分に分ける
2. 分けた半分をさらに半分に分ける（要素が 1 つになるまで繰り返す）
3. 1 つの要素になったら、それらをペアにしてマージ（結合）しながら並べ替える
4. マージを繰り返して、最終的に全体がソートされた 1 つの配列になる

この解説では、コードの動作を一つひとつ丁寧に説明し、実際の配列を使ってマージソートの処理の流れをステップバイステップで解説していきます。**初心者でも理解できるように**、なるべく具体的な数値例を交えて解説します。

### コードの全体の流れ
- このプログラムは、**マージソート**アルゴリズムを使って配列を昇順に並べ替えるためのものです。入力として与えられた数値のリストを再帰的に分割し、最終的にソート済みのリストとして結合する仕組みです。

### 1. `merge_sort` 関数の解説

```python
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
```
- **役割**: この関数は入力された配列をソートするためのメイン部分です。マージソートは**分割統治法**と呼ばれる手法を使います。配列を小さく分割して、最終的にそれらをソートしながらマージします。
- **処理内容**: 最初に配列の長さをチェックします。もし配列が1個以下（要素が0個または1個）であれば、すでにソート済みなので、そのまま配列を返します。

#### 事例
入力配列 `[658, 299, 47, 507, 122]` では、長さが5なので、分割を続けます。

```python
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
```
- **処理内容**: 配列の中央（`mid`）を計算し、左側と右側に分割します。その後、それぞれの部分に対して再帰的に`merge_sort`を呼び出して、さらに細かく分割します。

#### 事例
配列 `[658, 299, 47, 507, 122]` では、`mid = 5 // 2 = 2` なので、次のように分割されます。
- 左側: `[658, 299]`
- 右側: `[47, 507, 122]`

この分割された配列についても再帰的に同様の処理を行います。

```python
    return merge(left, right)
```
- **処理内容**: 左右それぞれがソートされた後、`merge` 関数でマージして1つのソート済み配列を作ります。

### 2. `merge` 関数の解説

```python
def merge(left, right):
    res = []
    i = j = 0
```
- **役割**: `merge` 関数は、ソートされた2つの配列を一つにまとめる役割を担っています。2つのリスト `left` と `right` の要素を比較しながら、昇順に結合します。
- **処理内容**: `res` は結果としてソートされた配列を格納するリスト、`i` と `j` はそれぞれ `left` と `right` の現在のインデックスです。

```python
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            res.append(left[i])
            i += 1
        else:
            res.append(right[j])
            j += 1
```
- **処理内容**: `left` と `right` の要素を1つずつ比較し、値の小さい方を `res` に追加していきます。そして、比較に使ったインデックスを進めます。
  - `left[i]` と `right[j]` を比較し、**小さい方の値**を結果リストに追加します。

#### 事例
- `left = [299, 658]` と `right = [47, 122, 507]` が入力された場合、以下のように処理が進みます：
  1. `299` と `47` を比較 → `47` を `res` に追加 → `res = [47]`
  2. `299` と `122` を比較 → `122` を追加 → `res = [47, 122]`
  3. `299` と `507` を比較 → `299` を追加 → `res = [47, 122, 299]`
  4. `658` と `507` を比較 → `507` を追加 → `res = [47, 122, 299, 507]`

```python
    res.extend(left[i:])
    res.extend(right[j:])
```
- **処理内容**: `left` または `right` のどちらかのリストが先に全て処理される場合があるので、残った方のリストの要素を全て `res` に追加します。

#### 事例
上記の比較の後、`left` の `658` がまだ残っているので、`res = [47, 122, 299, 507, 658]` となります。

```python
    return res
```
- **処理内容**: 結果としてソートされた配列 `res` を返します。

### 3. `main` 関数の解説

```python
def main():
    _ = int(input())
    A = list(map(int, input().split()))
    print(*merge_sort(A))
```
- **役割**: `main` 関数は、プログラムのエントリーポイントです。まず、最初に入力を受け取り、与えられた配列をソートして結果を出力します。
- **処理内容**:
  - 最初に、配列の長さを読み取ります（`_` は使われないので無視しています）。
  - 次に、`input().split()` を使って入力された配列をリスト `A` に変換します。
  - `merge_sort(A)` で配列をソートし、`print` で結果を表示します。

#### 事例
入力が `5`、`658 299 47 507 122` の場合：
- 配列 `A = [658, 299, 47, 507, 122]` となり、この配列が `merge_sort` に渡されます。
- 結果は `[47, 122, 299, 507, 658]` となり、それが出力されます。

---

### 処理の流れ（全体のステップバイステップの解説）

1. **最初の入力**として、`[658, 299, 47, 507, 122]` という配列が与えられます。
2. **`merge_sort`で分割**:
   - 配列を中央で分割し、`[658, 299]` と `[47, 507, 122]` に分かれます。
   - `[658, 299]` はさらに `[658]` と `[299]` に分割され、`[47, 507, 122]` は `[47]` と `[507, 122]` に分割されます。
3. **再帰的に分割**した結果、最小単位（1つの要素だけの配列）になります。これ以上分割できなくなったら、**マージ開始**。
4. **マージのステップ**:
   - `[658]` と `[299]` をマージして `[299, 658]` に。
   - `[507]` と `[122]` をマージして `[122, 507]` に。
   - `[47]` と `[122, 507]` をマージして `[47, 122, 507]` に。
5. 最後に、`[299, 658]` と `[47, 122, 507]` をマージして、**ソートされた最終結果** `[47, 122, 299, 507, 658]` が得られます。

---

### 結論
この説明では、事例を使いながら、各ステップで何が行われているかを明確に示しました。具体的な配列で再帰的な分割とマージの流れを確認することで、マージソートの仕組みがより直感的に理解できるはずです。


---

# 028

```python
def min_cost(N, h):
    dp = [0] * N
    dp[1] = abs(h[1] - h[0])
    for i in range(2, N):
        cost1 = dp[i-1] + abs(h[i] - h[i-1])
        cost2 = dp[i-2] + abs(h[i] - h[i-2])
        dp[i] = min(cost1, cost2)
    return dp[-1]

def main():
    N = int(input())
    h = list(map(int, input().split()))
    print(min_cost(N, h))

if __name__ == "__main__":
    main()
```

## カエルのジャンプ：最小コストを求めるプログラム解説

このプログラムは、カエルが足場をジャンプして進むときに、最小コストでゴールにたどり着く方法を見つけるためのものです。

### １. 全体の流れ

1. `main()`関数で、足場の数(`N`)と、各足場の高さ(`h`)を入力として受け取ります。
2. `min_cost(N, h)`関数を呼び出し、最小コストを計算します。
3. 計算結果（最小コスト）を表示します。

### 2. `min_cost` 関数の解説

この関数が、動的計画法を使って最小コストを計算する心臓部です。

#### 2.1. 変数

* **`dp`**: リストです。`dp[i]` は「足場 `i` に到達するまでの最小コスト」を保存します。
* **`cost1`**: 足場 `i-1` から足場 `i` にジャンプする場合のコストを一時的に保存します。
* **`cost2`**: 足場 `i-2` から足場 `i` にジャンプする場合のコストを一時的に保存します。

#### 2.2. 処理の流れ

1. **初期化**: `dp[0]` を `0` (最初の足場までのコストは0)、`dp[1]` を `abs(h[1] - h[0])` (最初の足場から2番目の足場へのコスト) で初期化します。
2. **最小コストの計算**: `for` 文を使って、2番目の足場から最後の足場まで順番に処理していきます。
    * 各足場 `i` に対して、
        * `cost1` に、足場 `i-1` からジャンプしてきた場合のコストを計算して代入します。
        * `cost2` に、足場 `i-2` からジャンプしてきた場合のコストを計算して代入します。
        * `dp[i]` に、`cost1` と `cost2` の小さい方を代入します。これで、足場 `i` に到達するまでの最小コストが記録されます。
3. **最小コストの返却**: すべての足場について計算が終わったら、最後の足場(`N-1`)に到達するまでの最小コスト(`dp[-1]`)を返します。

### 3. 事例を使った説明

例えば、足場の高さが `h = [30, 10, 60, 10, 60, 50]` の場合を考えます。

1. `dp` は最初は `[0, 20, 0, 0, 0, 0]` となります。(`dp[1]` は `abs(10-30) = 20`)
2. `i = 2` のとき:
    * `cost1 = dp[1] + abs(h[2] - h[1]) = 20 + abs(60 - 10) = 70`
    * `cost2 = dp[0] + abs(h[2] - h[0]) = 0 + abs(60 - 30) = 30`
    * `dp[2] = min(70, 30) = 30` となります。
3. `i = 3` のとき:
    * `cost1 = dp[2] + abs(h[3] - h[2]) = 30 + abs(10 - 60) = 80`
    * `cost2 = dp[1] + abs(h[3] - h[1]) = 20 + abs(10 - 10) = 20`
    * `dp[3] = min(80, 20) = 20` となります。
4. `i = 4` のとき:
    * `cost1 = dp[3] + abs(h[4] - h[3]) = 20 + abs(60 - 10) = 70`
    * `cost2 = dp[2] + abs(h[4] - h[2]) = 30 + abs(60 - 60) = 30`
    * `dp[4] = min(70, 30) = 30` となります。
5. `i = 5` のとき:
    * `cost1 = dp[4] + abs(h[5] - h[4]) = 30 + abs(50 - 60) = 40`
    * `cost2 = dp[3] + abs(h[5] - h[3]) = 20 + abs(50 - 10) = 60`
    * `dp[5] = min(40, 60) = 40` となります。
6. 最終的に `dp = [0, 20, 30, 20, 30, 40]` となり、`dp[-1] = 40` が最小コストとして返されます。

   ```python
   debug
   =========================== i : 2
   cost1(1) : 70
   cost2(0) : 30
   dp : [0, 20, 30, 0, 0, 0]
   =========================== i : 3
   cost1(2) : 80
   cost2(1) : 20
   dp : [0, 20, 30, 20, 0, 0]
   =========================== i : 4
   cost1(3) : 70
   cost2(2) : 30
   dp : [0, 20, 30, 20, 30, 0]
   =========================== i : 5
   cost1(4) : 40
   cost2(3) : 60
   dp : [0, 20, 30, 20, 30, 40]
   ```

### なぜ動的計画法を使うのか？
- 部分問題の再利用: 一度計算した部分問題（例えば、3番目の足場までの最小コスト）は、後の計算で再利用されます。
- 効率化: 全ての組み合わせを愚直に計算するよりも、大幅に計算量を減らすことができます。

### まとめ
このコードは、動的計画法というアルゴリズムを使って、カエルのジャンプ問題を効率的に解いています。
- dp配列: 各足場までの最小コストを記録
- ループ: 2つ前の足場と1つ前の足場からジャンプするコストを比較し、最小のコストを記録
- 最終的な答え: 最後の足場までの最小コストが答え

このコードは、一見複雑に見える問題を、構造化して解くための良い例です。<br>
計算量は O(N) で、N が最大10^5 でも十分に高速に処理できます。

---
# 029

このコードは、N 段の階段を1段または2段ずつ上がるときの、上がり方の数を計算することを目的としています。動的計画法（Dynamic Programming）というアルゴリズムを用いて、効率的に計算を行います。

### コードの詳細解説

#### `min_cost`関数

1. **リスト`dp`の初期化**:
    ```python
    dp = [0] * (N+1)
    ```
    - `dp`は長さ`N+1`のリストで、各インデックス`i`に対して`dp[i]`は`i`段目に到達する方法の数を表します。
    - 例えば、`N=4`の場合、`dp`は `[0, 0, 0, 0, 0]` となります。

2. **初期条件の設定**:
    ```python
    dp[0] = dp[1] = 1
    ```
    - `dp[0]`と`dp[1]`を1に設定します。これは、0段目と1段目に到達する方法がそれぞれ1通りであることを意味します。
    - 例えば、`N=4`の場合、`dp`は `[1, 1, 0, 0, 0]` となります。

3. **動的計画法による計算**:
    ```python
    for i in range(2, N+1):
        dp[i] = dp[i-1] + dp[i-2]
    ```
    - 2段目からN段目までの各段に対して、`dp[i]`を計算します。
    - `dp[i]`は、`dp[i-1]`（1段前から来る方法）と`dp[i-2]`（2段前から来る方法）の合計です。
    - 例えば、`N=4`の場合、以下のように計算されます:
        - `i=2`: `dp[2] = dp[1] + dp[0] = 1 + 1 = 2` → `dp = [1, 1, 2, 0, 0]`
        - `i=3`: `dp[3] = dp[2] + dp[1] = 2 + 1 = 3` → `dp = [1, 1, 2, 3, 0]`
        - `i=4`: `dp[4] = dp[3] + dp[2] = 3 + 2 = 5` → `dp = [1, 1, 2, 3, 5]`

4. **結果の返却**:
    ```python
    return dp[-1]
    ```
    - `dp[-1]`（リストの最後の要素）を返します。これは、N段目に到達する方法の数です。
    - 例えば、`N=4`の場合、`dp[4]`は5なので、5が返されます。

#### `main`関数

1. **標準入力からNを読み込む**:
    ```python
    N = int(input())
    ```
    - ユーザーから入力された値を整数として読み込みます。

2. **`min_cost`関数を呼び出し、結果を出力**:
    ```python
    print(min_cost(N))
    ```
    - `min_cost`関数を呼び出し、その結果を出力します。

#### エントリーポイント

1. **スクリプトのエントリーポイント**:
    ```python
    if __name__ == "__main__":
        main()
    ```
    - このスクリプトが直接実行された場合に`main`関数を呼び出します。

### 処理内容の過程

入力例として、N=4の場合をもう少し詳しく見てみましょう。

1. **初期化**:
    - `dp`リストを初期化します: `dp = [0, 0, 0, 0, 0]`
    - `dp[0]`と`dp[1]`を1に設定します: `dp = [1, 1, 0, 0, 0]`

2. **動的計画法による計算**:
    - `i=2`のとき、`dp[2] = dp[1] + dp[0] = 1 + 1 = 2`: `dp = [1, 1, 2, 0, 0]`
    - `i=3`のとき、`dp[3] = dp[2] + dp[1] = 2 + 1 = 3`: `dp = [1, 1, 2, 3, 0]`
    - `i=4`のとき、`dp[4] = dp[3] + dp[2] = 3 + 2 = 5`: `dp = [1, 1, 2, 3, 5]`

3. **結果の返却**:
    - `dp[-1]`（`dp[4]`）を返します。これは5です。

つまり、N=4の場合、0段目から4段目まで移動する方法は5通りあります。


---
# 030

## ナップサック問題の Python コード解説

### コード全体の説明

このコードは、**ナップサック問題**と呼ばれる、与えられた複数の品物の中から、ナップサックの容量を超えない範囲で、価値の総和を最大にする組み合わせを選ぶ問題を解くための Python プログラムです。

**動的計画法**と呼ばれるアルゴリズムを用いて、効率的に解いています。

### 各部分の解説

#### `knapsack`関数

- **引数:**
  - `N`: 品物の数
  - `W`: ナップサックの容量
  - `items`: 各品物の重さと価値のタプルのリスト
- **処理:**
  - `dp`リスト: 長さが`W+1`のリストを作成し、`dp[i]`に容量`i`のナップサックに入れられる品物の価値の最大値を格納します。
  - 重複ループ:
    - 外側のループ: 各品物`w, v`について処理します。
    - 内側のループ: 容量`j`について、品物`w`を入れる場合と入れない場合で、価値の大きい方を`dp[j]`に更新します。
      - `dp[j-w] + v`: 品物`w`を入れる場合の価値
      - `dp[j]`: 品物`w`を入れない場合の価値
  - `return dp[W]`: 最終的に、容量`W`のナップサックに入れられる品物の価値の最大値を返します。

#### `main`関数

- **入力:**
  - `N`, `W`: 品物の数とナップサックの容量を入力
  - `items`: 各品物の重さと価値を入力し、タプルのリストに格納
- **処理:**
  - `knapsack`関数を呼び出し、結果を出力

**ポイント:**

- **動的計画法:** 一度求めた部分問題の解を保存しておき、後から再利用することで、計算量を削減する手法です。
- **DP テーブル:** `dp`リストは、動的計画法で計算結果を保存するための表（テーブル）のような役割を果たします。
- **状態遷移:** 内側のループで、現在の状態（容量`j`）から、一つ前の状態（容量`j-w`）への遷移を考え、価値を更新しています。

**具体例**

- バッグの耐久重量(W) = 8
- 品物(N) = 3 個
  1. 重さ 3, 価値 30
  2. 重さ 4, 価値 50
  3. 重さ 5, 価値 60

1. `knapsack` 関数:

   - `dp`リストを作ります。これは「重さ j のバッグで得られる最大価値」を記録します。
   - 初期状態: `dp = [0, 0, 0, 0, 0, 0, 0, 0, 0]` (インデックス 0 から 8 まで)

2. 品物を 1 つずつ確認していきます:

   品物 1 (重さ 3, 価値 30):

   - 重さ 8 から 3 まで逆順に確認
   - `dp[8] = max(0, 0+30) = 30`
   - `dp[7] = max(0, 0+30) = 30`
   - `dp[6] = max(0, 0+30) = 30`
   - `dp[5] = max(0, 0+30) = 30`
   - `dp[4] = max(0, 0+30) = 30`
   - `dp[3] = max(0, 0+30) = 30`
   - 結果: `dp = [0, 0, 0, 30, 30, 30, 30, 30, 30]`

   品物 2 (重さ 4, 価値 50):

   - `dp[8] = max(30, 30+50) = 80`
   - `dp[7] = max(30, 30+50) = 80`
   - `dp[6] = max(30, 0+50) = 50`
   - `dp[5] = max(30, 0+50) = 50`
   - `dp[4] = max(30, 0+50) = 50`
   - 結果: `dp = [0, 0, 0, 30, 50, 50, 50, 80, 80]`

   品物 3 (重さ 5, 価値 60):

   - `dp[8] = max(80, 30+60) = 90`
   - `dp[7] = max(80, 0+60) = 80`
   - `dp[6] = max(50, 0+60) = 60`
   - `dp[5] = max(50, 0+60) = 60`
   - 結果: `dp = [0, 0, 0, 30, 50, 60, 60, 80, 90]`

3. 最終的に `dp[8] = 90` が答えになります。これは、重さ 8 のバッグで得られる最大価値が 90 であることを意味します。

`main` 関数は入力を受け取り、`knapsack` 関数を呼び出して結果を出力します。

このアルゴリズムの特徴は、各品物について一度だけ処理を行い、かつメモリ使用量を最小限に抑えている点です。これにより、効率的に問題を解決できます。

### [補足] dp[j] = max(dp[j], dp[j-w]+v) の解説

この部分が一番重要な箇所なので、落ち着いて理解していきましょう！

**状況:**

* `dp[j]` は「ナップサックの容量が `j` の時に実現できる価値の最大値」を格納していくためのリストです。
* 今、重さ `w`、価値 `v` の品物を新たに検討しようとしています。

**この処理が意味すること:**

1. `dp[j]` は、この品物を **入れる前** の、容量 `j` で実現できる最大価値を保持しています。
2. `dp[j-w]+v` は、この品物を **入れる** ことを考えた場合の価値です。
    * まず、`j-w` は「新しい品物を **入れる** ために残しておくべき容量」です。
    * `dp[j-w]` は「その残しておいた容量で実現できる最大価値」です。
    * そこに、新しく入れる品物の価値 `v` を足せば、 **新しい品物を入れた場合の価値** が計算できます。

つまり、`dp[j] = max(dp[j], dp[j-w]+v)` は、

* **「新しい品物を入れない場合」と「入れる場合」の価値を比較し、より価値の高い方を選択する**

という処理を意味しています。

**具体例で確認:**

`items = [(3, 30), (4, 50), (5, 60)]` で、ナップサックの容量 `W = 8` の場合を考えます。

1. `(3, 30)` の品物を検討する段階で、`j = 5` の時を考えてみましょう。
    * `dp[5]` は現時点では `0` です (まだ何も入れていない)。
    * `dp[j-w] = dp[2]` も `0` です。
    * `dp[j-w] + v = 0 + 30 = 30` となります。
    * `max(0, 30) = 30` なので、`dp[5]` は `30` に更新されます。

2. 次に `(4, 50)` を検討する段階で、再び `j = 5` の時を考えます。
    * `dp[5]` は `30` です ((3, 30) を入れた場合の価値が残っている)。
    * `dp[j-w] = dp[1]` は `0` です。
    * `dp[j-w] + v = 0 + 50 = 50` となります。
    * `max(30, 50) = 50` なので、`dp[5]` は `50` に更新されます。

このように、各品物、各容量について「入れるか入れないか」の選択を比較し、`dp` リストを更新していくことで、最終的に `dp[W]` には「ナップサックの容量 `W` で実現できる最大価値」が格納されることになります。

**ポイント:**

* `j` のループが `W` から降順になっているのは、同じ品物を複数回使わないようにするためです。
* 各品物について `dp` リスト全体を更新していくことで、あらゆる組み合わせを効率的に探索しています。

この解説で、`dp[j] = max(dp[j], dp[j-w]+v)` の部分が少しでもクリアになれば幸いです！


---

# 031

### コード全体の流れ

このプログラムは、太郎君が夏休み中に勉強をして得られる最大の実力値を計算します。太郎君は 2 日連続で勉強しないという制約があるため、各日の実力値を考慮しつつ最大値を求める必要があります。

### コードの説明

まずは、具体例として入力例を考えます。

#### 例:

- 日数 `N = 5`
- 各日の実力値 `A = [2, 5, 3, 3, 1]`

### 関数 `dp(N, A)` の説明

```python
def dp(N, A):
    dp = [0] * (N+1)
    dp[1] = A[0]
    for i in range(2, N+1):
        dp[i] = max(dp[i-1], dp[i-2] + A[i-1])
    return dp[-1]
```

#### ステップ 1: 初期化

1. **`dp = [0] * (N+1)`**:

   - `dp`リストを初期化します。このリストは`N+1`個の要素を持ち、全て 0 で初期化されています。
   - `dp[i]`は、`i`日目までの間に得られる最大の実力値を保持します。

   例えば、`N = 5`の場合、最初に作られるリストは次のようになります:

   ```python
   dp = [0, 0, 0, 0, 0, 0]
   ```

2. **`dp[1] = A[0]`**:

   - 1 日目に勉強した場合の実力値を設定します。`dp[1]`に`A[0]`を代入します。
   - `dp[1] = 2`となります。

   この時点で`dp`リストは次のようになります:

   ```python
   dp = [0, 2, 0, 0, 0, 0]
   ```

#### ステップ 2: 動的計画法による計算

3. **`for i in range(2, N+1):`**:

   - 2 日目から N 日目までの各日について計算します。

4. **`dp[i] = max(dp[i-1], dp[i-2] + A[i-1])`**:

   - `dp[i-1]`は、`i-1`日目までの最大の実力値を意味します。これは、`i`日目に勉強しない場合の実力値です。
   - `dp[i-2] + A[i-1]`は、`i-2`日目までの最大の実力値に`i`日目の実力値を加えたものです。これは、`i`日目に勉強する場合の実力値です。
   - より大きな値を`dp[i]`に保存します。

   実際の計算を見てみましょう。

   - `i = 2` の場合:

     - `dp[2] = max(dp[1], dp[0] + A[1]) = max(2, 0 + 5) = 5`
     - `dp = [0, 2, 5, 0, 0, 0]`

   - `i = 3` の場合:

     - `dp[3] = max(dp[2], dp[1] + A[2]) = max(5, 2 + 3) = 5`
     - `dp = [0, 2, 5, 5, 0, 0]`

   - `i = 4` の場合:

     - `dp[4] = max(dp[3], dp[2] + A[3]) = max(5, 5 + 3) = 8`
     - `dp = [0, 2, 5, 5, 8, 0]`

   - `i = 5` の場合:
     - `dp[5] = max(dp[4], dp[3] + A[4]) = max(8, 5 + 1) = 8`
     - `dp = [0, 2, 5, 5, 8, 8]`

#### ステップ 3: 最終的な実力値の取得

5. **`return dp[-1]`**:
   - `dp[-1]`（つまり`dp[5]`）を返します。これが太郎君が得られる最大の実力値です。
   - この例では、結果は `8` となります。

### 全体の流れをまとめると:

- 入力として`N`日分の実力値リスト`A`を受け取ります。
- `dp()`関数で動的計画法を用いて、太郎君が 2 日連続で勉強しないという制約のもとで、得られる最大の実力値を計算します。
- その結果を出力します。今回の例では、答えは`8`となります。

<br>
<br>

---
# 033

このコードは、2次元平面上にある点 `A` と線分 `BC` 上の最短距離を計算するものです。いくつかのサポート関数を使って、処理を分かりやすく、また再利用可能にしています。それぞれの関数の役割と処理の流れを、例を使って解説します。

## 点と線分の距離：数式を用いた詳細解説とコードの仕組み

このコードは、平面上に存在する点と線分の最短距離を求めるためのものです。以下では、数式を交えながらコードの解説を行います。

**問題設定**

2次元平面上に点Aと線分BCが存在するとします。点Aの座標を $(a_x, a_y)$ 、点Bの座標を $(b_x, b_y)$ 、点Cの座標を $(c_x, c_y)$ とします。

**目標**

点Aと線分BC間の最短距離を求めます。

**1. ベクトル計算の準備**

まず、点A, B, C を使って、以下の4つのベクトルを計算します。

* $\overrightarrow{BA} = (a_x - b_x, a_y - b_y)$
* $\overrightarrow{BC} = (c_x - b_x, c_y - b_y)$
* $\overrightarrow{CA} = (a_x - c_x, a_y - c_y)$
* $\overrightarrow{CB} = (b_x - c_x, b_y - c_y)$

**2. 最短距離になる点を探す**

点Aから線分BCへ垂線を下ろし、その足を点Hとします。この点Hこそが、点Aから線分BCへの最短距離を与える点となります。

**3. 点Hの位置で場合分け**

**ケース1：点Hが線分BCの外側で、点B寄りにある場合**

* この時、点Bと点Aを結ぶ線分が最短距離になります。
* $\overrightarrow{BA}$ と $\overrightarrow{BC}$ の内積が負になる、すなわち $\overrightarrow{BA} \cdot \overrightarrow{BC} < 0$ という条件で判別できます。
* この場合、最短距離は点Aと点Bの距離なので、以下のユークリッド距離の公式を用いて計算できます。
    * $\text{距離} = \sqrt{(a_x - b_x)^2 + (a_y - b_y)^2}$

**ケース2：点Hが線分BCの外側で、点C寄りにある場合**

* この時、点Cと点Aを結ぶ線分が最短距離になります。
*  $\overrightarrow{CA}$ と $\overrightarrow{CB}$ の内積が負になる、すなわち $\overrightarrow{CA} \cdot \overrightarrow{CB} < 0$ という条件で判別できます。
* この場合、最短距離は点Aと点Cの距離なので、以下のユークリッド距離の公式を用いて計算できます。
    * $\text{距離} = \sqrt{(a_x - c_x)^2 + (a_y - c_y)^2}$

**ケース3：点Hが線分BC上にある場合**

* この時、点Hと点Aを結ぶ線分が最短距離になります。
* 上記2つのケース以外の場合に該当します。

**点Hの座標を求める**

点Hは線分BC上の点なので、ベクトル $\overrightarrow{BC}$ を用いて以下のように表せます。

$$
\overrightarrow{OH} = \overrightarrow{OB} + t\overrightarrow{BC} \quad (0 \le t \le 1)
$$

ここで、 $\overrightarrow{OH}$ は原点Oから点Hへのベクトル、 $\overrightarrow{OB}$ は原点Oから点Bへのベクトルを表し、 $t$ は線分BCに対する点Hの位置を表すパラメータです。 $t$ が0のとき点Hは点Bと一致し、 $t$ が1のとき点Hは点Cと一致します。

**t の求め方**

点Hは垂線の足なので、 $\overrightarrow{AH}$ と $\overrightarrow{BC}$ は直交します。つまり、内積が0になります。

$$
\overrightarrow{AH} \cdot \overrightarrow{BC} = 0
$$

$\overrightarrow{AH} = \overrightarrow{OH} - \overrightarrow{OA}$ 、 $\overrightarrow{OH} = \overrightarrow{OB} + t\overrightarrow{BC}$ を代入して展開すると、

$$
(\overrightarrow{OB} + t\overrightarrow{BC} - \overrightarrow{OA}) \cdot \overrightarrow{BC} = 0
$$

$$
t = \frac{(\overrightarrow{OA} - \overrightarrow{OB}) \cdot \overrightarrow{BC}}{\overrightarrow{BC} \cdot \overrightarrow{BC}} =  \frac{\overrightarrow{BA} \cdot \overrightarrow{BC}}{\overrightarrow{BC} \cdot \overrightarrow{BC}}
$$

このようにして、 $t$ を求めることができます。

**点Hの座標の算出**

$t$ が求まれば、点Hの座標 $(h_x, h_y)$ は以下のようになります。

$$
h_x = b_x + t(c_x - b_x)
$$

$$
h_y = b_y + t(c_y - b_y)
$$

**最短距離の計算**

点Hの座標が求まれば、点Aと点Hの距離、すなわち最短距離はユークリッド距離の公式を用いて計算できます。

$$
\text{距離} = \sqrt{(a_x - h_x)^2 + (a_y - h_y)^2}
$$


**コードの解説**

```python
import numpy as np
import math

def vector_subtract(v1, v2):
    return [v1[0] - v2[0], v1[1] - v2[1]]

def distance(p1, p2):
    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)

def shortest_distance(A, B, C):
    BA = vector_subtract(A, B) # ベクトルBA
    BC = vector_subtract(C, B) # ベクトルBC
    CA = vector_subtract(A, C) # ベクトルCA
    CB = vector_subtract(B, C) # ベクトルCB

    if np.dot(BA, BC) < 0: # ケース1: 点Hが点Bの外側
        nearest = B
    elif np.dot(CA, CB) < 0: # ケース2: 点Hが点Cの外側
        nearest = C
    else: # ケース3: 点Hが線分BC上
        t = np.dot(BA, BC) / np.dot(BC, BC) # tの計算
        nearest = [B[0] + t * BC[0], B[1] + t * BC[1]] # 点Hの座標

    return distance(A, nearest) # 最短距離の計算
```

### 各関数の解説

1. **`vector_subtract(v1, v2)`**
   - これは、2つのベクトル（2次元座標のリスト）の減算を行う関数です。例えば、ベクトル `v1 = [x1, y1]` からベクトル `v2 = [x2, y2]` を引くと、`[x1 - x2, y1 - y2]` を返します。
   - ベクトルの減算は、点と点の相対的な位置（方向や長さ）を求めるために使います。

2. **`distance(p1, p2)`**
   - この関数は、2点間のユークリッド距離を計算します。距離公式は次の通りです： <br>
     $\text{distance} = \sqrt{(x2 - x1)^2 + (y2 - y1)^2}$
   - これにより、2点の座標間の直線距離を計算できます。

3. **`shortest_distance(A, B, C)`**
   - この関数は、点 `A` から線分 `BC` への最短距離を計算します。処理の流れは以下の通りです。
   - まず、点 `A`、`B`、`C` を基準にベクトル `BA`（BからAへのベクトル）、`BC`（BからCへのベクトル）、`CA`（CからAへのベクトル）などを計算します。
   - 内積 (`np.dot`) を使って、点 `A` が線分 `BC` の範囲内にあるかどうかを判定します。これにより、最短距離がどう決まるかが決定されます。

4. **`main()`**
   - 標準入力から、点 `A`、`B`、`C` の座標を受け取り、それらをリストとして格納し、最短距離を計算する `shortest_distance` 関数に渡して結果を出力します。


### 具体的な事例での処理内容の説明

#### 例1:
```
入力:
A = [0, 5]
B = [1, 1]
C = [3, 0]
```

1. **ベクトルの計算**
   - ベクトル `BA` を計算します。`B = [1, 1]` から `A = [0, 5]` を引くと、
     ```
     BA = [0 - 1, 5 - 1] = [-1, 4]
     ```
   - 同様に、ベクトル `BC` を計算します。
     ```
     BC = [3 - 1, 0 - 1] = [2, -1]
     ```
   - このようにして、`BA` と `BC` が計算されました。

2. **内積計算**
   - ベクトル `BA` と `BC` の内積を計算します。内積とは、ベクトルの「方向」を比較する指標で、次のように計算されます。
     ```
     np.dot(BA, BC) = (-1 * 2) + (4 * -1) = -2 - 4 = -6
     ```
   - 内積が負であるため、点 `A` は線分 `BC` の範囲外、点 `B` 側にあることが分かります。

3. **最短距離の計算**
   - この場合、内積が負であるため、点 `A` から点 `B` への距離が最短になります。
   - 距離を計算するために、関数 `distance(A, B)` を使います。
     ```
     distance(A, B) = sqrt((0 - 1)^2 + (5 - 1)^2) = sqrt(1 + 16) = sqrt(17) ≈ 4.123105625618
     ```
   - このようにして、`A` と `B` の距離が最短距離として返されます。

---

### もう一つの例:
```
入力:
A = [-40, -30]
B = [-50, -10]
C = [-20, -20]
```

1. **ベクトルの計算**
   - `BA` と `BC` を計算します。
     ```
     BA = [-40 - (-50), -30 - (-10)] = [10, -20]
     BC = [-20 - (-50), -20 - (-10)] = [30, -10]
     ```

2. **内積計算**
   - `np.dot(BA, BC)` を計算します。
     ```
     np.dot(BA, BC) = (10 * 30) + (-20 * -10) = 300 + 200 = 500
     ```
   - 内積が正なので、次に進みます。
   - `BC` の長さの2乗は、
     ```
     np.dot(BC, BC) = 30^2 + (-10)^2 = 900 + 100 = 1000
     ```

3. **射影点の計算**
   - `t` を計算します。
     ```
     t = np.dot(BA, BC) / np.dot(BC, BC) = 500 / 1000 = 0.5
     ```
   - これにより、射影点 `nearest` を計算します。
     ```
     nearest = [-50 + 0.5 * 30, -10 + 0.5 * (-10)] = [-50 + 15, -10 - 5] = [-35, -15]
     ```

4. **最短距離の計算**
   - 射影点 `nearest = [-35, -15]` と点 `A = [-40, -30]` との距離を計算します。
     ```
     distance(A, nearest) = sqrt((-40 - (-35))^2 + (-30 - (-15))^2) = sqrt((-5)^2 + (-15)^2) = sqrt(25 + 225) = sqrt(250) ≈ 15.811388300842
     ```

このようにして、`A` から線分 `BC` までの最短距離が計算されます。

---

### まとめ

- **内積の役割**: 点 `A` が線分 `BC` 上のどの位置にあるかを判定するために内積を使用しています。内積が負なら点 `A` は `B` 側にあり、正なら線分 `BC` 上に射影されるか、`C` 側にあります。
- **射影点の計算**: 射影点が線分 `BC` 上にある場合、その点までの距離が最短となります。射影点は `t` を使って計算します。
- **距離計算**: 距離の計算にはユークリッド距離公式を使っており、A と最も近い点（B、C、または射影点）との距離が最短距離として計算されます。

<br>
<br>

---
# 034

### コードの解説

このコードでは、2次元平面上の複数の点の中で、最も近い2つの点の間の距離を計算しています。主な手順として、以下の3つの関数とロジックが含まれています。

1. **`distance(p1, p2)` 関数**：
   - 2つの点 `p1` と `p2` の間のユークリッド距離を計算する関数です。
   - ユークリッド距離は次の式に基づいています：
    <br>&nbsp;&nbsp;&nbsp;&nbsp;
     $d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$
   - `p1[0]` と `p2[0]` がそれぞれ x 座標、`p1[1]` と `p2[1]` がそれぞれ y 座標です。

2. **`find_min_distance(points)` 関数**：
   - 与えられた点のリスト `points` の中で、最も近い2点の距離を求める関数です。
   - まず、非常に大きな初期値 `float('Inf')` を最小距離として設定します。次に、全ての点のペアを二重ループで調べ、距離を計算します。計算した距離が現在の最小距離よりも小さい場合は、その距離を最小距離として更新します。

3. **`main()` 関数**：
   - プログラムのメイン部分です。
   - 最初に、標準入力から点の数 `N` を読み込み、その後、`N` 個の点の座標を受け取ります。受け取った点のリスト `points` を `find_min_distance` 関数に渡して、最も近い2点の距離を計算し、その結果を表示します。

### 処理の流れ

1. **入力の受け取り**:
   - 点の数 `N` を受け取ります。次に、`N` 個の点の座標を標準入力から受け取って、それをリストに格納します。

2. **最小距離の計算**:
   - 点のリストの中から、全ての点のペアを組み合わせて、それぞれの距離を計算します。計算された距離が最小距離よりも小さい場合は、その距離を更新します。

3. **結果の出力**:
   - 最も近い2点の距離を出力します。

### 具体的な事例を使った処理の過程

例えば、次のような入力があったとします：

```
4
0 1
2 0
2 3
3 1
```

1. **`main()` 関数の実行**：
   - 点の数 `N = 4` と点の座標 `[(0, 1), (2, 0), (2, 3), (3, 1)]` を受け取ります。

2. **`find_min_distance(points)` 関数の実行**：
   - `min_distance` を初期化します (`float('Inf')`)。
   - すべての点のペアの距離を計算します：

   | 点のペア               | 距離計算 (ユークリッド距離)                                  | 距離                     |
   |----------------------|------------------------------------------------------------|--------------------------|
   | (0, 1) と (2, 0)     | \( $\sqrt{(2-0)^2 + (0-1)^2} = \sqrt{4 + 1} = \sqrt{5}$ \)   | 約 2.236                  |
   | (0, 1) と (2, 3)     | \( $\sqrt{(2-0)^2 + (3-1)^2} = \sqrt{4 + 4} = \sqrt{8}$ \)   | 約 2.828                  |
   | (0, 1) と (3, 1)     | \( $\sqrt{(3-0)^2 + (1-1)^2} = \sqrt{9 + 0} = \sqrt{9}$ \)   | 3                        |
   | (2, 0) と (2, 3)     | \( $\sqrt{(2-2)^2 + (3-0)^2} = \sqrt{0 + 9} = \sqrt{9}$ \)   | 3                        |
   | (2, 0) と (3, 1)     | \( $\sqrt{(3-2)^2 + (1-0)^2} = \sqrt{1 + 1} = \sqrt{2}$ \)   | 約 1.414                  |
   | (2, 3) と (3, 1)     | \( $\sqrt{(3-2)^2 + (1-3)^2} = \sqrt{1 + 4} = \sqrt{5}$ \)   | 約 2.236                  |

   - 最も近い2点は `(2, 0)` と `(3, 1)` で、距離は約 1.414 です。

3. **結果の出力**：
   - 最小距離である `1.414213562373` が出力されます。

### まとめ
このプログラムは、2次元平面上の複数の点から最も近い2つの点の距離を求めます。`find_min_distance()` 関数で全ての点のペアの距離を計算し、最小距離を見つけます。事例を用いて処理の流れを説明すると、プログラムがどのように点のペアごとに距離を計算して、最も近い点の距離を更新していくかが理解しやすくなります。

<br>
<br>

---
# 035

[参考] 2つの円の位置関係<br>
https://manabitimes.jp/math/745

このコードは、2 つの円の位置関係を判定するプログラムです。具体的には、与えられた 2 つの円の半径と中心座標から、以下の 5 つの位置関係のいずれかに分類し、その番号を出力します。

1. 一方の円が他方の円を完全に含み、2 つの円は接していない
2. 一方の円が他方の円を完全に含み、2 つの円は接している
3. 2 つの円が互いに交差する
4. 2 つの円の内部に共通部分は存在しないが、2 つの円は接している
5. 2 つの円の内部に共通部分は存在せず、2 つの円は接していない


プログラムの特徴と動作について詳細に説明します。

### コードの構成と解説

1. **モジュールのインポート**
   ```python
   import math
   ```
   - `math`モジュールをインポートしています。これは、数学的な関数を使うためです。ここでは、特にユークリッド距離を計算するための平方根関数 `math.sqrt` を使用しています。

2. **関数 `check_circle_position`**
   ```python
   def check_circle_position(r1, r2, d):
       if d < abs(r1 - r2):
           return 1
       elif d == abs(r1 - r2):
           return 2
       elif abs(r1 - r2) < d < r1 + r2:
           return 3
       elif d == r1 + r2:
           return 4
       elif d > r1 + r2:
           return 5
       else:
           return None
   ```
   - **引数**: 2つの円の半径 `r1` と `r2`、および円の中心間の距離 `d` を受け取ります。
   - **判定処理**:
     - `d < abs(r1 - r2)`: <br>&nbsp;&nbsp;&nbsp;
     一方の円が他方を完全に含んでいる状態で接していない場合。この場合、1を返します。
     - `d == abs(r1 - r2)`:<br>&nbsp;&nbsp;&nbsp;
     一方の円が他方を完全に含み、ちょうど接している場合。この場合、2を返します。
     - `abs(r1 - r2) < d < r1 + r2`: <br>&nbsp;&nbsp;&nbsp;
     2つの円が交差している場合。この場合、3を返します。
     - `d == r1 + r2`: <br>&nbsp;&nbsp;&nbsp;
     2つの円が外側でちょうど接している場合。この場合、4を返します。
     - `d > r1 + r2`: <br>&nbsp;&nbsp;&nbsp;
     2つの円が全く交差せず、離れている場合。この場合、5を返します。
   - **返り値**: 位置関係を示す番号を返します。

3. **関数 `main`**
   ```python
   def main():
       x1, y1, r1 = map(int, input().split())
       x2, y2, r2 = map(int, input().split())
       d = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
       print(check_circle_position(r1, r2, d))
   ```
   - **入力の取得**:
     - 2つの円の中心座標 `(x1, y1)` と `(x2, y2)`、および半径 `r1` と `r2` を標準入力から取得します。
     - `map(int, input().split())` を使ってスペース区切りの整数として入力を取得します。
   - **距離の計算**:
     - `d = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)` は2つの円の中心間の距離をユークリッド距離として計算します。

$$
d = \sqrt{(x1 - x2)^2 + (y1 - y2)^2}
$$

   - **位置関係の判定**:
     - `check_circle_position` 関数を呼び出して、返された位置関係の番号を出力します。

### 処理過程の具体例

#### 事例1:
入力:
```
4 1 2
1 5 3
```
- **ステップ1**: 円1の中心座標は `(4, 1)`、半径は `2`。円2の中心座標は `(1, 5)`、半径は `3`。
- **ステップ2**: 中心間の距離 `d` を計算します。

$$
d = \sqrt{(4 - 1)^2 + (1 - 5)^2} = \sqrt{9 + 16} = \sqrt{25} = 5
$$

- **ステップ3**: 判定の流れ
  - 半径の差: `|r1 - r2| = |2 - 3| = 1`
  - 半径の和: `r1 + r2 = 2 + 3 = 5`
  - 距離 `d = 5` は半径の和と等しいので、4番目の状態、つまり「円が外接している」と判断されます。
  出力: `4`

#### 事例2:
入力:
```
1 1 6
3 3 2
```
- **ステップ1**: 円1の中心座標は `(1, 1)`、半径は `6`。円2の中心座標は `(3, 3)`、半径は `2`。
- **ステップ2**: 中心間の距離 `d` を計算します。

$$
d = \sqrt{(1 - 3)^2 + (1 - 3)^2} = \sqrt{4 + 4} = \sqrt{8} \approx 2.83
$$

- **ステップ3**: 判定の流れ
  - 半径の差: `|r1 - r2| = |6 - 2| = 4`
  - 半径の和: `r1 + r2 = 6 + 2 = 8`
  - 距離 `d ≈ 2.83` は半径の差 `4` より小さいため、1番目の状態、つまり「一方の円が他方を完全に含み、接していない」と判断されます。
  出力: `1`

### まとめ:
このコードは、2つの円の位置関係を計算して判定するシンプルなアルゴリズムです。中心間の距離をまず計算し、条件に基づいてその関係を判定していきます。数学的な概念（円の位置関係や座標間の距離）に基づいているので、初心者でも数式を理解しながらステップバイステップで追っていける内容になっています。

<br>
<br>

---
# 036

このコードでは、アナログ時計の時針と分針の端点の距離を三角関数を使って計算しています。これから、コードの全体的な流れ、使われている数式、そして具体的な事例を用いて解説します。

## 1. 基本アイデア

アナログ時計の時針と分針はそれぞれ異なる角速度で回ります。H時M分の時、時針と分針が作る角度を計算し、その角度を基にして2本の針の固定されていない端点間の距離を求めます。

三角形の3辺の長さと角度に関する関係を示す**余弦定理**を使って、距離を計算しています。

### 余弦定理とは
余弦定理は、任意の三角形の2辺とそれらの間の角度を用いて、残りの辺の長さを計算する方法です。

公式は次の通りです： $c^2 = a^2 + b^2 - 2ab \cdot \cos(\theta)$

ここで：
- $a$ と $b$ は、時針と分針の長さに相当します。
- $\theta$ は、時針と分針が作る角度です。
- $c$ は、2つの針の固定されていない端点間の距離（求めたい値）です。

### 解説コード

### `calc_distance(A, B, H, M)` 関数
1. **角度の計算**
   - `angle_H`: 時針の角度を計算します。時針は12時間で1周 (360度) します。したがって、H時の時針の角度は $360 \times \dfrac{H}{12}$ となります。また、M分が経過している場合は、時針が次の時間に少し進んでいるため、分針の進行を考慮して追加の角度を計算します。これが $30 \times \dfrac{M}{60}$ です。
   - `angle_M`: 分針の角度を計算します。分針は1時間で1周 (360度) するため、M分の角度は $360 \times \dfrac{M}{60}$ となります。

2. **時針と分針の角度差**
   - `angle_diff`: 時針と分針が作る角度の絶対値を計算します。もし、この角度差が180度を超える場合、時計回りでなく逆回り（短いほうの角度）を使うため、360 - angle_diff にして最短の角度差に修正します。

3. **角度をラジアンに変換**
   - `math.radians(angle_diff)`: 三角関数を使うためには、角度をラジアン（radians）に変換します。これはPythonの `math` モジュールで行います。

4. **余弦定理で距離を計算**
   - 余弦定理を使って、針の端点間の距離を計算します。<br>
   公式は <br>$\text{distance} = \sqrt{A^2 + B^2 - 2AB \cdot \cos(\theta)}$ です。<br>
   `math.cos(angle_rad)` で角度の余弦を求めています。

### `main()` 関数
- 標準入力から `A, B, H, M` の4つの値を受け取ります。
- `calc_distance` 関数を使って計算し、その結果を表示します。

## 2. 具体例を使った解説

### 入力例
```
3 4 9 0
```
- A = 3 cm (時針の長さ)
- B = 4 cm (分針の長さ)
- H = 9 時
- M = 0 分

#### ステップ 1: 時針の角度を計算する
時針は9時なので、基準角度は $360 \times \dfrac{9}{12} = 270^\circ$ です。分は0なので、時針は9時の場所にいます。したがって、`angle_H = 270`。

#### ステップ 2: 分針の角度を計算する
分針は0分なので、分針は12時の位置にあり、angle_M = $0^\circ$ です。

#### ステップ 3: 角度差を計算する
時針と分針の角度差は $|270 - 0| = 270^\circ$ ですが、この角度は180度を超えているので、逆方向を取るために $360 - 270 = 90^\circ$ に修正します。

#### ステップ 4: 距離の計算
余弦定理を適用します。角度 $90^\circ$ をラジアンに変換すると、 $\theta = \dfrac{\pi}{2}$ です。<br>
余弦の値は $\cos(90^\circ) = 0$ なので、余弦定理の式は次のようになります：<br>
$c^2 = 3^2 + 4^2 - 2 \times 3 \times 4 \times 0 = 9 + 16 = 25$ <br>
したがって、距離 $c = \sqrt{25} = 5$ です。

### 出力
```
5.0
```

## 3. まとめ

- **余弦定理**を使って、時針と分針の端点間の距離を計算しました。
- **角度の計算**では、時針と分針の進行角度を個別に計算し、それらの角度差を求めて短いほうの角度を使いました。
- **余弦定理の適用**により、時計の2本の針が形成する三角形から距離を求めています。

これにより、任意の時刻での時針と分針の端点間の距離を正確に計算できます。

<br>
<br>

---
# 037

このコードは、2 つの線分が平面上で交差するかどうかを判定するものです。<br>
以下に、各部分の詳細な解説と、その数学的背景について初心者向けに説明します。

## [前提] 数学

### 1. ベクトルと外積の基礎

#### 1.1 ベクトルとは
ベクトルとは、**大きさ**と**向き**を持つ量のことです。2次元平面上では、ある点から別の点までを結ぶ矢印として考えることができます。例えば、点A `(x1, y1)` から点B `(x2, y2)` へのベクトルは、次のように表されます。

- ベクトルAB = `(x2 - x1, y2 - y1)`

#### 1.2 外積とは
2次元のベクトルにおける**外積**は、2つのベクトルが作る面積や方向を示します。特に、外積を計算することで、あるベクトルが別のベクトルの**右側**にあるか、**左側**にあるか、または**同じ直線上**にあるかを判定できます。

- **外積の計算式**
  - ベクトル `A = (x1, y1)` とベクトル `B = (x2, y2)` の外積は次のように計算します。
  - 外積 = `x1 * y2 - x2 * y1`

#### 1.3 外積の結果が示す意味
- **外積 > 0** の場合、ベクトルBはベクトルAに対して**左側**にあります。
- **外積 < 0** の場合、ベクトルBはベクトルAに対して**右側**にあります。
- **外積 = 0** の場合、ベクトルAとベクトルBは**同じ直線上**にあります。

この外積の性質を使って、2つの線分が交差しているかどうかを判定します。

### 2. 2本の線分の交差判定

線分の交差判定では、次の点を確認します：
- 2本の線分が交差している場合、1本目の線分の両端の点が、2本目の線分に対して**反対側**に位置しているはずです。同様に、2本目の線分の両端も1本目に対して**反対側**にある必要があります。

具体的にどういうことか、図を想像してみてください。

#### 例：交差している場合
例えば、1本目の線分が `A-B`、2本目の線分が `C-D` とします。
- 線分ABの両端AとBに対して、点Cが左側に、点Dが右側にあるとき、この線分は交差している可能性があります。逆に、線分CDに対して、点Aが左側に、点Bが右側にある場合も交差が確認できます。

この**左右の判定**を外積を使って行います。

### 3. 外積を使った交差判定の詳細

#### 3.1 外積を使って線分の相対的な位置を調べる
外積を使って、次の4つの組み合わせを考えます。

1. 線分ABに対して、CとDがどちら側にあるか。
   - ベクトル `AB` とベクトル `AC` の外積 `cp1`
   - ベクトル `AB` とベクトル `AD` の外積 `cp2`

2. 線分CDに対して、AとBがどちら側にあるか。
   - ベクトル `CD` とベクトル `CA` の外積 `cp3`
   - ベクトル `CD` とベクトル `CB` の外積 `cp4`

これらの外積の符号を確認し、交差しているかを判定します。

#### 3.2 交差しているかの条件
- **線分ABの両端（AとB）が線分CDに対して反対側にある**（外積の符号が異なる）：
  - `cp1 * cp2 <= 0`
- **線分CDの両端（CとD）が線分ABに対して反対側にある**（外積の符号が異なる）：
  - `cp3 * cp4 <= 0`

この条件が両方とも満たされる場合、線分ABとCDは交差していると判断できます。

### 4. コードの流れと具体例

#### 例: 2本の線分が交差する場合
例えば、次の座標で2本の線分が交差しているとします。

- 線分AB: A(1, 1), B(4, 4)
- 線分CD: C(1, 4), D(4, 1)

この場合の処理を見てみましょう。

```python
A = [1, 1]
B = [4, 4]
C = [1, 4]
D = [4, 1]
```

- `AB = (4 - 1, 4 - 1) = (3, 3)`
- `AC = (1 - 1, 4 - 1) = (0, 3)`
- `AD = (4 - 1, 1 - 1) = (3, 0)`

ここで、ベクトル `AB` と `AC` の外積 `cp1` を計算します。
- `cp1 = 3 * 3 - 3 * 0 = 9`

同様に、ベクトル `AB` と `AD` の外積 `cp2` を計算します。
- `cp2 = 3 * 0 - 3 * 3 = -9`

この時点で、`cp1` と `cp2` の符号が異なるので、線分ABに対して、点Cと点Dは反対側にあることが分かります。

同様に、線分CDに対して点Aと点Bの位置関係を調べ、結果的に両方が反対側にあることが確認できるため、これらの線分は交差していると判断できます。

### 5. 最後に

このように、外積は線分の交差判定において重要な役割を果たします。ベクトルの向きを使って、2つの線分が交差しているかどうかを効率的に判定するための手法です。この仕組みは、単純な位置判定だけでは扱いにくい問題を解決するために有効です。

## [本題] コード全体の流れ

1. **座標の入力とベクトルの計算**:

   - 4 つの点の座標を入力し、それぞれを結ぶ線分のベクトルを計算します。

2. **外積の計算**:

   - 計算したベクトルを使って外積を求め、点と線分の位置関係を判定します。

3. **線分の端点をソート**:

   - 線分の端点を比較して、端点が昇順になるように並べ替えます。

4. **交差判定**:
   - 線分が交差しているかどうかを外積とソートされた端点の位置関係を使って判定し、その結果を出力します。

### 各部分の詳細な解説

#### 1. 外積 (`cross_product`) とベクトル (`vector`) の計算

```python
def cross_product(x1, y1, x2, y2):
    return x1 * y2 - x2 * y1

def vector(a, b):
    return b[0] - a[0], b[1] - a[1]
```

- **ベクトル (`vector`)**:

  - 2 つの点 `a` と `b` を与えたとき、その点を結ぶベクトルを計算します。<br>
    ベクトルは方向と長さを持つ量で、`a` から `b` へ向かう方向を示します。
  - 具体的には、`a` から `b` へのベクトルは、<br>
    `b[0] - a[0]`（x 成分）と<br>
    `b[1] - a[1]`（y 成分）<br>
    で表されます。

- **外積 (`cross_product`)**:
  - 2 つのベクトル `AB` と `AC` の外積は、ベクトルが作る平行四辺形の面積に関連しています。<br>
    この値は、点 `C` が線分 `AB` の左側にあるか、右側にあるか、または同一直線上にあるかを判定するのに役立ちます。
  - 具体的には、`cross_product(x1, y1, x2, y2)` は、2 つのベクトルの x 成分と y 成分を使って計算されます。<br>
    この値が正なら右側、負なら左側、ゼロなら同一直線上にあることを意味します。

#### 2. 座標の入力とベクトルの計算

```python
def read_point():
    return list(map(int, input().split()))

def main():
    A = read_point()
    B = read_point()
    C = read_point()
    D = read_point()

    AB = vector(A, B)
    AC = vector(A, C)
    AD = vector(A, D)
    CD = vector(C, D)
    CA = vector(C, A)
    CB = vector(C, B)
```

- **座標の入力 (`read_point`)**:

  - 各点の座標を入力として受け取り、リスト形式で返します。

- **ベクトルの計算**:
  - `AB`, `AC`, `AD`, `CD`, `CA`, `CB` というベクトルを作成します。それぞれのベクトルは、対応する 2 つの点を結んでいます。

#### 3. 外積を使った交差判定

```python
    cp1 = cross_product(*AB, *AC)
    cp2 = cross_product(*AB, *AD)
    cp3 = cross_product(*CD, *CA)
    cp4 = cross_product(*CD, *CB)
```

- **外積 (`cp1`, `cp2`, `cp3`, `cp4`) の計算**:
  - `cp1` と `cp2` は、線分 `AB` に対する点 `C` と点 `D` の位置関係を示します。
  - `cp3` と `cp4` は、線分 `CD` に対する点 `A` と点 `B` の位置関係を示します。
  - 外積の結果を使って、点が線分のどちら側にあるか、または同一直線上にあるかを判定します。

#### 4. 線分の端点をソートして交差判定

```python
    if A > B:
        A, B = B, A
    if C > D:
        C, D = D, C

    if cp1 == 0 and cp2 == 0 and cp3 == 0 and cp4 == 0:
        return print('Yes' if max(A, C) <= min(B, D) else 'No')
    else:
        return print('Yes' if cp1 * cp2 <= 0 and cp3 * cp4 <= 0 else 'No')
```

- **端点のソート**:

  - ここで、端点 `A`, `B`, `C`, `D` を比較し、端点が昇順になるように並べ替えています。<br>
    これにより、線分が正しい順序で比較されるようになります。

- **同一直線上にある場合の判定**:

  - `cp1`, `cp2`, `cp3`, `cp4` がすべてゼロであれば、線分 `AB` と `CD` は同一直線上にあります。<br>
    この場合、`max(A, C) <= min(B, D)` という条件を使って、線分が重なっているかを判定します。
  - この条件が成り立てば、線分は交差しているので「Yes」を返し、そうでなければ「No」を返します。

- **通常の交差判定**:
  - `cp1 * cp2 <= 0 and cp3 * cp4 <= 0` という条件は、各線分の端点が他方の線分の異なる側にある場合に成立します。<br>
    これにより、2 つの線分が交差しているかどうかを判定します。

### まとめ

このコードは、幾何学的な手法を使って 2 つの線分が交差しているかどうかを正確に判定します。外積を使って各点がどちら側にあるかを調べ、さらに線分が同一直線上にある場合の処理も行うことで、すべてのケースに対応できるようにしています。これにより、線分の交差を効率的に判定することができます。

## [事例] 具体例
線分の交差判定において、最終的に4つのパターンが生じることについて、それぞれの事例を使って説明します。また、線分が同じ直線上にある場合のソート処理についても解説します。

### 1. 交差判定の4パターン

2本の線分 `AB` と `CD` が交差するかどうかは、次の4つの条件に基づきます。外積を用いて判定することができ、それぞれ異なる事例が該当します。

#### 条件1: `cp1 * cp2 <= 0`（線分 `AB` に対する `C` と `D` の位置関係）
- `cp1` = ベクトル `AB` とベクトル `AC` の外積
- `cp2` = ベクトル `AB` とベクトル `AD` の外積

#### 条件2: `cp3 * cp4 <= 0`（線分 `CD` に対する `A` と `B` の位置関係）
- `cp3` = ベクトル `CD` とベクトル `CA` の外積
- `cp4` = ベクトル `CD` とベクトル `CB` の外積

この条件が両方とも満たされる場合に線分は交差します。

次に、これらのパターンごとの事例を見ていきます。

### パターン1: 完全に交差している場合

**例**:
- 線分 `AB` と線分 `CD` が完全に交差している場合。
- `A(1, 1)`, `B(4, 4)`, `C(1, 4)`, `D(4, 1)`

```python
A = [1, 1]
B = [4, 4]
C = [1, 4]
D = [4, 1]
```

計算:
- `AB = (3, 3)`
- `AC = (0, 3)`, `AD = (3, 0)`
- 外積 `cp1 = 3 * 3 - 3 * 0 = 9`
- 外積 `cp2 = 3 * 0 - 3 * 3 = -9`

- `CD = (3, -3)`
- `CA = (0, -3)`, `CB = (3, -3)`
- 外積 `cp3 = -3 * -3 - 3 * 0 = 9`
- 外積 `cp4 = -3 * -3 - 3 * -3 = -9`

結果: 両方とも条件を満たすため、**交差している**。

### パターン2: 一部が重なっている場合（重なる部分が含まれる）

**例**:
- `A(1, 1)`, `B(5, 5)`, `C(3, 3)`, `D(6, 6)`
- ここでは、線分 `AB` に対して、線分 `CD` の一部が重なっている。

```python
A = [1, 1]
B = [5, 5]
C = [3, 3]
D = [6, 6]
```

計算:
- `AB = (4, 4)`
- `AC = (2, 2)`, `AD = (5, 5)`
- 外積 `cp1 = 4 * 2 - 4 * 2 = 0`
- 外積 `cp2 = 4 * 5 - 4 * 5 = 0`

結果: 外積が0の場合、これは同じ直線上にあるという意味になります。**重なっている部分がある**ため、この場合も交差とみなします。

### パターン3: 平行だが交差しない場合

**例**:
- 線分 `AB` と `CD` が平行で、完全に別々の位置にある場合。
- `A(1, 1)`, `B(3, 3)`, `C(4, 4)`, `D(6, 6)`

```python
A = [1, 1]
B = [3, 3]
C = [4, 4]
D = [6, 6]
```

計算:
- `AB = (2, 2)`
- `AC = (3, 3)`, `AD = (5, 5)`
- 外積 `cp1 = 2 * 3 - 2 * 3 = 0`
- 外積 `cp2 = 2 * 5 - 2 * 5 = 0`

結果: **平行で、交差していない**。線分が同じ直線上にあるが、重なっていない場合も外積が0になります。

### パターン4: 交差しない（完全に離れている）

**例**:
- 交差していないケース。
- `A(1, 1)`, `B(2, 2)`, `C(3, 3)`, `D(4, 4)`

```python
A = [1, 1]
B = [2, 2]
C = [3, 3]
D = [4, 4]
```

計算:
- `AB = (1, 1)`
- `AC = (2, 2)`, `AD = (3, 3)`
- 外積 `cp1 = 1 * 2 - 1 * 2 = 0`
- 外積 `cp2 = 1 * 3 - 1 * 3 = 0`

結果: **交差していない**。

### 5. ソート処理の意味

外積が0（つまり、ベクトルが同じ直線上にある）場合、線分の**並び順**を考慮して交差しているかを判定します。これは、線分が並んでいるか、重なっているかを確認するために必要です。

#### ソートの例
もし、`A` の座標が `B` より大きい場合、`A` と `B` を入れ替えます。同様に、`C` の座標が `D` より大きければ、それらを入れ替えます。こうすることで、線分が必ず**左から右**に向かうように揃えることができます。これによって、重なりを正確に判定することが可能になります。

#### ソートのコード部分

```python
if A > B:
    A, B = B, A
if C > D:
    C, D = D, C
```

これにより、`A <= B` と `C <= D` という順序が常に守られるようになります。線分が重なっているかどうかを確認するためには、次のようにして重なりの範囲を確認します。

```python
if max(A, C) <= min(B, D):
    'Yes'
else:
    'No'
```

この判定では、`A` と `B`、`C` と `D` の範囲が重なっているかどうかを確認しています。

## [補足] 線分の端点をソートする理由

まず、2 つの線分が同じ直線上にある場合を考えます。たとえば、線分 `AB` と線分 `CD` が同じ直線上にあるとき、これらが重なり合っているかどうかを確認する必要があります。重なり合っていれば「交差している」と判断し、重なっていなければ「交差していない」と判断します。

#### 端点のソートとは？

ソート（順序づけ）とは、数字や物を大きさや順序に従って並び替えることです。ここでは、線分の端点（始点と終点）を比較して、小さい方が始点、大きい方が終点になるように並び替えています。

### 具体例で説明

例えば、次のような点の配置を考えます。

- 点 `A(1, 1)`
- 点 `B(4, 1)`
- 点 `C(2, 1)`
- 点 `D(3, 1)`

この場合、線分 `AB` は `A` から `B` まで、線分 `CD` は `C` から `D` までです。ここで、`A` が `B` より左にあり、`C` が `D` より左にあるため、特に並び替える必要はありません。

### なぜソートが必要か？

もし、端点をソートしないと、例えば次のような状況で正しい判定ができないことがあります。

- 点 `A(4, 1)`
- 点 `B(1, 1)`
- 点 `C(3, 1)`
- 点 `D(2, 1)`

この場合、`A` が `B` より右にあり、`C` が `D` より右にあるため、端点が「逆」に並んでいます。これを放置すると、線分の重なりを正しく判断できない可能性があります。つまり、線分 `AB` は実際には `B` から `A` まで引かれており、`CD` は `D` から `C` まで引かれています。これでは、数学的には「逆方向の線分」になります。

このため、ソートして `A` と `B` を比較し、`A` が `B` より左にくるように（または `C` と `D` についても同様に）並べ替えるのです。これにより、線分の向きを統一し、次の重なり判定が適切に行われるようにします。

### 重なりの判定

端点がソートされた後、次に行うのは、これらの線分が同じ直線上に並んでいる場合、重なっているかどうかを判定することです。

```python
if cp1 == 0 and cp2 == 0 and cp3 == 0 and cp4 == 0:
    return print('Yes' if max(A, C) <= min(B, D) else 'No')
```

この部分では、もし `cp1` から `cp4` までの外積がすべてゼロの場合、線分はすべて同一直線上にあることを示しています。このとき、`max(A, C) <= min(B, D)` という条件を使って、線分が重なっているかどうかを判定しています。

- `max(A, C)` は `A` と `C` の中で右側（大きい方）の点を表し、
- `min(B, D)` は `B` と `D` の中で左側（小さい方）の点を表します。

この条件が成り立つと、2 つの線分は重なっているので「Yes」を返し、そうでなければ「No」を返します。

### まとめ

端点をソートする理由は、線分の向きを統一して正しい重なりの判定ができるようにするためです。ソートを行うことで、同一直線上にある線分が正しく重なっているかどうかを判定し、交差の有無を正確に判断できるようになります。

<br>
<br>

---
# 038

このコードは、遊園地の来場者数を特定の日数の範囲で計算する問題を解いています。各日ごとの来場者数をもとに、累積和を使って効率よく範囲の合計を求めるという流れです。


### 関数の説明

#### 1. `calc_cumulative_sum(N, A)`:
```python
def calc_cumulative_sum(N, A):
    calmulative_sum = [0] * (N+1)
    for i in range(N):
        calmulative_sum[i+1] = calmulative_sum[i] + A[i]
    return calmulative_sum
```
- **目的**: `A` というリストに含まれる日ごとの来場者数から累積和を計算します。
- **引数**:
  - `N`: 日数の合計。リスト `A` の長さに対応しています。
  - `A`: 各日の来場者数が格納されたリストです。
- **処理内容**:
  - 長さ `N+1` の `calmulative_sum` というリストを作成します。`calmulative_sum[i]` は、1日目から `i` 日目までの来場者数の合計です。`calmulative_sum[0]` は0で初期化されます。
  - `A` の各要素を順番に累積し、`calmulative_sum` に値を蓄積します。
- **戻り値**: 累積和を格納したリスト `calmulative_sum` を返します。

#### 2. `answer(calmulative_sum, LR)`:
```python
def answer(calmulative_sum, LR):
    for L, R in LR:
        print(calmulative_sum[R] - calmulative_sum[L-1])
```
- **目的**: クエリ（質問）ごとに、指定された範囲 `[L, R]` の来場者数の合計を計算し、出力します。
- **引数**:
  - `calmulative_sum`: 1日目から各日までの累積和が格納されたリスト。
  - `LR`: 各クエリ（質問）が格納されたリスト。各要素は `(L, R)` というタプルで、`L` 日目から `R` 日目までの合計を求める範囲です。
- **処理内容**:
  - 各 `L, R` について、`calmulative_sum[R] - calmulative_sum[L-1]` で範囲の合計来場者数を計算し、それを出力します。

#### 3. `main()`:
```python
def main():
    N, Q = map(int, input().split())
    A = list(map(int, input().split()))
    LR = [tuple(map(int, input().split())) for _ in range(Q)]
    calmulative_sum = calc_cumulative_sum(N, A)
    answer(calmulative_sum, LR)
```

- **目的**: 入力を受け取り、クエリごとに答えを求めます。
- **処理内容**:
  - `N` と `Q` を入力から読み取り、`A` に来場者数リストを格納します。
  - 各クエリ（質問）を `LR` というリストに格納し、`calc_cumulative_sum()` を使って累積和を計算します。
  - `answer()` を呼び出し、クエリに答えます。

### 具体例での説明

#### 入力例
```
10 5
8 6 9 1 2 1 10 100 1000 10000
2 3
1 4
3 9
6 8
1 10
```

#### ステップ 1: 累積和の計算
入力として、来場者数リスト `A = [8, 6, 9, 1, 2, 1, 10, 100, 1000, 10000]` を受け取ります。

`calc_cumulative_sum(N, A)` では、累積和を次のように計算します。

| `i`  | `A[i]` | `calmulative_sum[i+1]` (1日目からi日目までの合計) |
|------|--------|--------------------------------------------------|
| 0    | 8      | 8                                                |
| 1    | 6      | 14                                               |
| 2    | 9      | 23                                               |
| 3    | 1      | 24                                               |
| 4    | 2      | 26                                               |
| 5    | 1      | 27                                               |
| 6    | 10     | 37                                               |
| 7    | 100    | 137                                              |
| 8    | 1000   | 1137                                              |
| 9    | 10000  | 11137                                             |

最終的に、`calmulative_sum` は次のようになります：
```
calmulative_sum = [0, 8, 14, 23, 24, 26, 27, 37, 137, 1137, 11137]
```

#### ステップ 2: クエリの処理
クエリは5つあります。`answer()` 関数で順に処理します。

1. **クエリ (2, 3)**:
   - 範囲 2日目から3日目の合計を求めます。
   - 計算: `calmulative_sum[3] - calmulative_sum[1] = 23 - 8 = 15`
   - 結果: 15

2. **クエリ (1, 4)**:
   - 範囲 1日目から4日目の合計を求めます。
   - 計算: `calmulative_sum[4] - calmulative_sum[0] = 24 - 0 = 24`
   - 結果: 24

3. **クエリ (3, 9)**:
   - 範囲 3日目から9日目の合計を求めます。
   - 計算: `calmulative_sum[9] - calmulative_sum[2] = 1137 - 14 = 1123`
   - 結果: 1123

4. **クエリ (6, 8)**:
   - 範囲 6日目から8日目の合計を求めます。
   - 計算: `calmulative_sum[8] - calmulative_sum[5] = 137 - 26 = 111`
   - 結果: 111

5. **クエリ (1, 10)**:
   - 範囲 1日目から10日目の合計を求めます。
   - 計算: `calmulative_sum[10] - calmulative_sum[0] = 11137 - 0 = 11137`
   - 結果: 11137

#### 最終出力
```
15
24
1123
111
11137
```

### ポイント
1. **累積和の利点**: 逐一、範囲の合計を計算するのは時間がかかりますが、累積和を使うことで効率よく計算できます。`S[R] - S[L-1]` という形で、事前に計算した和を再利用するため、クエリごとの処理が高速です。
2. **リストの1-indexing**: `calmulative_sum` のリストは0番目を使わず、1番目からN番目を扱うように設計しています。これにより、日数とリストのインデックスが一致し、理解しやすくなっています。

<br>
<br>

---
# 039

### コードの解説

#### 1. `answer` 関数
```python
def answer(N, snow):
    res = []
    for i in range(1, N):
        if snow[i] > 0:
            res.append('<')
        elif snow[i] == 0:
            res.append('=')
        else:
            res.append('>')
    return print(''.join(res))
```
- この関数は、`snow` リストの内容に基づいて、隣接する区画の積雪量を比較し、記号 `'<', '=', '>'` を出力します。
- `res` は、結果を格納するリストです。
- `for` ループでは、`i=1` から `N-1` までを順に見ていきます。`snow[i]` が `0` より大きければ `'<（小さい）'` を追加し、`snow[i]` が `0` なら `'='` を、`0` より小さければ `'>'` を追加します。
- 最後に、`res` の内容を連結して文字列化し、それを出力します。

#### 2. `calc_cumulative_sum` 関数
```python
def calc_cumulative_sum(N, items):
    snow = [0] * (N+1)
    for L, R, X in items:
        snow[L-1] += X
        snow[R] -= X
    return snow
```
- `snow` は長さ `N+1` のリストで、各区間における雪の増減を記録します。
- `items` の各要素は `(L, R, X)` という形式のタプルです。これは、区間 `[L, R]` に `X` cm の雪が積もることを意味します。
- `snow[L-1] += X` は、区間 `L-1` に雪が `X` cm 積もることを表します。
- `snow[R] -= X` は、区間 `R` の次の位置に `-X` を加えて調整するために行います。これは、区間 `[L, R]` にのみ雪が積もることを管理するための「差分配列」の考え方です。

#### 3. `main` 関数
```python
def main():
    N, Q = map(int, input().split())
    items = [tuple(map(int, input().split())) for _ in range(Q)]
    snow = calc_cumulative_sum(N, items)
    answer(N, snow)
```
- この関数では、`N`（区画数）と `Q`（クエリ数）を入力として受け取り、降雪情報を `items` に格納します。
- `calc_cumulative_sum` 関数を使って、各区画にどのような積雪量の変動があったかを計算します。
- その結果に基づいて、隣接する区画の積雪量を比較し、結果を出力するために `answer` 関数を呼び出します。

### 処理の例

#### 入力例
```
5 3
1 2 3
2 5 4
2 4 1
```

1行目の `5 3` は、5つの区画と3つの降雪イベントがあることを示しています。次の3行には、それぞれ `(L, R, X)` 形式で降雪のイベントが与えられています。

- `1 2 3`: 区間 `[1, 2]` に `3` cm の雪が積もる。
- `2 5 4`: 区間 `[2, 5]` に `4` cm の雪が積もる。
- `2 4 1`: 区間 `[2, 4]` に `1` cm の雪が積もる。

#### `calc_cumulative_sum` の処理

入力の3つのイベントを基に、`snow` リストを次のように更新していきます。

1. 初期状態: `snow = [0, 0, 0, 0, 0, 0]`
2. 最初のクエリ `1 2 3` を処理:
   - `snow[0] += 3` → `snow = [3, 0, 0, 0, 0, 0]`
   - `snow[2] -= 3` → `snow = [3, 0, -3, 0, 0, 0]`
3. 次のクエリ `2 5 4` を処理:
   - `snow[1] += 4` → `snow = [3, 4, -3, 0, 0, 0]`
   - `snow[5] -= 4` → `snow = [3, 4, -3, 0, 0, -4]`
4. 最後のクエリ `2 4 1` を処理:
   - `snow[1] += 1` → `snow = [3, 5, -3, 0, 0, -4]`
   - `snow[4] -= 1` → `snow = [3, 5, -3, 0, -1, -4]`

最終的に、`snow = [3, 5, -3, 0, -1, -4]` となります。

#### `answer` の処理

次に、`answer` 関数で積雪量を比較します。この関数では、`i=1` から `N-1` までを比較します。

- `snow[1] = 5` なので、`snow[1] > 0` → `'<'` がリストに追加されます。
- `snow[2] = -3` なので、`snow[2] < 0` → `'>'` がリストに追加されます。
- `snow[3] = 0` なので、`snow[3] == 0` → `'='` がリストに追加されます。
- `snow[4] = -1` なので、`snow[4] < 0` → `'>'` がリストに追加されます。

最終的に、結果は `<>=>` となり、出力されます。

### まとめ

- このコードは差分配列を使って効率よく雪の積もり方を計算しています。
- `snow` リストに雪の増減を記録し、それを基に隣接する区画の積雪量を比較しています。

<br>
<br>

---

# 040

## コードの解説

このコードは、ALGO鉄道の駅間距離と太郎君の訪問駅リストから、総移動距離を計算するプログラムです。

### 関数 `calc_total_distance(A, M, B)`
```python
def calc_total_distance(A, M, B):
    dist = 0
    for i in range(M-1):
        start, end = B[i]-1, B[i+1]-1
        if start < end:
            dist += sum(A[start:end])
        else:
            dist += sum(A[end:start])
    return dist
```


この関数は、駅間距離リスト`A`、訪問駅数`M`、訪問駅リスト`B`を受け取り、総移動距離を計算して返します。

1. **初期化:** `dist = 0` で、総移動距離を初期化します。

2. **訪問駅間のループ:** `for i in range(M-1):` で、訪問駅間の移動を計算するためにループします。

    - `start, end = B[i]-1, B[i+1]-1`:  訪問駅リスト`B`から、現在(`i`)と次の(`i+1`)駅のインデックスを取得します。リストのインデックスは0から始まるため、駅番号から1を引いています。

    - **移動方向の判定:** `if start < end:` で、西から東へ向かう移動かどうかを判定します。

        - **西から東への移動:** `dist += sum(A[start:end])`: `A[start:end]` で、`start`駅（含まれる）から`end`駅（含まれない）までの駅間距離リストを取得し、その合計を`dist`に加算します。

        - **東から西への移動:** `dist += sum(A[end:start])`: 東から西への移動の場合は、`end`駅（含まれる）から`start`駅（含まれない）までの駅間距離リストを取得し、その合計を`dist`に加算します。

3. **総移動距離の返却:** すべての訪問駅間の移動距離を計算したら、`return dist`で総移動距離を返します。

### 関数 `main()`

```python
def main():
    N = int(input())
    A = list(map(int, input().split()))
    M = int(input())
    B = [int(input()) for _ in range(M)]
    print(calc_total_distance(A, M, B))
```


この関数は、プログラムのメイン処理を行います。

1. **入力の受け取り:**
   - `N = int(input())`: 駅の数`N`を入力します。
   - `A = list(map(int, input().split()))`: 駅間距離リスト`A`を入力します。
   - `M = int(input())`: 訪問駅数`M`を入力します。
   - `B = [int(input()) for _ in range(M)]`: 訪問駅リスト`B`を入力します。

2. **総移動距離の計算と出力:** `print(calc_total_distance(A, M, B))` で、`calc_total_distance`関数を呼び出して総移動距離を計算し、結果を出力します。


### `if __name__ == "__main__":`

この部分は、このPythonファイルが直接実行された場合にのみ、`main()`関数が実行されるようにするための記述です。

## 事例を使った処理過程の説明

入力例1を例に、処理過程を説明します。

**入力例1**
```
4
8 6 9
6
2
1
3
2
3
4
```

1. **入力の受け取り:**
   - `N = 4`
   - `A = [8, 6, 9]`
   - `M = 6`
   - `B = [2, 1, 3, 2, 3, 4]`

2. **`calc_total_distance`関数の実行:**

   - `dist = 0` で初期化

   - **1回目のループ (i=0):**
     - `start = 1`, `end = 0` (B[0]=2, B[1]=1)
     - `start > end` なので、東から西への移動
     - `dist += sum(A[0:1]) = 8` (駅1から駅2の距離)

   - **2回目のループ (i=1):**
     - `start = 0`, `end = 2` (B[1]=1, B[2]=3)
     - `start < end` なので、西から東への移動
     - `dist += sum(A[0:2]) = 14` (駅1から駅3の距離)

   - **3回目のループ (i=2):**
     - `start = 2`, `end = 1` (B[2]=3, B[3]=2)
     - `start > end` なので、東から西への移動
     - `dist += sum(A[1:2]) = 6` (駅3から駅2の距離)

   - **4回目のループ (i=3):**
     - `start = 1`, `end = 2` (B[3]=2, B[4]=3)
     - `start < end` なので、西から東への移動
     - `dist += sum(A[1:2]) = 6` (駅2から駅3の距離)

   - **5回目のループ (i=4):**
     - `start = 2`, `end = 3` (B[4]=3, B[5]=4)
     - `start < end` なので、西から東への移動
     - `dist += sum(A[2:3]) = 9` (駅3から駅4の距離)

   - 最終的に `dist = 43` となり、これが総移動距離として出力されます。

このように、このプログラムは訪問駅リストに基づいて駅間の移動をシミュレートし、総移動距離を計算します。

<br>
<br>

---
# 041

## コードの解説

このコードは、コンビニの営業時間中における各時刻の従業員数を計算するプログラムです。

### 関数 `count_employees(T, items)`

```python
def count_employees(T, items):
    diff = [0] * (T+1)
    for L, R in items:
        diff[L] += 1
        diff[R] -= 1

    res = 0
    for i in range(T):
        res += diff[i]
        print(res)
```

この関数は、コンビニの営業時間 `T` と、従業員の出勤・退勤時刻のリスト `items` を受け取り、各時刻の従業員数を計算して出力します。

1. **差分配列の初期化:**
   - `diff = [0] * (T+1)`:  まず、`diff` というリスト（配列）を `T+1` の長さで作成し、全ての要素を `0` で初期化します。このリストは、各時刻における従業員数の **増減** を表すために使われます。`T+1` としているのは、時刻 `T` (閉店時間) に退勤する場合に対応するためです。
2. **従業員の出退勤による増減を記録:**
   - `for L, R in items:`:  従業員の出勤・退勤時刻のリスト `items` から、各従業員のデータを取り出して処理します。
     - `diff[L] += 1`:  従業員が出勤する時刻 `L` に対応する `diff` の要素に `1` を加えます。これは、出勤によって従業員数が 1人増えることを表します。
     - `diff[R] -= 1`:  従業員が退勤する時刻 `R` に対応する `diff` の要素に `1` を減らします。これは、退勤によって従業員数が 1人減ることを表します。
3. **累積和による従業員数の計算:**
   - `res = 0`:  現在の従業員数を表す変数 `res` を `0` で初期化します。
   - `for i in range(T):`: 時刻 `0` から `T-1` までループします。
     - `res += diff[i]`:  現在の従業員数 `res` に、時刻 `i` における従業員数の増減 `diff[i]` を加算します。
     - `print(res)`:  時刻 `i` における従業員数 `res` を出力します。

### 関数 `main()`

この関数は、プログラムのメイン処理を行います。

1. **入力処理:**
   - `T = int(input())`:  コンビニの営業時間 `T` を入力として受け取ります。
   - `N = int(input())`:  従業員数 `N` を入力として受け取ります。
   - `items = [tuple(map(int, input().split())) for _ in range(N)]`:  各従業員の勤務時間 `L`, `R` を入力として受け取り、タプルのリストとして `items` に格納します。
2. **従業員数計算の実行:**
   - `print(count_employees(T, items))`:  `count_employees()` 関数を呼び出して、各時刻の従業員数を計算して出力します。

### `if __name__ == "__main__":`

この部分は、Pythonスクリプトが直接実行された場合にのみ `main()` 関数を呼び出すための記述です。

## 事例を使った処理過程の説明

例えば、コンビニの営業時間 `T` が `10`、従業員数 `N` が `3`、各従業員の勤務時間が `[(0, 3), (2, 4), (5, 6)]` であったとします。

### 1. `count_employees()` 関数の実行

1. `diff = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]` と初期化されます。
2. 1人目の従業員:  `L=0`, `R=3` なので、`diff[0]` に `1` を加え、 `diff[3]` から `1` を減らします。 `diff = [1, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0]` となります。
3. 2人目の従業員:  `L=2`, `R=4` なので、`diff[2]` に `1` を加え、 `diff[4]` から `1` を減らします。 `diff = [1, 0, 1, -1, -1, 0, 0, 0, 0, 0, 0]` となります。
4. 3人目の従業員:  `L=5`, `R=6` なので、`diff[5]` に `1` を加え、 `diff[6]` から `1` を減らします。 `diff = [1, 0, 1, -1, -1, 1, -1, 0, 0, 0, 0]` となります。
5. `res` を `0` で初期化します。
6. 時刻 `0` から `9` までループします:
   - `i = 0`: `res` に `diff[0]` (値は `1`) を加算し、 `res` は `1` になります。これを `print` します。
   - `i = 1`: `res` に `diff[1]` (値は `0`) を加算し、 `res` は `1` になります。これを `print` します。
   - `i = 2`: `res` に `diff[2]` (値は `1`) を加算し、 `res` は `2` になります。これを `print` します。
   - `i = 3`: `res` に `diff[3]` (値は `-1`) を加算し、 `res` は `1` になります。これを `print` します。
   - `i = 4`: `res` に `diff[4]` (値は `-1`) を加算し、 `res` は `0` になります。これを `print` します。
   - `i = 5`: `res` に `diff[5]` (値は `1`) を加算し、 `res` は `1` になります。これを `print` します。
   - `i = 6`: `res` に `diff[6]` (値は `-1`) を加算し、 `res` は `0` になります。これを `print` します。
   - `i = 7`, `i = 8`, `i = 9`:  `diff[7]` から `diff[9]` は全て `0` なので、`res` は変化せず `0` のままです。それぞれ `print` します。

### 2. 出力

最終的な出力は以下のようになります。

```
1
1
2
1
0
1
0
0
0
0
```

これは、各時刻におけるコンビニの従業員数を表しています。

<br>
<br>

---
# 042

このコードの目的は、与えられた正整数 `N` までのすべての整数 `K` に対して、`K × f(K)` の総和を効率的に求めることです。この問題の背景には、**整数の約数**に関する数学的な性質があり、それを活用して高速に計算を行っています。

コードを詳しく解説しながら、例を使って処理の流れをわかりやすく説明します。

---

## 基本的な考え方

まず、問題の焦点は「正の整数 `K` に対して `K × f(K)` の総和を計算する」ことです。`f(K)` は、`K` の正の約数の個数です。

### 例1: `N = 4` の場合

`f(1) = 1` (1の約数は1)
`f(2) = 2` (2の約数は1, 2)
`f(3) = 2` (3の約数は1, 3)
`f(4) = 3` (4の約数は1, 2, 4)

したがって、求めたい総和は次のようになります:

$1 \times 1 + 2 \times 2 + 3 \times 2 + 4 \times 3 = 23$

しかし、`N` が非常に大きい場合（例えば `N = 10^7` など）、このような直接的な計算では遅すぎるので、約数に関する数学的な性質を利用して高速に計算します。

---

## コードの詳細な解説

### 1. 和の公式 (`f(x)`)
```python
def f(x):
    return x * (x + 1) // 2
```

`f(x)` は、**1から `x` までの整数の総和**を計算する関数です。この関数は、次の数学的な公式に基づいています：

$1 + 2 + 3 + \cdots + x = \dfrac{x \times (x + 1)}{2}$ \]

例えば：

- `f(3)` の場合：`1 + 2 + 3 = 6` となり、これは公式に当てはめると次のように計算されます：

$$f(3) = \dfrac{3 \times (3 + 1)}{2} = \frac{3 \times 4}{2} = 6$$

- `f(5)` の場合：`1 + 2 + 3 + 4 + 5 = 15` となります。同様に：

$$f(5) = \dfrac{5 \times (5 + 1)}{2} = \frac{5 \times 6}{2} = 15$$

---

### 2. 約数の和を効率的に計算する (`sum_of_divisors`)
```python
def sum_of_divisors(N):
    res = 0
    for i in range(1, int(N**0.5)+1):
        res += i * i + 2 * i * (f(N//i) - f(i))
    return res
```

この関数では、`1` から `N` までの整数 `K` について、`K × f(K)` の総和を計算しています。以下では、この関数がどのように高速に計算しているかを見ていきます。

#### i のループ範囲

ループの範囲は `i` を `1` から `√N` までに制限しています。なぜかというと、ある数 `K` の約数は対になって現れるからです。例えば、`36` の約数を考えると、次のような対があります：

- 1と36
- 2と18
- 3と12
- 6と6

約数の小さい方を順に見ていけば、大きい方も同時に見つけられるため、`√N` まで調べるだけで済みます。

#### `res += i * i`

これは、`i` が自分自身の倍数である（つまり、`i * i` が約数となる）場合の特別な処理です。完全平方数の時に必要です。例えば、`i = 2` であれば、`2 * 2 = 4` で、`4` 自身が `2` の倍数です。

#### `2 * i * (f(N//i) - f(i))`

この部分は、`i` の倍数を効率的に処理しています。`N // i` は `i` の倍数の最大値です。たとえば `N = 100` の場合、`i = 2` だと `100 // 2 = 50` なので、`2` の倍数は `2, 4, 6, ..., 50` となります。

`f(N // i)` で、`i` の倍数の総和を計算し、`f(i)` を引くことで、`i` 自身を除いた倍数に対応する和を取得しています。

#### 例：`N = 10` の場合

`N = 10` の場合を例に処理を追ってみましょう。

1. `i = 1`
   - `f(N // i) = f(10) = 1 + 2 + ... + 10 = 55`
   - `f(i) = f(1) = 1`
   - 計算する式は `1 * 1 + 2 * 1 * (55 - 1) = 1 + 108 = 109`

2. `i = 2`
   - `f(N // i) = f(5) = 1 + 2 + 3 + 4 + 5 = 15`
   - `f(i) = f(2) = 1 + 2 = 3`
   - 計算する式は `2 * 2 + 2 * 2 * (15 - 3) = 4 + 48 = 52`

3. `i = 3`
   - `f(N // i) = f(3) = 1 + 2 + 3 = 6`
   - `f(i) = f(3) = 6`
   - 計算する式は `3 * 3 + 2 * 3 * (6 - 6) = 9 + 0 = 9`

最終的な結果として、`res = 109 + 52 + 9 = 170` となります。

---

### 計算量の詳細
このコードは、`N` の平方根までの範囲でループを回しています（`O(√N)`）。ループ内の各操作は一定時間（`O(1)`）で実行されるため、全体としての計算量は **`O(√N)`** です。これにより、`N` が非常に大きくても効率的に計算できます。

---

## まとめ

このコードは、数の約数に関する性質を巧妙に利用して、計算量を `O(√N)` に抑えることで高速に結果を求めています。特に大きな `N` に対しても効率的に動作します。

<br>

## [補足] `i * i + 2 * i * (f(N//i) - f(i))` という式の意味

`i * i + 2 * i * (f(N//i) - f(i))` という式の意味について、より詳細に説明します。

この式は、**整数 `N` に対して、その約数 `i` を効率的に扱う**ための工夫が含まれています。ここでは、この式が何を意味しているのかを、具体的な事例を用いて説明していきます。

---

### 背景：整数の約数と和の計算

まず、この問題では、`1` から `N` までのすべての整数 `K` に対して、`K × f(K)` の総和を求めています。ここで、`f(K)` は、`K` の正の約数の個数を表します。

直接的に `K` ごとに計算していくと非常に時間がかかりますが、整数の約数に関する数学的性質を使うことで、効率化が可能です。

#### ポイント

`K` の約数 `i` を見つけるとき、`i` とその倍数 `i * k` も同時に扱います。これによって、全体を効率的に計算できます。

---

### 式の分解と理解

式全体 `i * i + 2 * i * (f(N//i) - f(i))` は、**2つの部分**から成り立っています。それぞれを分解して見ていきましょう。

#### 1. `i * i` の部分

この部分は、`i` 自身が `N` の約数である場合に対応しています。つまり、`i` が `N` の約数のとき、その約数に対して `i × i` を加える必要があります。

- 例：`N = 36` の場合、`i = 6` のとき、`6 × 6 = 36` であるため、この値を加算します。

#### 2. `2 * i * (f(N // i) - f(i))` の部分

この部分は、`i` の倍数に対応しています。`N // i` は `i` の倍数のうち、`N` 以下の最大の倍数を表します。

例えば、`N = 36` で `i = 6` のとき、`N // i = 36 // 6 = 6` になります。`6` の倍数は `6, 12, 18, 24, 30, 36` です。

##### `f(N // i)` とは？

`f(N // i)` は、`1` から `N // i` までの整数の総和を表します。つまり、`i` の倍数を含む総和です。

##### `f(i)` とは？

`f(i)` は、`1` から `i` までの整数の総和を表します。`i` の倍数の中で最小の値である `i` 自身を含むため、それを差し引きます。

##### なぜ `2 * i` ？

ここで `2 * i` が使われるのは、`i` の倍数である数値すべてに対して、この操作を行う必要があるためです。倍数全体に対して、`i` を掛けた分を2倍にして計算します。

---

### 具体的な事例での理解

例えば、`N = 36` で `i = 6` の場合を考えてみましょう。

1. `i * i = 6 * 6 = 36`

   - これは、`6` 自身が約数であることに対応して加算しています。

2. `f(N // i) = f(36 // 6) = f(6) = 1 + 2 + 3 + 4 + 5 + 6 = 21`

3. `f(i) = f(6) = 1 + 2 + 3 + 4 + 5 + 6 = 21`

   - `i` 自身を含む部分を引くため、この場合、`f(N // i) - f(i) = 21 - 21 = 0` になります。

この場合、式の結果は次のようになります：

$$i * i + 2 * i * (f(N // i) - f(i)) = 6 * 6 + 2 * 6 * (21 - 21) = 36 + 0 = 36$$

これが `N = 36` で `i = 6` の場合の計算結果です。

---

### 別の例: `N = 36` で `i = 2`

次に、`i = 2` の場合を見てみましょう。

1. `i * i = 2 * 2 = 4`

2. `f(N // i) = f(36 // 2) = f(18) = 1 + 2 + 3 + ... + 18 = 171`

3. `f(i) = f(2) = 1 + 2 = 3`

この場合、`f(N // i) - f(i) = 171 - 3 = 168` です。

したがって、式は次のように計算されます：

$i * i + 2 * i * (f(N // i) - f(i)) = 2 * 2 + 2 * 2 * 168 = 4 + 672 = 676$

このようにして、`N = 36` に対して `i = 2` の倍数に関連する計算結果が得られます。

---

### 結論

`i * i + 2 * i * (f(N//i) - f(i))` という式は、`i` の倍数に関連するすべての数値を効率的に計算するための式です。`i` 自身が約数である部分と、その倍数に対する計算を同時に処理しています。

このアプローチは、`N` が大きい場合でも効率的に計算できる方法であり、各 `i` に対して必要な計算を最小限に抑えるために工夫されています。


<br>
<br>

---
# 043

### 部活ネットワーク！全員と繋がれるか！？ Pythonコードで徹底解説！

今度は、部活のメンバーを例に、「ある人からメッセージを伝言していくと全員に届くか」を判定するプログラムを解説します！

### 部活メンバーの関係をグラフで表す！

例えば、部員が5人 (Aさん～Eさん)いて、以下の様な関係だったとします。

- Aさん - Bさん, Cさん
- Bさん - Aさん, Dさん
- Cさん - Aさん
- Dさん - Bさん
- Eさん - (無し)

Eさんは、誰も知らない状態です。これを図にすると、こんな感じ！

```
     A
   /   \
  B     C
 /
D

E
```

この図の、
- Aさん、Bさん...を「頂点」
- メンバー同士の関係を「辺」
と呼びます。

### コード解説：伝言ゲームで全員に届け！

**1. 関係リストを作る！( `is_connected` 関数 )**

```python
def is_connected(N, edges):
    graph = [[] for _ in range(N)]  # 空の関係リストを人数分用意
    for a, b in edges:
        graph[a-1].append(b-1)  # aさんと関係がある人を登録
        graph[b-1].append(a-1)  # bさんと関係がある人を登録
    return dfs(graph, N)
```

- `N`: 部員の人数 (今回の例では5人)
- `edges`: メンバー同士の関係リスト (例: `[(1, 2), (1, 3), (2, 4)]`)

まず、 `graph = [[] for _ in range(N)]` で、全員分の空の関係リストを作ります。
 `[ [], [], [], [], [] ]` みたいなイメージですね！

次に、`for a, b in edges:` で、関係 `edges` を一つずつ取り出して、

- `graph[a-1].append(b-1)`: aさんと関係がある人をリストに追加
- `graph[b-1].append(a-1)`: bさんと関係がある人をリストに追加

していきます。
(Pythonでは番号は0から数えるので、`a-1` や `b-1` としています)

今回の例だと、最終的に `graph` は以下のようになります。

```python
graph = [
    [1, 2],  # Aさんと関係がある人: Bさん, Cさん
    [0, 3],  # Bさんと関係がある人: Aさん, Dさん
    [0],    # Cさんと関係がある人: Aさん
    [1],    # Dさんと関係がある人: Bさん
    []     # Eさんと関係がある人: 誰もいない！
]
```

**2. 伝言ゲームスタート！全員に届け！( `dfs` 関数 )**

```python
def dfs(graph, N):
    visited = [False] *  N  # 伝言済みリスト (最初は全員False)
    stack = [0]             # 今から伝言する人リスト (最初はAさん)
    while stack:            # 伝言する人リストが空になるまで続ける
        v = stack.pop()     # 伝言する人リストから一人取り出す
        if not visited[v]:   # もし、その人にまだ伝言していなかったら
            visited[v] = True # 伝言済みにする
            for nv in graph[v]:  # その人と関係がある人リストから一人ずつ取り出して
                stack.append(nv) # 伝言する人リストに追加する
    return all(visited)  # 全員に伝言できたならTrue、そうでなければFalseを返す
```

- `visited`: 伝言済みリスト。最初は全員 `False` で、伝言できたら `True` にしていきます。
- `stack`:  これから伝言する人を順番に入れておくリスト。

**処理の流れ:**

1. 最初はAさん( `0` )を `stack` に入れてスタート！
2. `stack` から一人取り出して (最初はAさん)、その人と関係がある人のリストを `graph` から確認
3. まだ伝言していない人がいたら、伝言済みにし、`stack` に追加します。
4. これを `stack` が空になるまで繰り返します。

**今回の例の場合:**

1. `stack = [0]` (Aさんからスタート)
2. Aさんから伝言開始 (`v=0`)。`visited[0] = True`
   - Aさんと関係があるのはBさんとCさん(`graph[0] = [1, 2]`)
   - Bさん、Cさんはまだ伝言済みではないので、`stack` に追加 -> `stack = [1, 2]`
3. `stack` から Bさんを取り出す(`v=1`)。`visited[1] = True`
   - Bさんと関係があるのはAさんとDさん(`graph[1] = [0, 3]`)
   - Aさんは既に伝言済み(`visited[0] == True`)
   - Dさんはまだ伝言済みではないので、`stack` に追加 -> `stack = [2, 3]`
4. `stack` から Cさんを取り出す(`v=2`)。`visited[2] = True`
   - Cさんと関係があるのはAさんだけ(`graph[2] = [0]`)
   - Aさんは既に伝言済み(`visited[0] == True`)
5. `stack` から Dさんを取り出す(`v=3`)。`visited[3] = True`
   - Dさんと関係があるのはBさんだけ(`graph[3] = [1]`)
   - Bさんは既に伝言済み(`visited[1] == True`)
6. `stack` が空になったので終了。`visited` を確認 -> `[True, True, True, True, False]`
7. Eさんには伝言できていないので、`all(visited)` は **`False`** を返す

**3. 結果発表！( `main` 関数 )**

```python
def main():
    N, M = map(int, input().split()) # 人数と関係の数を入力
    edges = [tuple(map(int, input().split())) for _ in range(M)] # 関係を入力
    if is_connected(N, edges):
        print("The graph is connected.")  # 全員に伝言できたら
    else:
        print("The graph is not connected.") # 伝言できない人がいたら
```

- `N, M`:  部員の人数と、関係の数を入力
- `edges`:  M個の関係を `(1, 2)` のように入力

`is_connected(N, edges)` で全員に伝言できるか判定し、結果に応じてメッセージを出力します。

今回の例では、Eさんに伝言できなかったため、"The graph is not connected." となります。

## まとめ

このように、このコードでは部活メンバーの関係をグラフ構造で表現し、深さ優先探索 (DFS) を用いて全員に伝言が伝わるかを判定しています。

部活の例以外にも、友達関係やコンピュータネットワークなど、様々な場面に応用できます。ぜひ、色々試してみてください！

<br>
<br>

---
# 044

このコードは、与えられた無向グラフで頂点 1 から他のすべての頂点に到達するために必要な最小の辺の数を求めるためのものです。到達できない頂点については `-1` を出力します。ここでは、コードの各部分がどのように動作するのか、初心者でも理解しやすいように、事例を交えながら丁寧に解説します。

## 1. 全体の流れ

コードは、以下のステップで動作します：
1. グラフを入力から構築する。
2. 幅優先探索（BFS）を使用して、頂点1から各頂点までの最小の移動回数（辺の数）を計算する。
3. 結果を順番に出力する。

それでは、各部分を具体的に見ていきましょう。

---

## 2. `build_graph` 関数

### 目的：
グラフの隣接リストを作成します。これは、各頂点がどの頂点とつながっているかをリスト形式で記録するものです。

### 解説：

```python
def build_graph(N, edges):
    graph = [[] for _ in range(N+1)]
    for a, b in edges:
        graph[a].append(b)
        graph[b].append(a)
    return graph
```

- **入力**：
  - `N`: 頂点の数
  - `edges`: 辺のリスト（例: `[(1, 3), (2, 3)]`）

- **出力**：
  - 隣接リスト形式のグラフを返します。例えば、`N=3` で `edges=[(1, 3), (2, 3)]` の場合、次のようなグラフが作られます：

```python
graph = [
    [],    # 頂点0 (無視)
    [3],   # 頂点1 -> 頂点3と接続
    [3],   # 頂点2 -> 頂点3と接続
    [1, 2] # 頂点3 -> 頂点1と2に接続
]
```

- **例**：
  - 頂点 `1` と `3` がつながっているので、`graph[1]` に `3` が入ります。
  - 同様に、`graph[3]` に `1` が追加されます（無向グラフなので双方向です）。
  - これをすべての辺に対して繰り返すことで、グラフが完成します。

---

## 3. `bfs` 関数（幅優先探索）

### 目的：
頂点 `1` から他の頂点までの最短距離（最小の辺数）を計算します。幅優先探索（BFS）を用いて、各頂点までの距離を順に探索していきます。

### 解説：

```python
def bfs(N, graph):
    dist = [-1] * (N+1)
    dist[1] = 0
    queue = deque([1])

    while queue:
        v = queue.popleft()
        for nv in graph[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                queue.append(nv)
    return dist[1:]
```

- **入力**：
  - `N`: 頂点数
  - `graph`: 隣接リスト形式のグラフ

- **内部変数**：
  - `dist`: 各頂点までの最短距離を格納するリスト。`dist[i]` には頂点1から頂点 `i` までの距離が入ります。初期値は全て `-1` で、これはまだ訪問していないことを意味します。
  - `queue`: 探索待ちの頂点を保持するキュー。最初は頂点1（出発点）から探索を開始します。

### 処理の流れ：

1. **初期化**：
   - `dist[1] = 0` で、頂点1から頂点1への距離は 0 です。
   - キューに最初の頂点 `1` を入れます（`queue = deque([1])`）。

2. **幅優先探索**：
   - キューから頂点を1つ取り出し（`popleft()`）、その頂点に隣接する未訪問の頂点をすべて探索します。
   - 新しい頂点に到達したら、その頂点までの距離を計算して（1つ前の頂点までの距離 `+1`）、その頂点をキューに追加します。

3. **探索の終了**：
   - キューが空になった時点で、頂点1から各頂点への最短距離が `dist` リストに保存されている状態になります。
   - 最後に、`dist[1:]` を返します（頂点0は無視）。

### 例：
 例えば、`N=3`、`edges=[(1, 3), (2, 3)]` の場合：

1. 最初に、`dist = [-1, 0, -1, -1]` と初期化されます。キューには `1` が入ります（`queue = deque([1])`）。
2. 頂点 `1` から探索を開始し、頂点 `3` に隣接しているので、`dist[3] = 1` とし、キューに `3` を追加します。
3. 次に、頂点 `3` から隣接する頂点 `2` を探索し、`dist[2] = 2` となります。

結果として、`dist = [-1, 0, 2, 1]` が得られます。出力する際は `dist[1:]` なので、`[0, 2, 1]` が返されます。

---

## 4. `main` 関数

### 目的：
標準入力からデータを読み込み、上記の関数を使って最終的な結果を出力します。

### 解説：

```python
def main():
    N, M = map(int, input().split())
    edges = [tuple(map(int, input().split())) for _ in range(M)]
    graph = build_graph(N, edges)
    dist = bfs(N, graph)
    print(*dist, sep='\n')
```

1. **入力の取得**：
   - `N` は頂点の数、`M` は辺の数です。
   - `edges` には `M` 本の辺の情報がタプルとしてリストに格納されます（例えば、`edges=[(1, 3), (2, 3)]`）。

2. **関数の呼び出し**：
   - `build_graph(N, edges)` でグラフを作成し、`bfs(N, graph)` で頂点1から他の頂点への最短距離を計算します。

3. **結果の出力**：
   - `dist` に格納された結果を1行ずつ出力します。

---

## 5. 例を用いた全体の流れ

例えば、次の入力が与えられたとします：

```
3 2
1 3
2 3
```

1. **グラフの構築**:
   - グラフは次のようになります：
   ```
   graph = [[], [3], [3], [1, 2]]
   ```

2. **BFSの結果**：
   - 頂点1から他の頂点への距離は次のようになります：
   ```
   dist = [-1, 0, 2, 1]
   ```

3. **出力**：
   - `dist[1:] = [0, 2, 1]` が出力されます。

<br>
<br>

## [別の説明]みんな大好き！グラフ探索ゲーム！：友達の家に遊びに行く編

このコードは、君のお家の周りで「友達の家に遊びに行くゲーム」をするためのプログラムなんだ！

**ゲームのルール説明**

1. 君の街には、君の家を含めて家がいくつかあって、それぞれの家は番号で呼ばれているよ！
2. 家と家は道で繋がれているけど、すべての家が繋がっているとは限らないんだ。
3. 君は、自分の家からスタートして、友達の家に遊びに行きたいんだけど、できるだけ短い道のりで遊びに行きたいよね！

このプログラムは、君の家からそれぞれの友達の家に遊びに行くための、**最短の道のり（必要な道の数）** を教えてくれるんだ！

### プログラムの中身を見てみよう！

#### 1. `build_graph(N, edges)` 関数：街の地図を作る！

この関数は、ゲームをするための「街の地図」を作る役割をしているよ！

* **入力**
    - `N` : 街にある家の数（君の家の番号は1番だよ！）
    - `edges` : 道の情報。例えば `[(1, 2), (2, 3)]` だったら、「1番の家と2番の家」、「2番の家と3番の家」がそれぞれ道で繋がっていることを表しているよ。

* **出力**
    - `graph`: 街の地図。どの家がどの家と繋がっているかを示しているよ。

**例：**

もし、君の家を含めて家が4軒あって、道が `[(1, 2), (2, 3), (1, 4)]` のように繋がっていたとすると、 `build_graph(4, [(1, 2), (2, 3), (1, 4)])` は、以下のような「街の地図」を作るよ。

```
graph = [
    [],                 # 0番目の家は使わないので空っぽ！
    [2, 4],             # 1番の家は、2番の家と4番の家と繋がっている
    [1, 3],             # 2番の家は、1番の家と3番の家と繋がっている
    [2],                # 3番の家は、2番の家と繋がっている
    [1]                 # 4番の家は、1番の家と繋がっている
]
```

#### 2. `bfs(N, graph)` 関数：最短ルートを探検だ！

この関数は、作った「街の地図」を使って、君の家からそれぞれの友達の家まで、最短で何本の道を通れば良いか計算してくれるよ！

* **入力**
    - `N`: 街にある家の数
    - `graph`: `build_graph` 関数で作った「街の地図」

* **出力**
    - `dist[1:]`: 君の家(1番)から各家までの最短距離が入ったリスト

**例：**

上の例と同じように、家が4軒あって、`graph` が
```python
graph = [
    [],
    [2, 4],
    [1, 3],
    [2],
    [1]
]
```
だったとする。

`bfs(4, graph)` を実行すると、以下のように計算が進んでいくよ！

1. まず、君の家からスタート！ `dist = [0, -1, -1, -1]` となる。`dist[i]` は君の家から `i` 番目の家までの距離を表していて、まだ訪れていない家は `-1` となっているよ。
2. 君の家(1番)から直接行ける家(2番と4番)を調べる。2番の家と4番の家は、君の家から1本道を通れば行けるので、 `dist = [0, 1, -1, 1]` となる。
3. 次に、2番の家から直接行ける家(3番)を調べる。3番の家は、君の家から2本道を通れば行けるので、 `dist = [0, 1, 2, 1]` となる。
4. これですべての家までの最短距離がわかったね！ `bfs` 関数は、 `[1, 2, 1]` を返す。

#### 3. `main()` 関数：ゲームスタート！

この関数は、ゲームを開始して、結果を表示する役割を持っているよ。

1. `N`, `M` の入力を受け取る。
2. `edges` を受け取り、`build_graph` 関数を使って「街の地図」を作る。
3. `bfs` 関数を使って、君の家から各家までの最短距離を計算する。
4. 計算結果を表示する。

**例：**

もし、入力が
```
4 3
1 2
2 3
1 4
```
だった場合、

1. `N = 4`, `M = 3`, `edges = [(1, 2), (2, 3), (1, 4)]` となる。
2. `build_graph(4, [(1, 2), (2, 3), (1, 4)])` を実行し、`graph` が作成される。
3. `bfs(4, graph)` を実行し、 `dist = [1, 2, 1]` が返される。
4. 最後に、 `1 2 1` と表示される。

これで、君の家からそれぞれの友達の家に遊びに行くための、最短の道のりがわかったね！

このプログラムを使えば、どんなに複雑な街の地図でも、迷わずに友達の家に遊びに行けるね！

<br>

## [補足] キューとスタックの違い
`queue` を使う理由は、**幅優先探索 (BFS)** を実現するためです。BFS は最短経路問題を解く際に非常に重要なアルゴリズムです。これを効率的に実行するためには、**キュー**を使って各ノードを訪れる必要があります。

一方、`stack` を使うと探索の順序が変わり、**深さ優先探索 (DFS)** に変わってしまいます。DFS では、ノードの訪問順が違うため、BFS のように正しい最短距離が計算されなくなります。

### 1. 幅優先探索 (BFS) とキュー
- **キュー (queue)** は**先入れ先出し (FIFO)** のデータ構造です。つまり、最初に追加された要素が最初に取り出されます。
- BFS では、最初に訪れたノードの隣接ノードを順番に訪れ、それから次の隣接ノードへと探索を広げていきます。
- これにより、探索が**層状**に進み、最短距離を確実に求めることができます。

### 2. 深さ優先探索 (DFS) とスタック
- **スタック (stack)** は**後入れ先出し (LIFO)** のデータ構造です。つまり、最後に追加された要素が最初に取り出されます。
- DFS では、あるノードの隣接ノードを可能な限り探索してから、次に移るので、探索が**深く進む**ことになります。
- これにより、BFS のように層状に探索が進まないため、最短距離を正確に求めることができません。

---

## 実際に比較してみる

### BFS の例（`queue` 使用）

```python
from collections import deque

def bfs_example():
    graph = {
        1: [2, 3],
        2: [4],
        3: [4],
        4: []
    }
    dist = [-1] * 5
    dist[1] = 0
    queue = deque([1])

    while queue:
        v = queue.popleft()
        for nv in graph[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                queue.append(nv)

    print(dist[1:])

bfs_example()
```

### 出力

```
[0, 1, 1, 2]
```

ここでは、ノード `1` から始めて、`2` と `3` は 1 つのステップで訪問でき、`4` は 2 つのステップで到達することが分かります。これは最短距離を正確に計算していることを示しています。

---

### DFS の例（`stack` 使用）

```python
def dfs_example():
    graph = {
        1: [2, 3],
        2: [4],
        3: [4],
        4: []
    }
    dist = [-1] * 5
    dist[1] = 0
    stack = [1]

    while stack:
        v = stack.pop()
        for nv in graph[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                stack.append(nv)

    print(dist[1:])

dfs_example()
```

### 出力

```
[0, 1, 1, 2]
```

見た目では同じ結果が出ていますが、これはたまたま単純なグラフの構造だったからです。DFS は「深く」進むため、複雑なグラフでは正しい最短距離が得られない可能性があります。

---

## 複雑なグラフでの違い

### 例: `1 -> 2 -> 4` と `1 -> 3 -> 4` の場合

- グラフに以下のような複数のルートがあるとします：

```python
graph = {
    1: [2, 3],
    2: [4],
    3: [4],
    4: []
}
```

この場合、`1` から `4` への最短距離は 2 ですが、DFS は必ずしも最短ルートを見つけるわけではありません。

---

### DFS での問題

DFS はスタックを使って「深く」進むため、あるルートを最後まで辿ることになります。つまり、`1 -> 2 -> 4` というルートをたどりきってから、他のルート（`1 -> 3 -> 4`）を探索します。

結果として、最短距離ではなく、最初に見つけたルートで到達した距離を記録してしまう可能性があります。

---

## 結論

- **BFS (キュー使用)**：最短距離を正確に計算したい場合に適しています。キューを使うことで、隣接ノードを層ごとに順番に訪れるため、全てのノードに対して最短距離を求めることができます。
- **DFS (スタック使用)**：グラフの全てのノードを深く探索する際に適していますが、最短距離を求める問題には適していません。

そのため、このコードでは **BFS** を用いるべきであり、`queue` を使う方が適切です。

<br>
<br>

### なぜ今回の問題でスタック（DFS）ではダメなのか？

今回の問題で **スタック（DFS）** ではなく **キュー（BFS）** を使うべき理由は、**最短距離を求める問題** だからです。幅優先探索（BFS）では最短距離が確実に計算できるのに対して、深さ優先探索（DFS）ではそうならないことがあるためです。

- **問題の要件**：
    - 頂点 1 から各頂点 \( k \) までの最短距離（たどる辺の最小本数）を計算しなければならない。
    - DFS は「深く」進む性質があるため、ある経路を見つけた時点で他の経路を無視してしまうことがあり、必ずしも最短経路を見つけるわけではありません。

- **BFS の特徴**：
    - BFS は「幅優先探索」なので、あるノードから隣接するノード全てを一層ずつ（つまり距離が短い順に）探索します。そのため、BFS を使うと、ノード 1 から他のノードへの最短距離を正確に求めることができます。

- **DFS の特徴**：
    - DFS は「深さ優先探索」なので、ある経路を深く探索し終えるまで他の経路を無視します。その結果、最初に見つけた経路が必ずしも最短距離であるとは限りません。
    - そのため、今回のように最短距離を求める場合、DFS では適切ではないのです。

### キュー（BFS）とスタック（DFS）での違いを示す例

次に、キュー（BFS）を使った場合とスタック（DFS）を使った場合で、出力結果が異なる例を見てみます。

---

#### 例 1: キュー（BFS）を使った場合

例えば次のグラフが与えられたとします：

```
1 -- 2 -- 4
 \        /
  3 -----
```

- 頂点 1 から頂点 4 までの最短距離は「1→3→4」（2 本の辺）です。

このグラフを使って、キュー（BFS）を使った場合の結果を見てみましょう。

```python
from collections import deque

def bfs_example():
    graph = {1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3]}
    dist = [-1] * 5
    dist[1] = 0
    queue = deque([1])

    while queue:
        v = queue.popleft()
        for nv in graph[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                queue.append(nv)

    print(dist[1:])

bfs_example()
```

### 出力

```
[0, 1, 1, 2]
```

- 頂点 1 から頂点 2 へは距離 1、頂点 3 へも距離 1、頂点 4 へは「1→3→4」で 2 本の辺を通って行けるので、距離は 2 です。

---

#### 例 2: スタック（DFS）を使った場合

次に、同じグラフに対してスタック（DFS）を使った場合の結果を見てみます。

```python
def dfs_example():
    graph = {1: [2, 3], 2: [1, 4], 3: [1, 4], 4: [2, 3]}
    dist = [-1] * 5
    dist[1] = 0
    stack = [1]

    while stack:
        v = stack.pop()
        for nv in graph[v]:
            if dist[nv] == -1:
                dist[nv] = dist[v] + 1
                stack.append(nv)

    print(dist[1:])

dfs_example()
```

### 出力

```
[0, 1, 2, 3]
```

- この結果では、頂点 1 から頂点 4 への最短距離は 2 ではなく、距離 3 となってしまいました。これは、スタックを使ったために、「1→2→4」の経路を先に探索したためです。

---

### 出力結果が異なる理由

- **BFS の場合**：頂点 1 から順に、隣接する頂点をすべて同じ層として探索し、距離が短い順に探索が行われます。そのため、最短距離が確実に求められます。
- **DFS の場合**：スタックを使うと、ある経路を深く探索してしまうため、最短経路ではなく、最初に見つけた経路が記録されてしまいます。DFS はすべてのノードを探索しますが、最短距離ではない探索結果が得られる可能性があります。

---

### まとめ

今回の問題では「最短距離」を求めるため、**キューを使って BFS を行う必要があります**。スタックを使った DFS では、最短経路を正確に見つけることができないため、BFS が正しい方法です。

DFS を使うと、「深く」探索するため、最短距離ではない経路を優先してしまい、正しい答えが得られない場合があるのです。

<br>
<br>

---
# 045

このコードは、**無向グラフ**が与えられたとき、特定の条件を満たす頂点の数をカウントするものです。コードの理解を深めるため、事例を使いながら初心者向けに丁寧に説明していきます。

### 問題の背景
グラフは**頂点**（ノード）と**辺**（エッジ）で構成されています。頂点は番号が振られていて、辺は2つの頂点をつなぐ線のようなものです。この問題では、特定の条件を満たす頂点を探す必要があります。

条件は、「自分より小さい番号の隣接頂点がちょうど1つ存在する頂点」を探すことです。

### コードの処理手順
まず、関数`count_valid_vertices()` と `main()` がどのように動くか説明します。

---

### `count_valid_vertices(N, edges)` の解説

この関数では、次のステップで条件を満たす頂点をカウントします。

1. **`count` リストの初期化**
   ```python
   count = [0] * (N + 1)
   ```
   ここでは、`count` というリストを作っています。このリストは `N+1` 個の要素を持ち、それぞれが 0 で初期化されています。各インデックスは対応する頂点を表し、隣接する自分より小さい頂点の数を数えます。

   例えば、頂点が 5 つ（N=5）の場合、リストは次のようになります。
   ```python
   count = [0, 0, 0, 0, 0, 0]
   ```
   インデックス 1〜5 がそれぞれの頂点を表し、`count[i]` は頂点 `i` に接続されている「自分より小さい番号の頂点」の数を示します。

2. **各辺の情報を処理**
   次に、グラフのすべての辺を調べます。`edges` は頂点のペアのリストで、それぞれのペアが辺を表します。`a, b` がその2つの頂点です。
   ```python
   for a, b in edges:
       if a > b:
           count[a] += 1
       else:
           count[b] += 1
   ```
   - **`a > b` の場合**: `a` の方が大きいため、`a` のカウントを増やします。
   - **`a ≤ b` の場合**: `b` の方が大きいため、`b` のカウントを増やします。

   これによって、各頂点に接続されている「自分より小さい番号の頂点」がカウントされます。

   #### 事例1
   例えば、次のような入力が与えられたとします。
   ```
   N = 5
   M = 5
   edges = [(1, 2), (1, 3), (3, 2), (5, 2), (4, 2)]
   ```
   この場合、各頂点の処理は以下のようになります。

   - `(1, 2)` では、`1` の方が小さいので、`2` にカウントを追加。`count[2] += 1`
   - `(1, 3)` では、`1` の方が小さいので、`3` にカウントを追加。`count[3] += 1`
   - `(3, 2)` では、`2` の方が小さいので、`3` にカウントを追加。`count[3] += 1`
   - `(5, 2)` では、`2` の方が小さいので、`5` にカウントを追加。`count[5] += 1`
   - `(4, 2)` では、`2` の方が小さいので、`4` にカウントを追加。`count[4] += 1`

   これにより、最終的な `count` リストは次のようになります。
   ```python
   count = [0, 0, 1, 2, 1, 1]
   ```

3. **条件を満たす頂点のカウント**
   最後に、カウントが「ちょうど1」である頂点の数を調べます。
   ```python
   return count.count(1)
   ```
   `count.count(1)` は、`count` リストの中で「1」の値を持つ要素の数を数えます。この例では、`count[2], count[4], count[5]` の3つが1なので、結果は `3` となります。

---

### `main()` の解説

`main()` 関数では、標準入力からデータを読み込み、処理を行います。

1. **入力の読み込み**
   ```python
   N, M = map(int, input().split())
   ```
   ここでは、`N` は頂点の数、`M` は辺の数です。

   例えば、入力が次のように与えられた場合：
   ```
   5 5
   1 2
   1 3
   3 2
   5 2
   4 2
   ```
   これは、頂点が5個あり、5本の辺が存在することを意味します。

2. **辺の読み込み**
   ```python
   edges = [tuple(map(int, input().split())) for _ in range(M)]
   ```
   この部分では、`M` 本の辺の情報をすべてリストとして読み込みます。各辺はタプル `(a, b)` の形で表され、`edges` に格納されます。

   事例1の例では、次のようなリストが得られます。
   ```python
   edges = [(1, 2), (1, 3), (3, 2), (5, 2), (4, 2)]
   ```

3. **頂点のカウント結果を出力**
   ```python
   print(count_valid_vertices(N, edges))
   ```
   `count_valid_vertices(N, edges)` を呼び出して結果を得て、それを標準出力に表示します。この事例の場合、結果は `3` です。

---

### 結論

このコードは、与えられたグラフにおいて「自分より小さい番号の隣接頂点がちょうど1つ存在する」頂点の数を効率的にカウントしています。処理過程を事例を使って説明しましたが、シンプルな構造であり、グラフの問題に慣れていない初心者でも理解しやすい実装となっています。

- **事例1**の処理では、頂点 2、4、5 が条件を満たす頂点としてカウントされ、その数が3と出力されました。

<br>
<br>

---
# 046

このコードは、幅優先探索（BFS）を使って、迷路内のスタート地点からゴール地点までの最短距離を求めるプログラムです。迷路は空きマス（`.`）と壁マス（`#`）で表されており、上下左右に移動できます。具体的な流れを、初心者向けに解説します。

### コード全体の流れ
1. **入力の受け取り**: 迷路の大きさ、スタート地点、ゴール地点、そして迷路の構造が入力される。
2. **幅優先探索（BFS）の実行**: 幅優先探索を用いて、スタート地点からゴール地点までの最小手数（最短距離）を計算します。
3. **結果の出力**: ゴール地点までの最短手数を出力します。

#### それぞれの部分について詳しく説明します。

---

### 1. `bfs` 関数
**幅優先探索（Breadth-First Search, BFS）** は、スタート地点から近いマスから順番に探索を行い、最短距離を求める方法です。

#### コードの説明

```python
from collections import deque
```
- **`deque`** は、両端から高速にデータを取り出せるデータ構造です。BFSで使うキュー（先入れ先出し）として利用します。

#### `bfs(maze, start, goal)` 関数の引数
- **`maze`**: 迷路の2次元リスト（`.``#`で構成された盤面）。
- **`start`**: スタート地点の座標（`(sy, sx)`）。
- **`goal`**: ゴール地点の座標（`(gy, gx)`）。

```python
directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]
```
- **`directions`**: 移動できる4方向（右、左、下、上）を表しています。これを使って、現在のマスから上下左右に移動します。

```python
R, C = len(maze), len(maze[0])
```
- **`R`**: 迷路の行数。
- **`C`**: 迷路の列数。

```python
dist = [[-1] * C for _ in range(R)]
```
- **`dist`**: 各マスのスタート地点からの距離を記録する2次元リスト。初期値は `-1` で、まだ訪れていないことを示しています。

```python
queue = deque([start])
dist[start[0]][start[1]] = 0
```
- **`queue`**: 探索対象のマスを格納するキュー。スタート地点から探索を開始するので、キューにスタート地点を入れます。
- **`dist[start[0]][start[1]] = 0`**: スタート地点の距離は `0` として初期化します。

#### 探索のループ
```python
while queue:
    y, x = queue.popleft()
    if (y, x) == goal:
        return dist[y][x]
```
- **`while queue:`**: キューに探索対象のマスがある限り、ループを回します。
- **`queue.popleft()`**: キューの先頭のマスを取り出します（これが現在の探索マスです）。
- **`if (y, x) == goal:`**: 現在のマスがゴール地点なら、その時点での距離を返します。

#### 隣接するマスの探索
```python
for dx, dy in directions:
    ny, nx = y + dy, x + dx
    if maze[ny][nx] != '#' and dist[ny][nx] == -1:
        queue.append((ny, nx))
        dist[ny][nx] = dist[y][x] + 1
```
- **`for dx, dy in directions:`**: 現在のマス（`(y, x)`）の上下左右のマス（`(ny, nx)`）を計算します。
- **`maze[ny][nx] != '#'`**: 隣のマスが壁でないか確認します。
- **`dist[ny][nx] == -1`**: そのマスが未訪問か確認します。未訪問の場合のみ、キューに追加します。
- **`dist[ny][nx] = dist[y][x] + 1`**: 隣接マスの距離を、現在のマスの距離 +1 として更新します。

#### 探索が終了しない場合
```python
return -1
```
もしゴール地点にたどり着けなかった場合、`-1` を返します（ただし、この問題では必ずゴールに到達可能なことが保証されています）。

---

### 2. `main` 関数
標準入力からデータを受け取り、`bfs` 関数を呼び出して結果を表示する部分です。

```python
R, C = map(int, input().split())
```
- **`R`**: 迷路の行数。
- **`C`**: 迷路の列数。

```python
sy, sx = map(int, input().split())
gy, gx = map(int, input().split())
```
- **`sy, sx`**: スタート地点の行・列。
- **`gy, gx`**: ゴール地点の行・列。

```python
maze = [list(input()) for _ in range(R)]
```
- **`maze`**: 迷路の各行を入力として受け取り、それをリストに変換して2次元リストに格納します。

```python
start = (sy-1, sx-1)
goal = (gy-1, gx-1)
```
- 入力座標は1始まりのため、プログラムでは0始まりに変換しています。

```python
print(bfs(maze, start, goal))
```
- BFSを実行し、その結果（最短手数）を出力します。

---

### 例を使った流れの解説

#### 入力例1
```
7 8
2 2
4 5
########
#......#
#.######
#..#...#
#..##..#
##.....#
########
```

1. **迷路の構造**: スタート地点は `(2, 2)` で、ゴール地点は `(4, 5)` にあります。スタートからゴールまでの最短経路を幅優先探索で求めます。
2. **初期状態**: BFSは、スタート地点 `(2, 2)` から距離 `0` で開始します。
3. **次の探索マス**: `(2, 3)`、`(3, 2)` に進み、順番に探索していきます。
4. **ゴール到達**: ゴール地点 `(4, 5)` に到達したとき、その地点の距離は `11` です。

<br>
<br>

---
# 047

## [参考] 2 部グラフ

https://www.momoyama-usagi.com/entry/math-risan09#i-8

はい、このコードを詳細に解説いたします。初心者の方にも理解しやすいように、段階的に説明していきます。

## 1. 全体の構造

このプログラムは主に 3 つの部分から構成されています：

1. `is_bipartite_graph` 関数：グラフが二部グラフかどうかを判定する主要な関数
2. `bfs` 関数：幅優先探索（BFS）を行う関数（`is_bipartite_graph`の中で定義）
3. `main` 関数：入力を受け取り、結果を出力する関数

## 2. グラフの表現

```python
graph = [[] for _ in range(N+1)]
for A, B in edges:
    graph[A].append(B)
    graph[B].append(A)
```

ここでは、グラフを隣接リストとして表現しています。

- `graph`は長さ`N+1`のリストで、各要素は空のリストです。
- インデックス 0 は使用せず、1 から N までの頂点番号に対応させています。
- 各辺`(A, B)`に対して、A のリストに B を、B のリストに A を追加しています。

例えば、N=4 で辺が(1,2), (2,3), (3,4)の場合：

```python
graph = [[], [2], [1,3], [2,4], [3]]
```

## 3. 色の管理

```python
color = [0] * len(graph)
```

各頂点の色を管理するリストです。

- 0: 未訪問
- 1: 色 1（例：赤）
- -1: 色 2（例：青）

## 4. 幅優先探索（BFS）

```python
def bfs(start):
    queue = deque([start])
    color[start] = 1
    while queue:
        node = queue.popleft()
        for neighbor in graph[node]:
            if color[neighbor] == 0:
                color[neighbor] = -color[node]
                queue.append(neighbor)
            elif color[neighbor] == color[node]:
                return False
    return True
```

この関数が二部グラフの判定の核心部分です。

1. 開始頂点を色 1 で塗り、キューに追加します。
2. キューから頂点を取り出し、その隣接頂点を調べます。
3. 隣接頂点が未訪問なら、現在の頂点と反対の色で塗り、キューに追加します。
4. 隣接頂点が既に同じ色で塗られていたら、二部グラフではないので False を返します。
5. すべての頂点を処理できたら、True を返します。

## 5. 全体の探索

```python
for i in range(1, N+1):
    if color[i] == 0:
        if not bfs(i):
            return 'No'
return 'Yes'
```

グラフが複数の連結成分に分かれている可能性があるため、すべての頂点をチェックします。

## 6. 具体例

N=4, 辺=(1,2), (2,3), (3,4)の場合：

1. 頂点 1 から開始：
   - 1 を赤(1)で塗る
   - 2 を青(-1)で塗る
2. 頂点 2 の隣接点をチェック：
   - 3 を赤(1)で塗る
3. 頂点 3 の隣接点をチェック：
   - 4 を青(-1)で塗る

結果：すべての隣接頂点が異なる色になるので、これは二部グラフです。

一方、N=3, 辺=(1,2), (2,3), (3,1)の場合：

1. 頂点 1 から開始：
   - 1 を赤(1)で塗る
   - 2 を青(-1)で塗る
2. 頂点 2 の隣接点をチェック：
   - 3 を赤(1)で塗る
3. 頂点 3 の隣接点をチェック：
   - 1 が既に赤で塗られているため、矛盾が発生

結果：これは二部グラフではありません。

このように、このプログラムは効率的にグラフを探索し、二部グラフかどうかを判定します。

## [参考] グラフの視覚化

### N=4, 辺=(1,2), (2,3), (3,4)の場合：

このグラフは直線状のパスグラフになります。

```
1 --- 2 --- 3 --- 4
```

このグラフは二部グラフです。頂点を以下のように 2 つのグループに分けることができます：

- グループ 1: 1, 3
- グループ 2: 2, 4

### N=3, 辺=(1,2), (2,3), (3,1)の場合：

このグラフは 3 つの頂点が互いに接続された三角形（サイクル）になります。

```
    1
   / \
  /   \
 3 --- 2
```

このグラフは二部グラフではありません。3 つの頂点が互いに接続されているため、2 つのグループに分けることができません。

これらの例は、二部グラフの性質を理解するのに役立ちます：

1. パスグラフ（N=4 の例）は常に二部グラフです。隣接する頂点を交互に異なるグループに割り当てることができます。

2. 奇数の長さを持つサイクル（N=3 の例）は二部グラフではありません。すべての頂点が互いに接続されているため、2 つのグループに分けることができません。

これらの視覚的な表現は、グラフの構造と二部グラフの概念を理解するのに役立ちます。

<br>
<br>

## [別説明] 二部グラフ判定プログラムを解説！

このプログラムは、グラフが**二部グラフ**かどうかを判定します。二部グラフとは、頂点を2つのグループに分けて、同じグループ内の頂点同士が辺で繋がっていないグラフのことです。

### 具体的な例で考えてみよう！

例えば、友達同士の関係をグラフで表すとします。

* **人:** 太郎、次郎、花子、陽子 の4人
* **関係:** 太郎と花子は友達、次郎と陽子は友達

この関係を図にすると、以下のようになります。

```
  太郎 ----- 花子
  |          |
  |          |
  次郎 ----- 陽子
```

このグラフは二部グラフです。なぜなら、

1. **グループA:** 太郎、陽子
2. **グループB:** 次郎、花子

と分けると、同じグループ内の人同士は友達関係にないからです。

### プログラムの中身を詳しく見ていきましょう！

#### 1. データ構造の準備 ( `graph`, `color` )

```python
    graph = [[] for _ in range(N+1)]
    for a, b in edges:
        graph[a].append(b)
        graph[b].append(a)

    color = [0] * len(graph)
```

* `graph`: 各頂点から、どの頂点に繋がっているかを表すリストです。
    - 例えば、 `graph[1] = [2, 3]` は、頂点1が頂点2と頂点3に繋がっていることを意味します。
* `color`: 各頂点をどちらのグループに属させるかを表すリストです。
    - 最初は全て `0` で初期化されています。
    - 後で、`1` もしくは `-1` を使ってグループ分けを行います。

#### 2. 幅優先探索で二部グラフ判定 ( `bfs` 関数)

```python
    def bfs(start):
        queue = deque([start])
        color[start] = 1
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if color[neighbor] == 0:
                    color[neighbor] = -color[node]
                    queue.append(neighbor)
                elif color[neighbor] == color[node]:
                    return False
        return True
```

* `bfs(start)`: `start` 頂点から探索を開始し、二部グラフかどうかを判定します。
    - `queue`: これから調べる頂点を格納するキューです。
    - `color[start] = 1`: まず、開始頂点の色を `1` に設定します。
    - `while queue:`: キューが空になるまで、以下の処理を繰り返します。
        - `node = queue.popleft()`: キューから頂点を一つ取り出します。
        - `for neighbor in graph[node]:`: 取り出した頂点に隣接する頂点を順番に調べます。
            - `if color[neighbor] == 0:`: まだ色が決まっていない頂点の場合
                - `color[neighbor] = -color[node]`: 取り出した頂点と反対の色に設定します。
                - `queue.append(neighbor)`: キューに追加し、後で調べます。
            - `elif color[neighbor] == color[node]:`: 既に同じ色の頂点と繋がっている場合
                - 二部グラフではないので `False` を返します。
    - 全ての頂点を調べ終わったら `True` を返します。

#### 3. 全ての頂点に対して二部グラフ判定 ( メインループ )

```python
    for i in range(1, N+1):
        if color[i] == 0:
            if not bfs(i):
                return 'No'
    return 'Yes'
```

* `for i in range(1, N+1):`: 全ての頂点に対して、以下の処理を行います。
    - `if color[i] == 0:`: まだ色が決まっていない頂点の場合
        - `if not bfs(i):`: `bfs` 関数を呼び出して二部グラフ判定を行い、`False` が返ってきたら `'No'` を出力します。
* 全ての頂点に対して `bfs` 関数が `True` を返したら `'Yes'` を出力します。

### まとめ

このプログラムは、幅優先探索を使ってグラフの頂点を2つのグループに分け、二部グラフかどうかを判定します。 `bfs` 関数で、隣接する頂点を異なる色で塗りながら探索していくことで、二部グラフかどうかの判定を実現しています。


<br>
<br>

---
# 048

このコードでは、与えられた整数 `K` の倍数のうち、その **各桁の和** が最小になる数を探索しています。具体的には、操作として次の2つを行いながら、`K` の倍数を探します。

1. 現在の数を **1増やす操作**（`u` と呼ばれる）。
2. 現在の数を **10倍する操作**（`v` と呼ばれる）。

それでは、このコードの処理過程と動作を、初心者でもわかるように例を使いながら詳しく説明します。

### 1. 問題の理解

まず、`K` の倍数の中で、その **各桁の和が最小** となる数を見つける問題です。例えば、`K = 6` の場合、「12」は 6 の倍数で、各桁の和は `1 + 2 = 3` です。この数が一番桁の和が小さいため、答えは 3 となります。

### 2. BFS（幅優先探索）の利用

この問題では「操作をして `K` の倍数を作る」という探索が必要です。この探索を効率的に行うために **BFS**（幅優先探索）を使用します。幅優先探索は、ある状態から次の状態に進む際、最も早く目的に到達する道を探す方法です。

### 3. コードの詳細解説

#### 初期化部分

```python
from collections import deque

def find_min_digit_sum(K):
    # 初期化：全ての位置について、最小桁和を無限大に設定
    dist = [10**9] * K
    # 1の位置の最小桁和を1に設定
    dist[1] = 1
    q = deque()
    q.append(1)
```

- `dist` という配列を作ります。この配列は `K` の余り（0から`K-1`）に対して、その位置に達するために必要な **最小の桁の和** を保持します。初期化時には全ての値を非常に大きな数 `10^9` に設定します（これにより後で最小の値が更新されるように）。
- 最初に `1` を操作して `K` の倍数を探し始めるため、`dist[1]` を `1` に設定します。
- BFSのキュー `q` に `1` を追加します。

#### BFSの処理部分

```python
    while q:
        pos = q.popleft()
        # 現在の位置から1増やす操作（u）と10倍する操作（v）を考える
        u = (pos + 1) % K
        v = 10 * pos % K
```

- BFSではキューに追加した数字を一つずつ取り出し、次の状態に進む操作を行います。
- `pos` は今キューから取り出した現在の余り（数）です。
- `u = (pos + 1) % K` は、現在の数に `1` を足した余りを計算しています。これは「今の位置から `1` を加えた数が、`K` に対してどんな余りを持つか」を調べています。
- `v = 10 * pos % K` は、今の数を `10` 倍した余りを計算しています。これは「今の位置から `10` をかけた数が、`K` に対してどんな余りを持つか」を調べています。

#### 移動の可能性をチェックする部分

```python
        # uへの移動が可能（最小桁和が更新される）ならば、distとキューを更新
        if dist[u] > dist[pos] + 1:
            dist[u] = dist[pos] + 1
            q.append(u)

        # vへの移動が可能（最小桁和が更新される）ならば、distとキューを更新
        if dist[v] > dist[pos]:
            dist[v] = dist[pos]
            q.append(v)
```

- `u` への移動: 現在の位置 `pos` から「1 を加えた余り `u` 」へ移動する際、**最小の桁の和** が更新されるかをチェックしています。もし、`u` の位置への最小桁の和が `現在の桁の和 + 1` よりも大きければ、`dist[u]` を更新し、新しい状態 `u` をキューに追加します。
- `v` への移動: 現在の位置 `pos` から「10 倍した余り `v` 」へ移動する際も同様に、最小桁の和が更新されるかをチェックし、必要なら更新します。

#### 結果の出力部分

```python
    return dist[0]
```

- 最終的に、余りが `0` となる状態にたどり着いた時の最小桁の和を `dist[0]` から取得し、それを返します。

### 4. 実行例

#### 例1: `K = 6`

最初に `1` を使って探索を開始します。幅優先探索の過程では次のように進みます。

- 初期状態は `1` です。
- `1` から「1 を加えた数の余り」を計算すると `(1 + 1) % 6 = 2`。また、「1 を 10 倍した数の余り」を計算すると `10 * 1 % 6 = 4` です。`dist[2]` と `dist[4]` が更新されます。
- このように進み、`12 = 6 * 2` という倍数にたどり着きます。このときの桁の和は `1 + 2 = 3` です。

出力: `3`

#### 例2: `K = 41`

この場合も、同様にして探索します。

- 最初に `1` を使って探索を開始。
- 途中で `11111 = 41 * 271` という倍数にたどり着きます。このときの桁の和は `1 + 1 + 1 + 1 + 1 = 5` です。

出力: `5`

### 5. 最後に

このコードでは、BFS を使って効率よく探索を行い、`K` の倍数を探しています。また、その倍数の桁の和を最小化するために、`1` を加えたり、`10` 倍したりする操作を利用しています。これにより、余計な計算を避けながら、最小の桁和を持つ数を効率的に見つけています。

<br>
<br>

## [補足1] 解を算出できる理由 (1増やす操作と10倍する操作)

この方法で解を算出できる理由は、**1増やす操作**と**10倍する操作**の組み合わせが、与えられた `K` の倍数のうち最小の桁和を持つ数を効率的に探すための鍵となるからです。それぞれの操作の意味を具体的に理解することで、なぜこの方法が機能するのかが分かります。

### 1. 解の探索空間

#### 倍数の性質
`K` の倍数を探す問題なので、次のような倍数を考える必要があります。

- `K`, `2K`, `3K`, `4K` … という形で `K` の倍数が次々と現れます。

倍数の中で、最も桁和が小さいものを探すことが求められているので、無駄な操作をせずに `K` の倍数を効率よく探索する方法が必要です。

### 2. 操作の解釈

#### 操作1：**1増やす操作**

`1増やす操作` は、現在の数字に `1` を足した数を考える操作です。たとえば、今 `3` という数があった場合、`3 + 1 = 4` に進みます。そして、その数を `K` で割った余りを計算します。この操作により、現在の数を少しずつ増やしていくことができます。

この操作を使う理由は、**桁の和を変えることなく、数値を少しずつ変えて倍数を探せる**ためです。

- 例えば、`6` の倍数を探している場合、`12 = 6 × 2` は解の一つです。この場合、`12` の桁の和は `1 + 2 = 3` です。ここで、もし倍数に到達する前に少し数値を加えたい場合、この操作が使えます。

#### 操作2：**10倍する操作**

`10倍する操作` は、現在の数字に `10` を掛ける操作です。たとえば、今 `3` という数があった場合、`3 × 10 = 30` に進みます。そして、その数を `K` で割った余りを計算します。この操作は桁を追加することに相当します。桁が増えることで新しい桁が加わり、より大きな倍数を探すことができます。

この操作を使う理由は、**桁の数を増やして新しい数を素早く作れる**ためです。

- 例えば、`41` の倍数を探している場合、`11111 = 41 × 271` は解の一つです。この数は `1` を連続で10倍しながら作ったものです。

#### なぜこの2つの操作が効率的なのか？

**1増やす操作**は、数を少しずつ増やしていくことで、桁和をなるべく小さく保ちながら倍数を探す手助けをします。一方、**10倍する操作**は、数を大きく動かすことで桁が増え、新しい数を生み出します。この2つの操作を組み合わせることで、数を効率的に増やしつつ、必要な倍数にたどり着けます。

### 3. なぜこのアプローチで解けるのか？

このアプローチは、「各桁の和が最小」になる条件を満たすために、**幅優先探索（BFS）** という手法を使っています。BFSは、最短の道筋を探すための探索アルゴリズムです。このアルゴリズムにおいては、同じ余りになる数字が何度も出てくることはありません。なので、最短の移動（最小の桁の和）を見つけることができるのです。

たとえば `K = 6` の場合、次のような移動が考えられます。

- `1` の状態からスタートします。
- `1` に `1` を足すと `2` になります（余り `2`）。
- `1` を 10倍すると `10` になり、`10 % 6 = 4`（余り `4`）です。
- このように探索を続けていくと、`12` に到達します。この数は `K` の倍数で、かつ桁和が最小になります（`1 + 2 = 3`）。

**BFS** によって最短のパスが見つかり、その結果、**最小の桁の和**を持つ倍数が見つかるという仕組みです。

### 4. 実際の処理過程を例で説明

#### 例1: `K = 6`

1. **初期状態**: キューには `1` が入っていて、桁和は `1` です。
2. **操作1**: `1` に `1` を足して `2`（余り `2`）になる。
3. **操作2**: `1` を `10` 倍して `10`（余り `4`）になる。
4. その後、探索が進み、`12 = 6 × 2` という倍数に到達します。このときの桁和は `1 + 2 = 3` です。

#### 例2: `K = 41`

1. **初期状態**: キューには `1` が入っていて、桁和は `1` です。
2. **操作1**: `1` に `1` を足して `2`（余り `2`）になる。
3. **操作2**: `1` を `10` 倍して `10`（余り `10`）になる。
4. 探索が進み、最終的に `11111 = 41 × 271` という倍数に到達します。このときの桁和は `1 + 1 + 1 + 1 + 1 = 5` です。

### 5. なぜ桁の和が最小化されるのか？

桁の和を小さくするためには、無駄な大きな数を避ける必要があります。このアプローチでは、探索範囲をできるだけ狭く保ち、桁が少なく済むように調整しています。`1` を加える操作は、桁の数にほとんど影響を与えずに数を増やせますし、10倍する操作は新しい桁を作るのに適しています。

この2つの操作を使うことで、効率よく数を作り出し、その中から最も桁和が小さい倍数を見つけることができます。

### まとめ

- **1増やす操作**は、桁の和をなるべく小さく保ちながら、徐々に数を増やして倍数を探すために使われます。
- **10倍する操作**は、新しい桁を作り、より大きな数を作るために使われます。
- **幅優先探索（BFS）**を使うことで、最短の桁の和を持つ倍数を効率よく探すことができ、結果として最小の桁和を見つけることが可能になります。

これらの操作を組み合わせることで、問題を解決できる理由が説明できます。

<br>
<br>

## [補足2] BFSによる有効性

「単純に `K` の倍数を順に計算していく方法」と今回のBFSによるアプローチとの違いについて、説明が不足していました。それでは、**どのように効率が違うのか**、そして**なぜこの方法が有効なのか**を丁寧に説明します。

### 1. 単純な倍数列の方法とは？

まず、単純に `K` の倍数を順に計算していく方法を考えます。

たとえば、`K = 6` の場合に `K` の倍数を1つずつ計算していくと以下のようになります。

- `6 × 1 = 6` （桁和 `6`）
- `6 × 2 = 12` （桁和 `1 + 2 = 3`）
- `6 × 3 = 18` （桁和 `1 + 8 = 9`）
- `6 × 4 = 24` （桁和 `2 + 4 = 6`）

このように、順に倍数を確認していく方法では、一つ一つの倍数を計算して、その桁の和を確認していく必要があります。この方法はシンプルですが、問題があります。

#### 問題点:
1. **非効率的**: 単純に倍数を計算して桁の和を確認していく方法では、どこで最小の桁和が現れるかがわからないため、全ての倍数を無駄に調べる可能性があります。場合によっては、非常に大きな数を計算することになり、時間がかかります。

2. **探索が遅い**: 毎回桁の和を計算する必要があるので、途中で無駄に大きな数の桁和を計算する手間が生じ、効率が悪いです。

### 2. BFSを使った方法の違い

一方、今回のBFS（幅優先探索）を使った方法は、効率的に探索を行い、最短の桁和を見つけます。

BFSを使うことで、**桁和が増えるのを最小限に抑えつつ、効率よく倍数を探索できる**理由を、以下のポイントに分けて説明します。

#### (1) 幅優先探索の利点

BFSは、「少しずつ数値を広げていきながら、最も効率的な（最小の）答えを見つける」アルゴリズムです。具体的には、現在の数に `1` を足したり、10倍する操作を行いながら、どんどん先の数を計算していきますが、常に最短の経路（最小の桁和）を探しています。

これにより、無駄な大きな数を計算することなく、早い段階で答えにたどり着けます。

#### (2) キューを使うことで探索範囲を制限

BFSでは、**キュー**というデータ構造を使って、探索する順番を管理しています。このキューの使い方により、まだ探索していない数だけを効率的に処理し、桁和が大きくならないように順番に処理します。

たとえば、`K = 6` の場合、最初に `1` の桁和からスタートし、次に `1` を足したり10倍することで、より大きな倍数を作っていきます。

#### (3) 無駄を省くためのメモ化

BFSでは、各数に対応する桁和を一度記録しておき、すでに計算済みの数は再び計算しないようにしています。これにより、無駄な計算を省き、効率的に最小の桁和を見つけます。

### 3. 単純な倍数探索との効率の比較

ここで、単純な倍数探索とBFSの方法を比較します。

#### 単純な倍数探索の場合:
- 倍数を1つずつ計算し、そのたびに桁和を調べる。たとえば、`K = 6` なら `6`, `12`, `18`, `24`, ... と順に確認。
- 大きな倍数になるほど、桁数も増えるので、桁和の計算が複雑になり、途中で桁和が大きくなる可能性が高い。
- たとえば、`K = 41` の場合、`41, 82, 123, 164, 205...` など順に調べていく必要があり、非常に非効率。

#### BFSを使った探索の場合:
- 初期値（`1` の桁和）から、少しずつ数を増やしていくことで、効率よく倍数を探す。
- 途中で大きな倍数に無駄にたどり着くことなく、最小の桁和を持つ倍数を見つけられる。
- たとえば、`K = 41` の場合、すぐに `11111` という最小の桁和を持つ倍数に到達することができる。

### 4. 効率の差：具体的な計算例

#### 例1: `K = 6`

- **単純な倍数探索**:
  1. `6 × 1 = 6`（桁和 `6`）
  2. `6 × 2 = 12`（桁和 `1 + 2 = 3`）
  3. `6 × 3 = 18`（桁和 `1 + 8 = 9`）
  4. `6 × 4 = 24`（桁和 `2 + 4 = 6`）…

  このように、桁和が無駄に増えてしまうため、効率が悪くなります。

- **BFSによる探索**:
  1. 初期値 `1`（桁和 `1`）
  2. `1` を10倍して `10`（`10 % 6 = 4`）
  3. `1` に `1` を足して `2`（`12 % 6 = 0`）→最小の桁和 `3` に到達

#### 例2: `K = 41`

- **単純な倍数探索**:
  1. `41 × 1 = 41`（桁和 `4 + 1 = 5`）
  2. `41 × 2 = 82`（桁和 `8 + 2 = 10`）
  3. `41 × 3 = 123`（桁和 `1 + 2 + 3 = 6`）…

  と無駄に大きな数を調べる必要があり、最小の桁和にすぐ到達できません。

- **BFSによる探索**:
  1. 初期値 `1`（桁和 `1`）
  2. `1` を10倍して `10`（`10 % 41 = 10`）
  3. 探索が進み、最小の桁和 `11111 = 41 × 271`（桁和 `1 + 1 + 1 + 1 + 1 = 5`）に到達

### 5. まとめ

- **単純な倍数探索**は、全ての倍数を一つずつ計算し、桁の和を調べるため、非常に効率が悪い。
- **BFSを使った探索**は、数を小さく保ちながら、効率的に最小の桁和を持つ倍数に到達することができる。
- 無駄な大きな倍数を計算せず、効率よく解を求められるため、非常に効果的。

BFSは、探索範囲を賢く制御しながら最短で桁和が最小の倍数にたどり着けるため、効率的に解を見つけられるという点が最大の利点です。

<br>
<br>

## [補足3] 計算量の違い

### 1. 単純な倍数探索の計算量

単純に `K` の倍数を順に計算していく方法では、倍数をひたすら計算し、それぞれの倍数の桁和を計算します。

#### 計算ステップ
1. `K` の倍数 `K, 2K, 3K, ..., nK` を順に計算。
2. 各倍数の桁和を計算して、最小の桁和を探す。

この方法では、桁和が最小になる倍数に到達するまで、最悪の場合に `O(K)` 回の倍数計算が必要です。そして、それぞれの倍数の桁和を計算するためには、その数の桁数に比例した計算が必要です。桁数は `log(nK)`（倍数の数の大きさに依存）で決まるため、最悪の場合は `O(log nK)` の時間がかかります。

つまり、全体の計算量は以下のようになります：

- **倍数の計算量**: 倍数を順に調べるために `O(K)` 回のループが必要。
- **桁和の計算量**: 各倍数について桁の和を計算するには `O(log nK)` 回の桁和計算が必要。

したがって、全体の時間計算量は **`O(K * log nK)`** となります。`K` の値が大きくなると、この計算が非常に遅くなり、特に `K` が大きい場合には無駄な計算が多くなります。

---

### 2. BFSを使った探索の計算量

一方、BFSを用いた探索の計算量について見ていきます。

#### 計算ステップ
1. 現在の数（`pos`）から、`u = (pos + 1) % K` と `v = 10 * pos % K` の2つの遷移をBFSで探索。
2. すでに訪れたことのある位置（`dist[pos]` で管理）には二度と遷移しないため、探索回数を減らす。

#### 計算量の分析

- **探索範囲のサイズ**: BFSでは、`K` の倍数全体を探索するわけではなく、`K` の余り `0, 1, 2, ..., K-1` のみを探索します。よって、訪れる頂点の数は最大でも `K` 個です。
- **各頂点の処理コスト**: 各頂点において、`1` を足す操作と、`10倍する` 操作の2つの遷移しかありません。つまり、各頂点で行う操作は定数時間 (`O(1)`) です。

したがって、BFSによる探索の全体の計算量は、**`O(K)`** となります。これは、`K` 個の余りに対して定数時間の処理を行うためです。

---

### 3. 計算量の比較

- **単純な倍数探索**: `O(K * log nK)`
  → `K` の値が大きくなるにつれ、計算が非効率になります。特に大きな数になると、倍数が巨大になり、その桁数の計算が非常に大きくなるため、無駄な計算が増えます。

- **BFSを使った探索**: `O(K)`
  → BFSでは、`K` に関連する余りだけを探索するので、探索する範囲が小さく、効率的です。`K` の大きさに依存せず、遷移操作はすべて定数時間で行われるため、非常に速くなります。

#### 具体例

例えば、`K = 79992` の場合を考えてみましょう。

- **単純な倍数探索**では、倍数を順に計算すると、最初の方の倍数はすぐに見つかりますが、必要な最小桁和に到達するまで非常に多くの倍数を計算し続けることになります。各倍数の桁数も次第に増えていき、その桁和を計算するコストも増えます。

- **BFS** では、余りに注目して探索を行うため、`79992` の倍数そのものではなく、`79992` に対する余りの中で効率的に最小の桁和を持つ倍数にたどり着くことができます。この方法は倍数の大きさに関わらず、`K` の余りに対する探索に限定されるので、無駄が少なく高速です。

---

### 4. 結論

- **単純な倍数探索**では、全ての倍数を順に計算していくため、無駄な倍数の計算や桁和の計算が増え、特に `K` が大きくなると非効率です。
- **BFSを使った探索**は、`K` の倍数の余りに注目して効率的に探索を行うため、無駄が少なく、計算量が `O(K)` に抑えられます。倍数そのものではなく、余りの集合に対して操作を行うので、倍数が大きくなっても処理は一定時間で行われます。

このため、BFSによる方法が桁和を求めるために非常に効率的であり、大きな `K` の値に対しても高速に解を得ることができるのです。

<br>
<br>


---
# 049

# フィボナッチ数列の効率的な計算方法：行列累乗法の解説

## はじめに

フィボナッチ数列は、次のように定義される数列です：

F(0) = 0, F(1) = 1
F(n) = F(n-1) + F(n-2) （nが2以上の場合）

例えば、最初の10項は次のようになります：
0, 1, 1, 2, 3, 5, 8, 13, 21, 34

この数列の項を素早く計算するために、行列累乗法という高度な手法を使います。

## コードの詳細解説

### 1. 行列の掛け算（`matrix_multiply`関数）

```python
def matrix_multiply(a, b, mod):
    return [
        [(a[0][0]*b[0][0] + a[0][1]*b[1][0]) % mod, (a[0][0]*b[0][1] + a[0][1]*b[1][1]) % mod],
        [(a[1][0]*b[0][0] + a[1][1]*b[1][0]) % mod, (a[1][0]*b[0][1] + a[1][1]*b[1][1]) % mod]
    ]
```

この関数は2x2の行列同士の掛け算を行います。

例えば：
```
a = [[1, 2],   b = [[5, 6],
     [3, 4]]        [7, 8]]
```
という2つの行列があった場合、

結果の[0][0]要素は：(1*5 + 2*7) % mod<br>
結果の[0][1]要素は：(1*6 + 2*8) % mod<br>
結果の[1][0]要素は：(3*5 + 4*7) % mod<br>
結果の[1][1]要素は：(3*6 + 4*8) % mod<br>

となります。

`% mod`は、数が大きくなりすぎないようにするための工夫です。

### 2. 行列のべき乗（`matrix_power`関数）

```python
def matrix_power(matrix, n, mod):
    result = [[1, 0], [0, 1]]
    while n > 0:
        if n % 2 == 1:
            result = matrix_multiply(result, matrix, mod)
        matrix = matrix_multiply(matrix, matrix, mod)
        n //= 2
    return result
```

この関数は、行列のn乗を効率的に計算します。普通に n 回掛け算すると時間がかかりすぎるので、賢い方法を使います。

例えば、matrix^8 を計算する場合：
1. 8 = 2^3 なので、(matrix^2)^2^2 と考えます。
2. matrix を2回掛けて、その結果をさらに2回掛けて、最後にもう一度2回掛ける

これにより、8回の掛け算を3回で済ませることができます。

nが13の場合（2進数で1101）：
1. matrix^1 を計算
2. それを2乗して matrix^2 を計算
3. さらに2乗して matrix^4 を計算
4. matrix^1 * matrix^4 * matrix^8 を計算

これで、13回の掛け算を5回で済ませられます。

### 3. フィボナッチ数の計算（`fibonacci_mod`関数）

```python
def fibonacci_mod(n):
    if n <= 1:
        return n
    MOD = 10**9 + 7
    matrix = [[1, 1], [1, 0]]
    result = matrix_power(matrix, n - 1, MOD)
    return result[0][0]
```

ここでは、フィボナッチ数列と行列の関係を利用します：

[[F(n+1), F(n)],   =  [[1, 1], ^ n
 [F(n),   F(n-1)]]     [1, 0]]

つまり、[[1, 1], [1, 0]] という行列のn乗の[0][0]要素が、F(n+1)になるのです。

例えば、n=5の場合：
1. [[1, 1], [1, 0]]^4 を計算（なぜ4かというと、0から数えて5番目を求めるため）
2. 結果の[0][0]要素がF(5)、つまり5番目のフィボナッチ数になります

### 4. メイン関数

```python
def main():
    N = int(input())
    print(fibonacci_mod(N))

if __name__ == "__main__":
    main()
```

この部分は、ユーザーから入力を受け取り、計算結果を表示します。

例えば、ユーザーが「10」と入力すると：
1. `fibonacci_mod(10)`が呼ばれます
2. 内部で`matrix_power([[1, 1], [1, 0]], 9, MOD)`が計算されます
3. その結果の[0][0]要素、つまり55が返されます
4. 最後に55が画面に表示されます

## まとめ

このプログラムは、行列の性質を巧みに利用して、フィボナッチ数列の項を高速に計算しています。普通の方法だとN回の計算が必要ですが、この方法だと約log(N)回の計算で済むため、特に大きな数を扱う場合に非常に効果的です。

<br>
<br>

# [補足] 上記 2. 行列のべき乗（`matrix_power`関数）
## 行列の累乗計算：効率的なアルゴリズムの解説

## はじめに

行列のn乗を計算する際、単純に n 回掛け算を行うのは非効率的です。そこで、「繰り返し二乗法」という効率的な方法を使います。この方法を理解するために、まず数値の例で考え、その後でコードがどのように動作するかを見ていきましょう。

## 数値例での説明

### 例1: 8乗の計算

8 = 2^3 = 2 * 2 * 2 なので、次のように計算できます：

1. まず2乗を計算: A^2
2. その結果をさらに2乗: (A^2)^2 = A^4
3. さらにその結果を2乗: ((A^2)^2)^2 = A^8

このように、3回の2乗計算で8乗が求められます。

### 例2: 13乗の計算

13を2進数で表すと1101です。これは次のように分解できます：
13 = 8 + 4 + 0 + 1 = 2^3 + 2^2 + 2^0

したがって、A^13 は次のように計算できます：
A^13 = A^8 * A^4 * A^1

計算手順：
1. A^1 を計算 (これは A そのもの)
2. A^2 を計算 (A * A)
3. A^4 を計算 ((A^2) * (A^2))
4. A^8 を計算 ((A^4) * (A^4))
5. 最後に A^13 = A^8 * A^4 * A^1 を計算

## コードでの実装

では、これがコードでどのように実装されているか見てみましょう：

```python
def matrix_power(matrix, n, mod):
    result = [[1, 0], [0, 1]]  # 単位行列で初期化
    while n > 0:
        if n % 2 == 1:
            result = matrix_multiply(result, matrix, mod)
        matrix = matrix_multiply(matrix, matrix, mod)
        n //= 2
    return result
```

このコードの動作を、n = 13 の場合で詳しく見ていきます：

1. 初期状態:
   - `result` = 単位行列 [[1, 0], [0, 1]]
   - `matrix` = 元の行列 A
   - n = 13 (2進数で1101)

2. 1回目のループ:
   - n = 13 (奇数)なので、`result = result * matrix`（A^1を掛ける）
   - `matrix = matrix * matrix`（A^2を計算）
   - n = 6

3. 2回目のループ:
   - n = 6 (偶数)なので、resultは変更なし
   - `matrix = matrix * matrix`（A^4を計算）
   - n = 3

4. 3回目のループ:
   - n = 3 (奇数)なので、`result = result * matrix`（A^4を掛ける）
   - `matrix = matrix * matrix`（A^8を計算）
   - n = 1

5. 4回目のループ:
   - n = 1 (奇数)なので、`result = result * matrix`（A^8を掛ける）
   - `matrix = matrix * matrix`（A^16を計算するが、使用しない）
   - n = 0

6. ループ終了

最終的に、`result`は A^1 * A^4 * A^8 = A^13 となります。

## まとめ

このアルゴリズムは、行列の累乗を効率的に計算します。n の2進表現を利用することで、必要最小限の掛け算だけを行い、計算量を大幅に削減しています。

13乗の場合、素朴な方法では13回の掛け算が必要ですが、この方法では実質5回（A^2, A^4, A^8の計算と、resultへの掛け算2回）で済みます。nが大きくなるほど、この効率の差は顕著になります。

この効率的な方法により、非常に大きな数のフィボナッチ数でも高速に計算することができるのです。

<br>
<br>

---
# 050

このコードは、非常に大きな数「aのb乗」を効率よく計算し、それを \(10^9 + 7\) で割った余りを求めるアルゴリズムを実装しています。以下、コードの各部分を初心者が理解できるように、事例を使いながら丁寧に解説していきます。

### 1. 問題の背景
通常、`a^b`（aのb乗）を計算すると、数が非常に大きくなります。例えば、`5^23` は 11920928955078125 という大きな数になります。このような大きな数をそのまま扱うと、コンピュータでの計算が非常に遅くなったり、メモリ不足が生じたりします。

そこで、数を \(10^9 + 7\) という大きな素数で割った余りを計算することで、数値を小さく保ちながら計算します。これにより、効率的に計算が行えます。

### 2. `mod_pow(a, b)` 関数の解説

この関数は「a の b 乗を \(10^9 + 7\) で割った余り」を効率的に計算します。一般に、指数が大きい場合（例えば、b が 10^9 のような値）、普通に計算すると非常に時間がかかります。そこで、「**二分累乗法**」というテクニックを使います。

では、コードの処理を詳しく見ていきましょう。

#### ステップ1: 初期設定
```python
MOD = 10**9 + 7
res = 1
```
- `MOD` は \(10^9 + 7\) のことです。これを使って割った余りを計算します。
- `res` には計算結果を保存します。最初は 1 を代入しておきます。

#### ステップ2: ループ処理（b が 0 になるまで）
```python
while b > 0:
```
`b` が 0 になるまでループを続けます。この間に、`a` を次々と二乗していき、必要に応じて `res` に結果を反映していきます。

#### ステップ3: `b` が奇数の場合の処理
```python
if b % 2 == 1:
    res = (res * a) % MOD
```
- `b % 2 == 1` は「`b` が奇数かどうか」を確認する条件です。もし `b` が奇数なら、その時点の `a` を `res` に掛けて、結果を MOD で割った余りを `res` に代入します。
- 例えば、`b = 23` の場合、最初の繰り返しで `b` は奇数です。この時、`res` に `a` を掛けたものを保存します。

#### ステップ4: `a` を二乗し、`b` を半分に
```python
a = (a * a) % MOD
b //= 2
```
- `a` を二乗し、その結果を MOD で割った余りを `a` に代入します。これにより、次のステップで `a` の二乗が計算に使われるようになります。
- `b` を半分にすることで、次のループで `a` の二乗を計算に使えるようにします。これにより、ループが効率よく進みます。

### 3. 事例を使った解説

#### 例: `a = 5`, `b = 23` の場合

この例を通じて、ループがどのように動作するかを見ていきます。

- 最初の状態:
  - `a = 5`
  - `b = 23`
  - `res = 1`
  - `MOD = 1000000007`

1. **最初のループ** (`b = 23`、奇数):
   - `b % 2 == 1` なので、`res = (res * a) % MOD = (1 * 5) % MOD = 5` となります。
   - `a = (a * a) % MOD = (5 * 5) % MOD = 25` となります。
   - `b //= 2` なので、`b = 11` になります。

2. **次のループ** (`b = 11`、奇数):
   - `b % 2 == 1` なので、`res = (res * a) % MOD = (5 * 25) % MOD = 125` となります。
   - `a = (a * a) % MOD = (25 * 25) % MOD = 625` となります。
   - `b //= 2` なので、`b = 5` になります。

3. **次のループ** (`b = 5`、奇数):
   - `b % 2 == 1` なので、`res = (res * a) % MOD = (125 * 625) % MOD = 78125` となります。
   - `a = (a * a) % MOD = (625 * 625) % MOD = 390625` となります。
   - `b //= 2` なので、`b = 2` になります。

4. **次のループ** (`b = 2`、偶数):
   - `b % 2 == 0` なので、`res` は更新されません。
   - `a = (a * a) % MOD = (390625 * 390625) % MOD = 587889561` となります。
   - `b //= 2` なので、`b = 1` になります。

5. **次のループ** (`b = 1`、奇数):
   - `b % 2 == 1` なので、`res = (res * a) % MOD = (78125 * 587889561) % MOD = 871631629` となります。
   - `a = (a * a) % MOD = (587889561 * 587889561) % MOD = 513473790` となります。
   - `b //= 2` なので、`b = 0` になり、ループが終了します。

結果として、`res = 871631629` が得られます。

### 4. `main` 関数の解説

```python
def main():
    a, b = map(int, input().split())
    print(mod_pow(a, b))
```
- `map(int, input().split())` によって、入力を整数として受け取り、それぞれ `a` と `b` に代入します。
- `mod_pow(a, b)` を呼び出して、結果を計算し、その結果を `print` で表示します。

### まとめ
このコードでは、`a^b` を直接計算するのではなく、効率よく処理するために二分累乗法を使用しています。この方法により、指数が非常に大きくても計算が高速に行えます。

<br>
<br>

## [補足] 二分累乗法について
「二分累乗法（または、累乗の二分法）」は、大きな指数の累乗を効率よく計算するためのテクニックです。この方法を使うと、普通に $a^b$ を計算するよりもはるかに少ないステップで計算できます。数学の初心者にもわかるように、この方法がどのように働くのか、基本から丁寧に説明します。

### 1. 通常の累乗計算
まず、普通に $a^b$ を計算すると、 $a$ を $b$ 回掛け算する必要があります。

例えば、 $5^{23}$ を考えてみましょう。

- $5^{23}$ を普通に計算するには、 $5 \times 5 \times 5 \times \dots \times 5$ という計算を23回繰り返さなければなりません。これにはたくさんの掛け算が必要で、 $b$ が大きいと時間がかかってしまいます。

### 2. 二分累乗法の基本アイデア
二分累乗法では、指数 $b$ を半分にしていくことで、累乗を効率的に計算します。

二分累乗法のポイントは次の2つです：
1. $b$ が **偶数** の場合、 $a^b = (a^{b/2})^2$ という性質を使います。つまり、累乗を半分に分割できます。
2. $b$ が **奇数** の場合、 $a^b = a \times a^{b-1}$ として、まず $a$ を掛けてから、残りを偶数の累乗に変えます。

### 3. 具体的な例： $5^{23}$ の計算
二分累乗法を使って、 $5^{23}$ をどのように計算するのか、ステップごとに説明します。

#### ステップ 1:
- $b = 23$ は奇数です。だから、まず $5$ を結果に掛けます（この時点で結果は $5$）。
- その後、 $b = 22$ にします（1を減らして偶数にする）。

#### ステップ 2:
- $b = 22$ は偶数なので、 $5^{22} = (5^{11})^2$ として計算できます。
- ここで、まず $5^{11}$ を計算しないといけません。

#### ステップ 3:
- $b = 11$ は奇数なので、また $5$ を結果に掛けます（現在の結果は $5 \times 5 = 25$）。
- その後、 $b = 10$ にします。

#### ステップ 4:
- $b = 10$ は偶数なので、 $5^{10} = (5^5)^2$ です。
- ここでも $5^5$ をまず計算します。

#### ステップ 5:
- $b = 5$ は奇数なので、また $5$ を結果に掛けます（現在の結果は $25 \times 5 = 125$）。
- その後、 $b = 4$ にします。

#### ステップ 6:
- $b = 4$ は偶数なので、 $5^4 = (5^2)^2$ です。
- 次に $5^2$ を計算します。

#### ステップ 7:
- $b = 2$ は偶数なので、 $5^2 = (5^1)^2$ です。
- $b = 1$ は奇数なので、また $5$ を結果に掛けます（現在の結果は $125 \times 5 = 78125$）。

#### ステップ 8:
- $b = 0$ になり、ループが終了します。この時点で、結果が得られます。

### 4. このコードにおける二分累乗法の使用箇所
このコードでは、指数 $b$ をどんどん半分にしていくという「二分累乗法」の考え方を使っています。

#### 該当する部分のコード
```python
while b > 0:
    if b % 2 == 1:
        res = (res * a) % MOD
    a = (a * a) % MOD
    b //= 2
```
- ここで `b` を半分にする（`b //= 2`）ことが「二分累乗法」です。`b` を半分にするたびに、`a` を二乗していきます（`a = (a * a) % MOD`）。
- また、`b` が奇数の場合には `res` に `a` を掛けるというステップが入ります（`res = (res * a) % MOD`）。

これにより、指数が非常に大きな場合でも、効率的に累乗の計算ができるようになっています。

### 5. 計算ステップ数の削減
通常の累乗計算では $b$ 回の掛け算が必要です。しかし、二分累乗法では $b$ の値を毎回半分にしていくため、必要な計算ステップ数は約 $\log_2(b)$ 回になります。

例えば、 $b = 23$ の場合、通常の方法なら 23 回の掛け算が必要ですが、二分累乗法を使うと約 $\log_2(23) \approx 4.5$ なので、実際には 5 回程度の掛け算で済みます。

これが、二分累乗法が非常に効率的である理由です。指数 $b$ が大きくなればなるほど、この方法のメリットが際立ちます。

### まとめ
- **二分累乗法**は、指数 $b$ を半分にしながら効率よく累乗を計算する方法です。
- この方法により、通常の $b$ 回の掛け算を $\log_2(b)$ 回の掛け算に減らすことができ、特に $b$ が大きい場合に計算が高速になります。
- このコードでは、`a` を二乗しながら `b` を半分にしていくことで、指数が非常に大きい場合でも効率的に計算を行っています。
